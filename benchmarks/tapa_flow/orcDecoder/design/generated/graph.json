{
    "cflags": [
        "-std=c++17",
        "-I",
        "/home/ylxiao/.local/lib/python3.8/site-packages/tapa/../../../src",
        "-isystem",
        "/tools/Xilinx/Vitis_HLS/2022.2/include"
    ],
    "tasks": {
        "Data_Aligner": {
            "code": "\n\n\n #include <cstdint>\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <iostream>\n\n#include <fstream>\n\n#include <string>\n\n#include <vector>\n\n#include <algorithm>\n\n#include <inttypes.h>\n\n\n #include \"ap_int.h\"\n\n#include <tapa.h>\n\n// const uint32_t dataWR_Cnt = 934640;\n// const uint32_t metaWR_Cnt = 934640;  //2147483647;\nconst uint8_t SR = 0;\nconst uint8_t DIRECT = 1;\nconst uint8_t PATCHED = 2;\nconst uint8_t DELTA = 3;\nconst uint8_t HEADER_ST = 7;\nconst uint8_t SR_STATE = 0; // 0 from 8\nconst uint8_t DI_STATE = 1; // 1 from 5\nconst uint8_t PA_STATE = 2; // 2 from 7\nconst uint8_t DE_STATE = 3; // 3 from 2\nconst uint8_t ASSIGN_DATA = 4;\nconst uint8_t PA_META_PROC = 5;\nconst uint8_t TR_HEADER = 6;\nconst uint8_t HD_PROC = 8;\nconst uint8_t waste_cycles = 9;\nconst uint16_t AXI_WIDTH_2X = 1024;\nconst uint16_t AXI_WIDTH_4X = 2048;\nconst uint16_t AXI_WIDTH = 512;\nconst uint16_t SR_DATAW = 320;\nconst uint16_t AXI_WIDTH_H = 256;\nconst uint16_t AXI_WIDTH_HH = 128;\ntypedef ap_uint<AXI_WIDTH_4X> _2048b;\ntypedef ap_uint<AXI_WIDTH_2X> _1024b;\ntypedef ap_uint<AXI_WIDTH> _512b;\ntypedef ap_int<AXI_WIDTH> _512bi;\ntypedef ap_uint<SR_DATAW> _320b;\ntypedef ap_uint<AXI_WIDTH_H> _256b;\ntypedef ap_uint<AXI_WIDTH_HH> _128b;\nconst uint16_t PEs = 16;\n// Map to bit width value.\n// const uint16_t NDelta_BitMap[32] = {1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n// const uint16_t Delta_BitMap[32] = {0,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n\nvoid mmap2s(uint64_t  input_port,\n            tapa::ostream<_512b>& outLstrm,\n            tapa::ostream<bool>& rstStrmL,\n            tapa::ostream<bool>& rstStrmMeta,\n            tapa::ostream<bool>& rstStrmStore,\n            uint32_t wait_count,\n            uint32_t data_count)\n;\nvoid load(tapa::istream<_512b>& data_in,\n            tapa::istream<bool>& rstStrm,\n            tapa::ostream<_2048b>& outAll_Lstrm,\n            tapa::ostream<_256b> &out_strmC_Track,\n            tapa::ostream<_512b>& PA_DATA,\n            tapa::ostream<uint32_t>& PA_metaDATA\n            // tapa::ostream<uint32_t>& paCnt_strm\n            // uint32_t KRNL_Data_Write\n            // uint32_t data_count\n                 )\n;\nvoid data_Sender(tapa::istream<_2048b>& data_in,\n                tapa::istream<_256b>& meta_in,\n                // tapa::istream<bool> & rst_Strm,\n                tapa::ostreams<_512b,4>& outAll_Pstrm,\n                tapa::ostream<uint64_t>& outSR_Pstrm,\n                tapa::ostreams<_256b, 4>& meta_out,\n                tapa::ostream<uint8_t>& SR_meta_out,\n                tapa::ostream<uint64_t>& All_meta_out,\n                tapa::ostream<uint8_t>& Dec_type_Out\n                // tapa::ostream<uint32_t>& data_Cnt,\n                // tapa::ostream<uint32_t>& pa_Cnt\n                )\n;\nvoid compSR(tapa::istream<uint64_t>& outSR_Pstrm,\n            tapa::istream<uint8_t>& meta_out,\n            tapa::ostream<_320b>& SR_Dout)\n;\nvoid compute_delta(tapa::istream<_512b>& in_Cstrm,\n                tapa::istream<_256b>& in_Trstrm,\n                tapa::ostream<uint32_t>& out_Cmeta_strm,\n                tapa::ostream<_512b>& out_Cstrm,\n                tapa::ostream<_512b>& DI_strm,\n                tapa::ostream<_512b>& PA_strm,\n                tapa::ostream<uint32_t>& PA_meta_strm,\n                uint32_t compD_ID)\n;\nvoid PA_meta_proc(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_meta_Strm,\n                tapa::ostream<uint64_t>& metaOutPA_Strm) //PLL, IDX, VAL\n;\nvoid PA_sum_out(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_BV_Strm,\n                tapa::ostream<_512b>& dataOutPA_Strm\n                )\n;\nvoid Meta_Aligner(tapa::istream<uint64_t>& PA_metaStrm,\n                tapa::istream<uint64_t>& All_meta_Strm,\n                tapa::ostream<_128b>& meta_Out\n                )\n;\nvoid Meta_Writer(tapa::istream<_128b>& PA_metaStrm,\n                tapa::istream<bool>& rst_StrmDS,\n                // tapa::istream<uint32_t>& complete_count,\n                uint64_t  metaPort_Out\n                // uint32_t KRNL_Data_Write\n                )\n;\nvoid delta_sumNC_in(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                // ,uint32_t ID\n                )\n;\nvoid delta_sumNC_all(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_sum_2out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm1\n                )\n;\nvoid delta_sum_1out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                )\n;\nvoid delta_sum_0out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_Fsum(tapa::istreams<_512b, 4>& delta_Strm,\n                tapa::istreams<uint32_t, 4>& meta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostreams<_512b, 4>& dataOut_Strm\n                )\n;\nvoid Data_Aligner(tapa::istream<uint8_t>& inTrackStrm,\n                tapa::istreams<_512b, 4>& inDEStrm,\n                tapa::istreams<_512b, 4>& inDIStrm,\n                tapa::istreams<_512b, 4>& inPAStrm,\n                tapa::istream<_320b>& inSRStrm,\n                tapa::ostreams<_512b, 4>& outWRStrm )\n{\n#pragma HLS disaggregate variable = inTrackStrm\n#pragma HLS interface ap_fifo port = inTrackStrm._\n#pragma HLS aggregate variable = inTrackStrm._ bit\n#pragma HLS interface ap_fifo port = inTrackStrm._peek\n#pragma HLS aggregate variable = inTrackStrm._peek bit\nvoid(inTrackStrm._.empty());\nvoid(inTrackStrm._peek.empty());\n\n#pragma HLS disaggregate variable = inDEStrm\n#pragma HLS array_partition variable = inDEStrm complete\n#pragma HLS interface ap_fifo port = inDEStrm[0]._\n#pragma HLS aggregate variable = inDEStrm[0]._ bit\n#pragma HLS interface ap_fifo port = inDEStrm[0]._peek\n#pragma HLS aggregate variable = inDEStrm[0]._peek bit\nvoid(inDEStrm[0]._.empty());\nvoid(inDEStrm[0]._peek.empty());\n#pragma HLS interface ap_fifo port = inDEStrm[1]._\n#pragma HLS aggregate variable = inDEStrm[1]._ bit\n#pragma HLS interface ap_fifo port = inDEStrm[1]._peek\n#pragma HLS aggregate variable = inDEStrm[1]._peek bit\nvoid(inDEStrm[1]._.empty());\nvoid(inDEStrm[1]._peek.empty());\n#pragma HLS interface ap_fifo port = inDEStrm[2]._\n#pragma HLS aggregate variable = inDEStrm[2]._ bit\n#pragma HLS interface ap_fifo port = inDEStrm[2]._peek\n#pragma HLS aggregate variable = inDEStrm[2]._peek bit\nvoid(inDEStrm[2]._.empty());\nvoid(inDEStrm[2]._peek.empty());\n#pragma HLS interface ap_fifo port = inDEStrm[3]._\n#pragma HLS aggregate variable = inDEStrm[3]._ bit\n#pragma HLS interface ap_fifo port = inDEStrm[3]._peek\n#pragma HLS aggregate variable = inDEStrm[3]._peek bit\nvoid(inDEStrm[3]._.empty());\nvoid(inDEStrm[3]._peek.empty());\n\n#pragma HLS disaggregate variable = inDIStrm\n#pragma HLS array_partition variable = inDIStrm complete\n#pragma HLS interface ap_fifo port = inDIStrm[0]._\n#pragma HLS aggregate variable = inDIStrm[0]._ bit\n#pragma HLS interface ap_fifo port = inDIStrm[0]._peek\n#pragma HLS aggregate variable = inDIStrm[0]._peek bit\nvoid(inDIStrm[0]._.empty());\nvoid(inDIStrm[0]._peek.empty());\n#pragma HLS interface ap_fifo port = inDIStrm[1]._\n#pragma HLS aggregate variable = inDIStrm[1]._ bit\n#pragma HLS interface ap_fifo port = inDIStrm[1]._peek\n#pragma HLS aggregate variable = inDIStrm[1]._peek bit\nvoid(inDIStrm[1]._.empty());\nvoid(inDIStrm[1]._peek.empty());\n#pragma HLS interface ap_fifo port = inDIStrm[2]._\n#pragma HLS aggregate variable = inDIStrm[2]._ bit\n#pragma HLS interface ap_fifo port = inDIStrm[2]._peek\n#pragma HLS aggregate variable = inDIStrm[2]._peek bit\nvoid(inDIStrm[2]._.empty());\nvoid(inDIStrm[2]._peek.empty());\n#pragma HLS interface ap_fifo port = inDIStrm[3]._\n#pragma HLS aggregate variable = inDIStrm[3]._ bit\n#pragma HLS interface ap_fifo port = inDIStrm[3]._peek\n#pragma HLS aggregate variable = inDIStrm[3]._peek bit\nvoid(inDIStrm[3]._.empty());\nvoid(inDIStrm[3]._peek.empty());\n\n#pragma HLS disaggregate variable = inPAStrm\n#pragma HLS array_partition variable = inPAStrm complete\n#pragma HLS interface ap_fifo port = inPAStrm[0]._\n#pragma HLS aggregate variable = inPAStrm[0]._ bit\n#pragma HLS interface ap_fifo port = inPAStrm[0]._peek\n#pragma HLS aggregate variable = inPAStrm[0]._peek bit\nvoid(inPAStrm[0]._.empty());\nvoid(inPAStrm[0]._peek.empty());\n#pragma HLS interface ap_fifo port = inPAStrm[1]._\n#pragma HLS aggregate variable = inPAStrm[1]._ bit\n#pragma HLS interface ap_fifo port = inPAStrm[1]._peek\n#pragma HLS aggregate variable = inPAStrm[1]._peek bit\nvoid(inPAStrm[1]._.empty());\nvoid(inPAStrm[1]._peek.empty());\n#pragma HLS interface ap_fifo port = inPAStrm[2]._\n#pragma HLS aggregate variable = inPAStrm[2]._ bit\n#pragma HLS interface ap_fifo port = inPAStrm[2]._peek\n#pragma HLS aggregate variable = inPAStrm[2]._peek bit\nvoid(inPAStrm[2]._.empty());\nvoid(inPAStrm[2]._peek.empty());\n#pragma HLS interface ap_fifo port = inPAStrm[3]._\n#pragma HLS aggregate variable = inPAStrm[3]._ bit\n#pragma HLS interface ap_fifo port = inPAStrm[3]._peek\n#pragma HLS aggregate variable = inPAStrm[3]._peek bit\nvoid(inPAStrm[3]._.empty());\nvoid(inPAStrm[3]._peek.empty());\n\n#pragma HLS disaggregate variable = inSRStrm\n#pragma HLS interface ap_fifo port = inSRStrm._\n#pragma HLS aggregate variable = inSRStrm._ bit\n#pragma HLS interface ap_fifo port = inSRStrm._peek\n#pragma HLS aggregate variable = inSRStrm._peek bit\nvoid(inSRStrm._.empty());\nvoid(inSRStrm._peek.empty());\n\n#pragma HLS disaggregate variable = outWRStrm\n#pragma HLS array_partition variable = outWRStrm complete\n#pragma HLS interface ap_fifo port = outWRStrm[0]._\n#pragma HLS aggregate variable = outWRStrm[0]._ bit\nvoid(outWRStrm[0]._.full());\n#pragma HLS interface ap_fifo port = outWRStrm[1]._\n#pragma HLS aggregate variable = outWRStrm[1]._ bit\nvoid(outWRStrm[1]._.full());\n#pragma HLS interface ap_fifo port = outWRStrm[2]._\n#pragma HLS aggregate variable = outWRStrm[2]._ bit\nvoid(outWRStrm[2]._.full());\n#pragma HLS interface ap_fifo port = outWRStrm[3]._\n#pragma HLS aggregate variable = outWRStrm[3]._ bit\nvoid(outWRStrm[3]._.full());\n\n    uint8_t dec_type = 0;\n    bool Read_Tr = true;\n    data_align:for( ;; )\n    {\n#pragma HLS pipeline II=1\n        if(!inTrackStrm.empty())\n        {\n            if(Read_Tr)\n            {\n                dec_type = inTrackStrm.read();\n                Read_Tr = false;\n            }\n        }\n        if(dec_type == DIRECT)\n        {\n            if((!inDIStrm[0].empty()) &&\n                (!inDIStrm[1].empty()) &&\n                (!inDIStrm[2].empty()) &&\n                (!inDIStrm[3].empty())\n                )\n            {\n                Read_Tr = true;\n                dec_type = 10;\n                write_DI:for(int i = 0; i < 4; i++)\n                {\n#pragma HLS UNROLL\n                    outWRStrm[i].write(inDIStrm[i].read());\n                }\n            }\n        }\n        else if(dec_type == DELTA)\n        {\n            if((!inDEStrm[0].empty()) &&\n                (!inDEStrm[1].empty()) &&\n                (!inDEStrm[2].empty()) &&\n                (!inDEStrm[3].empty())\n                )\n            {\n                Read_Tr = true;\n                dec_type = 10;\n                write_DE:for(int i = 0; i < 4; i++)\n                {\n#pragma HLS UNROLL\n                    outWRStrm[i].write(inDEStrm[i].read());\n                }\n            }\n        }\n        else if(dec_type == PATCHED)\n        {\n            if((!inPAStrm[0].empty()) &&\n                (!inPAStrm[1].empty()) &&\n                (!inPAStrm[2].empty()) &&\n                (!inPAStrm[3].empty())\n                )\n            {\n                Read_Tr = true;\n                dec_type = 10;\n                write_PA:for(int i = 0; i < 4; i++)\n                {\n#pragma HLS UNROLL\n                    outWRStrm[i].write(inPAStrm[i].read());\n                }\n            }\n        }\n        else\n        {\n            if(!inSRStrm.empty())\n            {\n                Read_Tr = true;\n                dec_type = 10;\n                outWRStrm[0].write(inSRStrm.read());\n                write_SR:for(int i = 1; i < 4; i++)\n                {\n#pragma HLS UNROLL\n                    outWRStrm[i].write(0);\n                }\n            }\n        }\n    }\n}\nvoid store_all(tapa::istreams<_512b, 4>& inAllStrm,\n            tapa::istream<bool>& rst_StrmL,\n            // tapa::istream<uint32_t>& dataCnt_strm,\n            uint64_t OUT0_32b_8b,\n            uint64_t OUT1_16b_8b,\n            uint64_t OUT2_16b_8b,\n            uint64_t OUT3_8b)\n;\nvoid data_decoding(uint64_t  input_port,\n                    uint64_t  output_port0_32b_8b,\n                    uint64_t  output_port1_16b_8b,\n                    uint64_t  output_port2_16b_8b,\n                    uint64_t  output_port3_8b,\n                    uint64_t  output_port4_Track,\n                    uint32_t wait_count,\n                    uint32_t data_count)\n;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "Meta_Aligner": {
            "code": "\n\n\n #include <cstdint>\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <iostream>\n\n#include <fstream>\n\n#include <string>\n\n#include <vector>\n\n#include <algorithm>\n\n#include <inttypes.h>\n\n\n #include \"ap_int.h\"\n\n#include <tapa.h>\n\n// const uint32_t dataWR_Cnt = 934640;\n// const uint32_t metaWR_Cnt = 934640;  //2147483647;\nconst uint8_t SR = 0;\nconst uint8_t DIRECT = 1;\nconst uint8_t PATCHED = 2;\nconst uint8_t DELTA = 3;\nconst uint8_t HEADER_ST = 7;\nconst uint8_t SR_STATE = 0; // 0 from 8\nconst uint8_t DI_STATE = 1; // 1 from 5\nconst uint8_t PA_STATE = 2; // 2 from 7\nconst uint8_t DE_STATE = 3; // 3 from 2\nconst uint8_t ASSIGN_DATA = 4;\nconst uint8_t PA_META_PROC = 5;\nconst uint8_t TR_HEADER = 6;\nconst uint8_t HD_PROC = 8;\nconst uint8_t waste_cycles = 9;\nconst uint16_t AXI_WIDTH_2X = 1024;\nconst uint16_t AXI_WIDTH_4X = 2048;\nconst uint16_t AXI_WIDTH = 512;\nconst uint16_t SR_DATAW = 320;\nconst uint16_t AXI_WIDTH_H = 256;\nconst uint16_t AXI_WIDTH_HH = 128;\ntypedef ap_uint<AXI_WIDTH_4X> _2048b;\ntypedef ap_uint<AXI_WIDTH_2X> _1024b;\ntypedef ap_uint<AXI_WIDTH> _512b;\ntypedef ap_int<AXI_WIDTH> _512bi;\ntypedef ap_uint<SR_DATAW> _320b;\ntypedef ap_uint<AXI_WIDTH_H> _256b;\ntypedef ap_uint<AXI_WIDTH_HH> _128b;\nconst uint16_t PEs = 16;\n// Map to bit width value.\n// const uint16_t NDelta_BitMap[32] = {1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n// const uint16_t Delta_BitMap[32] = {0,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n\nvoid mmap2s(uint64_t  input_port,\n            tapa::ostream<_512b>& outLstrm,\n            tapa::ostream<bool>& rstStrmL,\n            tapa::ostream<bool>& rstStrmMeta,\n            tapa::ostream<bool>& rstStrmStore,\n            uint32_t wait_count,\n            uint32_t data_count)\n;\nvoid load(tapa::istream<_512b>& data_in,\n            tapa::istream<bool>& rstStrm,\n            tapa::ostream<_2048b>& outAll_Lstrm,\n            tapa::ostream<_256b> &out_strmC_Track,\n            tapa::ostream<_512b>& PA_DATA,\n            tapa::ostream<uint32_t>& PA_metaDATA\n            // tapa::ostream<uint32_t>& paCnt_strm\n            // uint32_t KRNL_Data_Write\n            // uint32_t data_count\n                 )\n;\nvoid data_Sender(tapa::istream<_2048b>& data_in,\n                tapa::istream<_256b>& meta_in,\n                // tapa::istream<bool> & rst_Strm,\n                tapa::ostreams<_512b,4>& outAll_Pstrm,\n                tapa::ostream<uint64_t>& outSR_Pstrm,\n                tapa::ostreams<_256b, 4>& meta_out,\n                tapa::ostream<uint8_t>& SR_meta_out,\n                tapa::ostream<uint64_t>& All_meta_out,\n                tapa::ostream<uint8_t>& Dec_type_Out\n                // tapa::ostream<uint32_t>& data_Cnt,\n                // tapa::ostream<uint32_t>& pa_Cnt\n                )\n;\nvoid compSR(tapa::istream<uint64_t>& outSR_Pstrm,\n            tapa::istream<uint8_t>& meta_out,\n            tapa::ostream<_320b>& SR_Dout)\n;\nvoid compute_delta(tapa::istream<_512b>& in_Cstrm,\n                tapa::istream<_256b>& in_Trstrm,\n                tapa::ostream<uint32_t>& out_Cmeta_strm,\n                tapa::ostream<_512b>& out_Cstrm,\n                tapa::ostream<_512b>& DI_strm,\n                tapa::ostream<_512b>& PA_strm,\n                tapa::ostream<uint32_t>& PA_meta_strm,\n                uint32_t compD_ID)\n;\nvoid PA_meta_proc(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_meta_Strm,\n                tapa::ostream<uint64_t>& metaOutPA_Strm) //PLL, IDX, VAL\n;\nvoid PA_sum_out(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_BV_Strm,\n                tapa::ostream<_512b>& dataOutPA_Strm\n                )\n;\nvoid Meta_Aligner(tapa::istream<uint64_t>& PA_metaStrm,\n                tapa::istream<uint64_t>& All_meta_Strm,\n                tapa::ostream<_128b>& meta_Out\n                )\n{\n#pragma HLS disaggregate variable = PA_metaStrm\n#pragma HLS interface ap_fifo port = PA_metaStrm._\n#pragma HLS aggregate variable = PA_metaStrm._ bit\n#pragma HLS interface ap_fifo port = PA_metaStrm._peek\n#pragma HLS aggregate variable = PA_metaStrm._peek bit\nvoid(PA_metaStrm._.empty());\nvoid(PA_metaStrm._peek.empty());\n\n#pragma HLS disaggregate variable = All_meta_Strm\n#pragma HLS interface ap_fifo port = All_meta_Strm._\n#pragma HLS aggregate variable = All_meta_Strm._ bit\n#pragma HLS interface ap_fifo port = All_meta_Strm._peek\n#pragma HLS aggregate variable = All_meta_Strm._peek bit\nvoid(All_meta_Strm._.empty());\nvoid(All_meta_Strm._peek.empty());\n\n#pragma HLS disaggregate variable = meta_Out\n#pragma HLS interface ap_fifo port = meta_Out._\n#pragma HLS aggregate variable = meta_Out._ bit\nvoid(meta_Out._.full());\n\n    bool send_all_data = true;\n    ap_uint<128> all_meta = 0;\n    ap_uint<64> pa_meta = 0;\n    ap_uint<128> myMeta = 0;\n    uint16_t DecType = 0;\n    uint16_t runLength = 0;\n    uint32_t d_count = 0;\n    uint8_t PLL = 0;\n    uint8_t myCount = 0;\n    // bool write_all_data = false;\n    // bool write_pa_data = false;\n    // uint32_t all_cnt = 0;\n    // uint32_t pa_cnt = 0;\n    meta_align_loop:for(;;)\n    {\n        temploop:for(int i = 0; i < 2147483647; i ++)\n        {\n#pragma HLS pipeline II=1\n            if(send_all_data)\n            {\n                if(!All_meta_Strm.empty())\n                {\n                    all_meta = All_meta_Strm.read();\n                    DecType = all_meta.range(15,0);\n                    runLength = all_meta.range(31,16);\n                    myMeta = (all_meta << 64);\n                    if(DecType == PATCHED)\n                    {\n                        if(d_count < (runLength-64))\n                        {\n                            d_count+=64;\n                        }\n                        else\n                        {\n                            d_count = 0;\n                            send_all_data = false;\n                        }\n                    }\n                    // all_cnt += 1;\n                    // write_all_data = true;\n                    meta_Out.write(myMeta);\n                }\n            }\n            else\n            {\n                if(!PA_metaStrm.empty())\n                {\n                    pa_meta = PA_metaStrm.read();\n                    PLL = pa_meta.range(7,0);\n                    myMeta = (all_meta << 64) | pa_meta;\n                    if(myCount < (PLL-1))\n                    {\n                        myCount+=1;\n                    }\n                    else //(myCount ==  PLL)\n                    {\n                        myCount = 0;\n                        send_all_data = true;\n                    }\n                    // write_pa_data = true;\n                    meta_Out.write(myMeta);\n                }\n            }\n        }\n    }\n}\nvoid Meta_Writer(tapa::istream<_128b>& PA_metaStrm,\n                tapa::istream<bool>& rst_StrmDS,\n                // tapa::istream<uint32_t>& complete_count,\n                uint64_t  metaPort_Out\n                // uint32_t KRNL_Data_Write\n                )\n;\nvoid delta_sumNC_in(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                // ,uint32_t ID\n                )\n;\nvoid delta_sumNC_all(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_sum_2out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm1\n                )\n;\nvoid delta_sum_1out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                )\n;\nvoid delta_sum_0out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_Fsum(tapa::istreams<_512b, 4>& delta_Strm,\n                tapa::istreams<uint32_t, 4>& meta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostreams<_512b, 4>& dataOut_Strm\n                )\n;\nvoid Data_Aligner(tapa::istream<uint8_t>& inTrackStrm,\n                tapa::istreams<_512b, 4>& inDEStrm,\n                tapa::istreams<_512b, 4>& inDIStrm,\n                tapa::istreams<_512b, 4>& inPAStrm,\n                tapa::istream<_320b>& inSRStrm,\n                tapa::ostreams<_512b, 4>& outWRStrm )\n;\nvoid store_all(tapa::istreams<_512b, 4>& inAllStrm,\n            tapa::istream<bool>& rst_StrmL,\n            // tapa::istream<uint32_t>& dataCnt_strm,\n            uint64_t OUT0_32b_8b,\n            uint64_t OUT1_16b_8b,\n            uint64_t OUT2_16b_8b,\n            uint64_t OUT3_8b)\n;\nvoid data_decoding(uint64_t  input_port,\n                    uint64_t  output_port0_32b_8b,\n                    uint64_t  output_port1_16b_8b,\n                    uint64_t  output_port2_16b_8b,\n                    uint64_t  output_port3_8b,\n                    uint64_t  output_port4_Track,\n                    uint32_t wait_count,\n                    uint32_t data_count)\n;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "Meta_Writer": {
            "code": "\n\n\n #include <cstdint>\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <iostream>\n\n#include <fstream>\n\n#include <string>\n\n#include <vector>\n\n#include <algorithm>\n\n#include <inttypes.h>\n\n\n #include \"ap_int.h\"\n\n#include <tapa.h>\n\n// const uint32_t dataWR_Cnt = 934640;\n// const uint32_t metaWR_Cnt = 934640;  //2147483647;\nconst uint8_t SR = 0;\nconst uint8_t DIRECT = 1;\nconst uint8_t PATCHED = 2;\nconst uint8_t DELTA = 3;\nconst uint8_t HEADER_ST = 7;\nconst uint8_t SR_STATE = 0; // 0 from 8\nconst uint8_t DI_STATE = 1; // 1 from 5\nconst uint8_t PA_STATE = 2; // 2 from 7\nconst uint8_t DE_STATE = 3; // 3 from 2\nconst uint8_t ASSIGN_DATA = 4;\nconst uint8_t PA_META_PROC = 5;\nconst uint8_t TR_HEADER = 6;\nconst uint8_t HD_PROC = 8;\nconst uint8_t waste_cycles = 9;\nconst uint16_t AXI_WIDTH_2X = 1024;\nconst uint16_t AXI_WIDTH_4X = 2048;\nconst uint16_t AXI_WIDTH = 512;\nconst uint16_t SR_DATAW = 320;\nconst uint16_t AXI_WIDTH_H = 256;\nconst uint16_t AXI_WIDTH_HH = 128;\ntypedef ap_uint<AXI_WIDTH_4X> _2048b;\ntypedef ap_uint<AXI_WIDTH_2X> _1024b;\ntypedef ap_uint<AXI_WIDTH> _512b;\ntypedef ap_int<AXI_WIDTH> _512bi;\ntypedef ap_uint<SR_DATAW> _320b;\ntypedef ap_uint<AXI_WIDTH_H> _256b;\ntypedef ap_uint<AXI_WIDTH_HH> _128b;\nconst uint16_t PEs = 16;\n// Map to bit width value.\n// const uint16_t NDelta_BitMap[32] = {1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n// const uint16_t Delta_BitMap[32] = {0,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n\nvoid mmap2s(uint64_t  input_port,\n            tapa::ostream<_512b>& outLstrm,\n            tapa::ostream<bool>& rstStrmL,\n            tapa::ostream<bool>& rstStrmMeta,\n            tapa::ostream<bool>& rstStrmStore,\n            uint32_t wait_count,\n            uint32_t data_count)\n;\nvoid load(tapa::istream<_512b>& data_in,\n            tapa::istream<bool>& rstStrm,\n            tapa::ostream<_2048b>& outAll_Lstrm,\n            tapa::ostream<_256b> &out_strmC_Track,\n            tapa::ostream<_512b>& PA_DATA,\n            tapa::ostream<uint32_t>& PA_metaDATA\n            // tapa::ostream<uint32_t>& paCnt_strm\n            // uint32_t KRNL_Data_Write\n            // uint32_t data_count\n                 )\n;\nvoid data_Sender(tapa::istream<_2048b>& data_in,\n                tapa::istream<_256b>& meta_in,\n                // tapa::istream<bool> & rst_Strm,\n                tapa::ostreams<_512b,4>& outAll_Pstrm,\n                tapa::ostream<uint64_t>& outSR_Pstrm,\n                tapa::ostreams<_256b, 4>& meta_out,\n                tapa::ostream<uint8_t>& SR_meta_out,\n                tapa::ostream<uint64_t>& All_meta_out,\n                tapa::ostream<uint8_t>& Dec_type_Out\n                // tapa::ostream<uint32_t>& data_Cnt,\n                // tapa::ostream<uint32_t>& pa_Cnt\n                )\n;\nvoid compSR(tapa::istream<uint64_t>& outSR_Pstrm,\n            tapa::istream<uint8_t>& meta_out,\n            tapa::ostream<_320b>& SR_Dout)\n;\nvoid compute_delta(tapa::istream<_512b>& in_Cstrm,\n                tapa::istream<_256b>& in_Trstrm,\n                tapa::ostream<uint32_t>& out_Cmeta_strm,\n                tapa::ostream<_512b>& out_Cstrm,\n                tapa::ostream<_512b>& DI_strm,\n                tapa::ostream<_512b>& PA_strm,\n                tapa::ostream<uint32_t>& PA_meta_strm,\n                uint32_t compD_ID)\n;\nvoid PA_meta_proc(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_meta_Strm,\n                tapa::ostream<uint64_t>& metaOutPA_Strm) //PLL, IDX, VAL\n;\nvoid PA_sum_out(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_BV_Strm,\n                tapa::ostream<_512b>& dataOutPA_Strm\n                )\n;\nvoid Meta_Aligner(tapa::istream<uint64_t>& PA_metaStrm,\n                tapa::istream<uint64_t>& All_meta_Strm,\n                tapa::ostream<_128b>& meta_Out\n                )\n;\nvoid Meta_Writer(tapa::istream<_128b>& PA_metaStrm,\n                tapa::istream<bool>& rst_StrmDS,\n                // tapa::istream<uint32_t>& complete_count,\n                tapa::async_mmap<_128b>& metaPort_Out\n                // uint32_t KRNL_Data_Write\n                )\n{\n#pragma HLS disaggregate variable = PA_metaStrm\n#pragma HLS interface ap_fifo port = PA_metaStrm._\n#pragma HLS aggregate variable = PA_metaStrm._ bit\n#pragma HLS interface ap_fifo port = PA_metaStrm._peek\n#pragma HLS aggregate variable = PA_metaStrm._peek bit\nvoid(PA_metaStrm._.empty());\nvoid(PA_metaStrm._peek.empty());\n\n#pragma HLS disaggregate variable = rst_StrmDS\n#pragma HLS interface ap_fifo port = rst_StrmDS._\n#pragma HLS aggregate variable = rst_StrmDS._ bit\n#pragma HLS interface ap_fifo port = rst_StrmDS._peek\n#pragma HLS aggregate variable = rst_StrmDS._peek bit\nvoid(rst_StrmDS._.empty());\nvoid(rst_StrmDS._peek.empty());\n\n#pragma HLS disaggregate variable = metaPort_Out\n#pragma HLS interface ap_fifo port = metaPort_Out.read_addr._\n#pragma HLS aggregate variable = metaPort_Out.read_addr._  bit\n#pragma HLS interface ap_fifo port = metaPort_Out.read_data._\n#pragma HLS aggregate variable = metaPort_Out.read_data._  bit\n#pragma HLS interface ap_fifo port = metaPort_Out.write_addr._\n#pragma HLS aggregate variable = metaPort_Out.write_addr._  bit\n#pragma HLS interface ap_fifo port = metaPort_Out.write_data._\n#pragma HLS aggregate variable = metaPort_Out.write_data._  bit\n#pragma HLS interface ap_fifo port = metaPort_Out.write_resp._\n#pragma HLS aggregate variable = metaPort_Out.write_resp._  bit\n#pragma HLS disaggregate variable = metaPort_Out .read_data\n#pragma HLS interface ap_fifo port = metaPort_Out.read_data._peek\n#pragma HLS aggregate variable = metaPort_Out.read_data._peek bit\n#pragma HLS disaggregate variable = metaPort_Out .write_resp\n#pragma HLS interface ap_fifo port = metaPort_Out.write_resp._peek\n#pragma HLS aggregate variable = metaPort_Out.write_resp._peek bit\nvoid(metaPort_Out.read_addr._.full());\nvoid(metaPort_Out.read_data._.empty());\nvoid(metaPort_Out.read_data._peek.empty());\nvoid(metaPort_Out.write_addr._.full());\nvoid(metaPort_Out.write_data._.full());\nvoid(metaPort_Out.write_resp._.empty());\nvoid(metaPort_Out.write_resp._peek.empty());\n\n    uint32_t i_req_0 = 0, i_resp_0 = 0;\n    // uint32_t write_count = metaWR_Cnt; //metaWR_Cnt; //2147483647;\n    // uint32_t Rwrite_count = 0;\n    // (i_resp_0 < write_count)\n    store_meta:for( ; ; )\n    {\n#pragma HLS pipeline II=1\n        //reset Stream\n            if(!rst_StrmDS.empty())\n            {\n                bool tmp = rst_StrmDS.read();\n                i_req_0 = 0;\n            }\n        //Update Write Count\n        // if(!complete_count.empty())\n        // {\n        //     write_count = complete_count.read();\n        //     // write_count = write_count+Rwrite_count;\n        // }\n        // issue write requests\n        if((!PA_metaStrm.empty()) &&\n            (!metaPort_Out.write_addr.full()) &&\n            (!metaPort_Out.write_data.full())\n            )\n        {\n            metaPort_Out.write_addr.try_write(i_req_0);\n            metaPort_Out.write_data.try_write(PA_metaStrm.read(nullptr));\n            ++i_req_0;\n        }\n        // receive acks of write success\n        if (!metaPort_Out.write_resp.empty()) {\n            i_resp_0 = unsigned(metaPort_Out.write_resp.read(nullptr)) + 1;\n        }\n    }\n}\nvoid delta_sumNC_in(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                // ,uint32_t ID\n                )\n;\nvoid delta_sumNC_all(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_sum_2out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm1\n                )\n;\nvoid delta_sum_1out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                )\n;\nvoid delta_sum_0out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_Fsum(tapa::istreams<_512b, 4>& delta_Strm,\n                tapa::istreams<uint32_t, 4>& meta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostreams<_512b, 4>& dataOut_Strm\n                )\n;\nvoid Data_Aligner(tapa::istream<uint8_t>& inTrackStrm,\n                tapa::istreams<_512b, 4>& inDEStrm,\n                tapa::istreams<_512b, 4>& inDIStrm,\n                tapa::istreams<_512b, 4>& inPAStrm,\n                tapa::istream<_320b>& inSRStrm,\n                tapa::ostreams<_512b, 4>& outWRStrm )\n;\nvoid store_all(tapa::istreams<_512b, 4>& inAllStrm,\n            tapa::istream<bool>& rst_StrmL,\n            // tapa::istream<uint32_t>& dataCnt_strm,\n            uint64_t OUT0_32b_8b,\n            uint64_t OUT1_16b_8b,\n            uint64_t OUT2_16b_8b,\n            uint64_t OUT3_8b)\n;\nvoid data_decoding(uint64_t  input_port,\n                    uint64_t  output_port0_32b_8b,\n                    uint64_t  output_port1_16b_8b,\n                    uint64_t  output_port2_16b_8b,\n                    uint64_t  output_port3_8b,\n                    uint64_t  output_port4_Track,\n                    uint32_t wait_count,\n                    uint32_t data_count)\n;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "PA_meta_proc": {
            "code": "\n\n\n #include <cstdint>\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <iostream>\n\n#include <fstream>\n\n#include <string>\n\n#include <vector>\n\n#include <algorithm>\n\n#include <inttypes.h>\n\n\n #include \"ap_int.h\"\n\n#include <tapa.h>\n\n// const uint32_t dataWR_Cnt = 934640;\n// const uint32_t metaWR_Cnt = 934640;  //2147483647;\nconst uint8_t SR = 0;\nconst uint8_t DIRECT = 1;\nconst uint8_t PATCHED = 2;\nconst uint8_t DELTA = 3;\nconst uint8_t HEADER_ST = 7;\nconst uint8_t SR_STATE = 0; // 0 from 8\nconst uint8_t DI_STATE = 1; // 1 from 5\nconst uint8_t PA_STATE = 2; // 2 from 7\nconst uint8_t DE_STATE = 3; // 3 from 2\nconst uint8_t ASSIGN_DATA = 4;\nconst uint8_t PA_META_PROC = 5;\nconst uint8_t TR_HEADER = 6;\nconst uint8_t HD_PROC = 8;\nconst uint8_t waste_cycles = 9;\nconst uint16_t AXI_WIDTH_2X = 1024;\nconst uint16_t AXI_WIDTH_4X = 2048;\nconst uint16_t AXI_WIDTH = 512;\nconst uint16_t SR_DATAW = 320;\nconst uint16_t AXI_WIDTH_H = 256;\nconst uint16_t AXI_WIDTH_HH = 128;\ntypedef ap_uint<AXI_WIDTH_4X> _2048b;\ntypedef ap_uint<AXI_WIDTH_2X> _1024b;\ntypedef ap_uint<AXI_WIDTH> _512b;\ntypedef ap_int<AXI_WIDTH> _512bi;\ntypedef ap_uint<SR_DATAW> _320b;\ntypedef ap_uint<AXI_WIDTH_H> _256b;\ntypedef ap_uint<AXI_WIDTH_HH> _128b;\nconst uint16_t PEs = 16;\n// Map to bit width value.\n// const uint16_t NDelta_BitMap[32] = {1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n// const uint16_t Delta_BitMap[32] = {0,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n\nvoid mmap2s(uint64_t  input_port,\n            tapa::ostream<_512b>& outLstrm,\n            tapa::ostream<bool>& rstStrmL,\n            tapa::ostream<bool>& rstStrmMeta,\n            tapa::ostream<bool>& rstStrmStore,\n            uint32_t wait_count,\n            uint32_t data_count)\n;\nvoid load(tapa::istream<_512b>& data_in,\n            tapa::istream<bool>& rstStrm,\n            tapa::ostream<_2048b>& outAll_Lstrm,\n            tapa::ostream<_256b> &out_strmC_Track,\n            tapa::ostream<_512b>& PA_DATA,\n            tapa::ostream<uint32_t>& PA_metaDATA\n            // tapa::ostream<uint32_t>& paCnt_strm\n            // uint32_t KRNL_Data_Write\n            // uint32_t data_count\n                 )\n;\nvoid data_Sender(tapa::istream<_2048b>& data_in,\n                tapa::istream<_256b>& meta_in,\n                // tapa::istream<bool> & rst_Strm,\n                tapa::ostreams<_512b,4>& outAll_Pstrm,\n                tapa::ostream<uint64_t>& outSR_Pstrm,\n                tapa::ostreams<_256b, 4>& meta_out,\n                tapa::ostream<uint8_t>& SR_meta_out,\n                tapa::ostream<uint64_t>& All_meta_out,\n                tapa::ostream<uint8_t>& Dec_type_Out\n                // tapa::ostream<uint32_t>& data_Cnt,\n                // tapa::ostream<uint32_t>& pa_Cnt\n                )\n;\nvoid compSR(tapa::istream<uint64_t>& outSR_Pstrm,\n            tapa::istream<uint8_t>& meta_out,\n            tapa::ostream<_320b>& SR_Dout)\n;\nvoid compute_delta(tapa::istream<_512b>& in_Cstrm,\n                tapa::istream<_256b>& in_Trstrm,\n                tapa::ostream<uint32_t>& out_Cmeta_strm,\n                tapa::ostream<_512b>& out_Cstrm,\n                tapa::ostream<_512b>& DI_strm,\n                tapa::ostream<_512b>& PA_strm,\n                tapa::ostream<uint32_t>& PA_meta_strm,\n                uint32_t compD_ID)\n;\nvoid PA_meta_proc(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_meta_Strm,\n                tapa::ostream<uint64_t>& metaOutPA_Strm) //PLL, IDX, VAL\n{\n#pragma HLS disaggregate variable = PA_Strm\n#pragma HLS interface ap_fifo port = PA_Strm._\n#pragma HLS aggregate variable = PA_Strm._ bit\n#pragma HLS interface ap_fifo port = PA_Strm._peek\n#pragma HLS aggregate variable = PA_Strm._peek bit\nvoid(PA_Strm._.empty());\nvoid(PA_Strm._peek.empty());\n\n#pragma HLS disaggregate variable = PA_meta_Strm\n#pragma HLS interface ap_fifo port = PA_meta_Strm._\n#pragma HLS aggregate variable = PA_meta_Strm._ bit\n#pragma HLS interface ap_fifo port = PA_meta_Strm._peek\n#pragma HLS aggregate variable = PA_meta_Strm._peek bit\nvoid(PA_meta_Strm._.empty());\nvoid(PA_meta_Strm._peek.empty());\n\n#pragma HLS disaggregate variable = metaOutPA_Strm\n#pragma HLS interface ap_fifo port = metaOutPA_Strm._\n#pragma HLS aggregate variable = metaOutPA_Strm._ bit\nvoid(metaOutPA_Strm._.full());\n\n    bool dRead = true;\n    bool meta_Proc = false;\n    _512b pa_data = 0;\n    ap_uint<32> pa_meta = 0;\n    uint8_t CLBW = 0;\n    uint8_t myCLBW = 0;\n    uint8_t PW = 0;\n    uint8_t bitSize = 0;\n    uint8_t PLL = 0;\n    uint8_t pll_count = 0;\n    uint32_t pa_bytes[4] = {0};\n    ap_uint<32> pa_gap = 0;\n    uint8_t bitShifter_8b = 0;\n    uint8_t bitShifter_16b = 0;\n    uint8_t bitShifter_24b = 0;\n    uint8_t bitShifter_32b = 0;\n    uint8_t right_Shift = 0;\n    uint8_t pa_mask = 0;\n    uint32_t old_data = 0;\n    ap_uint<32> myData = 0;\n    uint16_t gap_val = 0;\n    uint32_t patch_val = 0;\n    uint64_t metaData = 0;\n    uint32_t saved_data = 0;\n    uint16_t append_shift = 0;\n    bool first_time = false;\n    // uint16_t tt_var = 0;\n    //masking data\n    const uint8_t pa_maskOLD[9] = {0,1,3,7,15,31,63,127,255}; //cannot be greater than 8 bits\n    // #pragma HLS bind_storage variable=pa_maskOLD type=ROM_2P impl=bram\n    PA_meta:for( ;; )\n    {\n#pragma HLS pipeline II=1\n        //Give cycle to stable\n        if((!PA_Strm.empty()) && (!PA_meta_Strm.empty()))\n        {\n            if(dRead)\n            {\n                dRead = false;\n                meta_Proc = true;\n                first_time = true;\n                pa_data = PA_Strm.read();\n                pa_meta = PA_meta_Strm.read(); //CLBW, PW, bitSize, PLL\n                CLBW = pa_meta.range(7,0);\n                PW = pa_meta.range(15,8);\n                bitSize = pa_meta.range(23,16);\n                PLL = pa_meta.range(31,24);\n                myCLBW = CLBW;\n            }\n        }\n        if(meta_Proc)\n        {\n            //Based on CLBW divide the data and udpate endianness\n            // bufferWriteTemp = pa_data.range(CLBW-1, 0); //BitSize any Size\n            if(first_time)\n            {\n                first_time = false;\n                uint8_t temp_var = (myCLBW%8);\n                if(temp_var != 0)\n                {\n                    myCLBW += (8-temp_var); // make it byte aligned\n                    //how many bits to throw\n                    if(CLBW > 24)\n                    {\n                        right_Shift = 32-CLBW;\n                    }\n                    else if(CLBW > 16)\n                    {\n                        right_Shift = 24-CLBW;\n                    }\n                    else if(CLBW > 8)\n                    {\n                        right_Shift = 16-CLBW;\n                    }\n                    else\n                    {\n                        right_Shift = 0;\n                    }\n                    //mask for reusing the bits in next cycle\n                    pa_mask = pa_maskOLD[right_Shift];\n                }\n                else\n                {\n                    right_Shift = 0;\n                    pa_mask = 0;\n                }\n                bitShifter_8b = myCLBW - 8;\n                bitShifter_16b = (myCLBW <= 8) ? 40 : (myCLBW - 16);\n                bitShifter_24b = (myCLBW <= 16) ? 40 : (myCLBW - 24);\n                bitShifter_32b = (myCLBW <= 24) ? 40 : (myCLBW - 32);\n            }\n            else if(pll_count >= PLL)\n            {\n                meta_Proc = false;\n                dRead = true;\n                pll_count = 0;\n                pa_data = 0;\n                old_data = 0;\n                saved_data = 0;\n                append_shift = 0;\n            }\n            else\n            {\n                // pa_data = (pa_data << right_Shift) | old_data;\n                myData = pa_data.range(myCLBW-1,0);\n                pa_gap = (myData.range(7,0) << bitShifter_8b) | (myData.range(15,8) << bitShifter_16b) |\n                        (myData.range(23,16) << bitShifter_24b) | (myData.range(31,24) << bitShifter_32b);\n                old_data = pa_gap & pa_mask;\n                saved_data = saved_data << append_shift;\n                pa_gap = pa_gap >> right_Shift;\n                pa_gap |= saved_data;\n                gap_val = pa_gap >> PW;\n                patch_val = pa_gap.range(PW-1,0);\n                patch_val = patch_val << bitSize;\n                metaData = patch_val;\n                metaData = metaData << 16 | gap_val;\n                metaData = metaData << 8 | PLL;\n                //PLL, gap_val, Patch_val\n                metaOutPA_Strm.write(metaData);\n                pa_data = pa_data >> myCLBW;\n                saved_data = old_data;\n                if((right_Shift + 8) >= CLBW)\n                {\n                    myCLBW = 8;\n                }\n                else if((right_Shift + 16) >= CLBW)\n                {\n                    myCLBW = 16;\n                }\n                else if((right_Shift + 24) >= CLBW)\n                {\n                    myCLBW = 24;\n                }\n                else if((right_Shift + 32) >= CLBW)\n                {\n                    myCLBW = 32;\n                }\n                right_Shift = (right_Shift + myCLBW) - CLBW;\n                append_shift = myCLBW - right_Shift;\n                //mask for reusing the bits in next cycle\n                pa_mask = pa_maskOLD[right_Shift];\n                bitShifter_8b = myCLBW - 8;\n                bitShifter_16b = (myCLBW <= 8) ? 40 : (myCLBW - 16);\n                bitShifter_24b = (myCLBW <= 16) ? 40 : (myCLBW - 24);\n                bitShifter_32b = (myCLBW <= 24) ? 40 : (myCLBW - 32);\n                pll_count += 1;\n            }\n        }\n    }\n}\nvoid PA_sum_out(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_BV_Strm,\n                tapa::ostream<_512b>& dataOutPA_Strm\n                )\n;\nvoid Meta_Aligner(tapa::istream<uint64_t>& PA_metaStrm,\n                tapa::istream<uint64_t>& All_meta_Strm,\n                tapa::ostream<_128b>& meta_Out\n                )\n;\nvoid Meta_Writer(tapa::istream<_128b>& PA_metaStrm,\n                tapa::istream<bool>& rst_StrmDS,\n                // tapa::istream<uint32_t>& complete_count,\n                uint64_t  metaPort_Out\n                // uint32_t KRNL_Data_Write\n                )\n;\nvoid delta_sumNC_in(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                // ,uint32_t ID\n                )\n;\nvoid delta_sumNC_all(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_sum_2out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm1\n                )\n;\nvoid delta_sum_1out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                )\n;\nvoid delta_sum_0out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_Fsum(tapa::istreams<_512b, 4>& delta_Strm,\n                tapa::istreams<uint32_t, 4>& meta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostreams<_512b, 4>& dataOut_Strm\n                )\n;\nvoid Data_Aligner(tapa::istream<uint8_t>& inTrackStrm,\n                tapa::istreams<_512b, 4>& inDEStrm,\n                tapa::istreams<_512b, 4>& inDIStrm,\n                tapa::istreams<_512b, 4>& inPAStrm,\n                tapa::istream<_320b>& inSRStrm,\n                tapa::ostreams<_512b, 4>& outWRStrm )\n;\nvoid store_all(tapa::istreams<_512b, 4>& inAllStrm,\n            tapa::istream<bool>& rst_StrmL,\n            // tapa::istream<uint32_t>& dataCnt_strm,\n            uint64_t OUT0_32b_8b,\n            uint64_t OUT1_16b_8b,\n            uint64_t OUT2_16b_8b,\n            uint64_t OUT3_8b)\n;\nvoid data_decoding(uint64_t  input_port,\n                    uint64_t  output_port0_32b_8b,\n                    uint64_t  output_port1_16b_8b,\n                    uint64_t  output_port2_16b_8b,\n                    uint64_t  output_port3_8b,\n                    uint64_t  output_port4_Track,\n                    uint32_t wait_count,\n                    uint32_t data_count)\n;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "PA_sum_out": {
            "code": "\n\n\n #include <cstdint>\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <iostream>\n\n#include <fstream>\n\n#include <string>\n\n#include <vector>\n\n#include <algorithm>\n\n#include <inttypes.h>\n\n\n #include \"ap_int.h\"\n\n#include <tapa.h>\n\n// const uint32_t dataWR_Cnt = 934640;\n// const uint32_t metaWR_Cnt = 934640;  //2147483647;\nconst uint8_t SR = 0;\nconst uint8_t DIRECT = 1;\nconst uint8_t PATCHED = 2;\nconst uint8_t DELTA = 3;\nconst uint8_t HEADER_ST = 7;\nconst uint8_t SR_STATE = 0; // 0 from 8\nconst uint8_t DI_STATE = 1; // 1 from 5\nconst uint8_t PA_STATE = 2; // 2 from 7\nconst uint8_t DE_STATE = 3; // 3 from 2\nconst uint8_t ASSIGN_DATA = 4;\nconst uint8_t PA_META_PROC = 5;\nconst uint8_t TR_HEADER = 6;\nconst uint8_t HD_PROC = 8;\nconst uint8_t waste_cycles = 9;\nconst uint16_t AXI_WIDTH_2X = 1024;\nconst uint16_t AXI_WIDTH_4X = 2048;\nconst uint16_t AXI_WIDTH = 512;\nconst uint16_t SR_DATAW = 320;\nconst uint16_t AXI_WIDTH_H = 256;\nconst uint16_t AXI_WIDTH_HH = 128;\ntypedef ap_uint<AXI_WIDTH_4X> _2048b;\ntypedef ap_uint<AXI_WIDTH_2X> _1024b;\ntypedef ap_uint<AXI_WIDTH> _512b;\ntypedef ap_int<AXI_WIDTH> _512bi;\ntypedef ap_uint<SR_DATAW> _320b;\ntypedef ap_uint<AXI_WIDTH_H> _256b;\ntypedef ap_uint<AXI_WIDTH_HH> _128b;\nconst uint16_t PEs = 16;\n// Map to bit width value.\n// const uint16_t NDelta_BitMap[32] = {1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n// const uint16_t Delta_BitMap[32] = {0,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n\nvoid mmap2s(uint64_t  input_port,\n            tapa::ostream<_512b>& outLstrm,\n            tapa::ostream<bool>& rstStrmL,\n            tapa::ostream<bool>& rstStrmMeta,\n            tapa::ostream<bool>& rstStrmStore,\n            uint32_t wait_count,\n            uint32_t data_count)\n;\nvoid load(tapa::istream<_512b>& data_in,\n            tapa::istream<bool>& rstStrm,\n            tapa::ostream<_2048b>& outAll_Lstrm,\n            tapa::ostream<_256b> &out_strmC_Track,\n            tapa::ostream<_512b>& PA_DATA,\n            tapa::ostream<uint32_t>& PA_metaDATA\n            // tapa::ostream<uint32_t>& paCnt_strm\n            // uint32_t KRNL_Data_Write\n            // uint32_t data_count\n                 )\n;\nvoid data_Sender(tapa::istream<_2048b>& data_in,\n                tapa::istream<_256b>& meta_in,\n                // tapa::istream<bool> & rst_Strm,\n                tapa::ostreams<_512b,4>& outAll_Pstrm,\n                tapa::ostream<uint64_t>& outSR_Pstrm,\n                tapa::ostreams<_256b, 4>& meta_out,\n                tapa::ostream<uint8_t>& SR_meta_out,\n                tapa::ostream<uint64_t>& All_meta_out,\n                tapa::ostream<uint8_t>& Dec_type_Out\n                // tapa::ostream<uint32_t>& data_Cnt,\n                // tapa::ostream<uint32_t>& pa_Cnt\n                )\n;\nvoid compSR(tapa::istream<uint64_t>& outSR_Pstrm,\n            tapa::istream<uint8_t>& meta_out,\n            tapa::ostream<_320b>& SR_Dout)\n;\nvoid compute_delta(tapa::istream<_512b>& in_Cstrm,\n                tapa::istream<_256b>& in_Trstrm,\n                tapa::ostream<uint32_t>& out_Cmeta_strm,\n                tapa::ostream<_512b>& out_Cstrm,\n                tapa::ostream<_512b>& DI_strm,\n                tapa::ostream<_512b>& PA_strm,\n                tapa::ostream<uint32_t>& PA_meta_strm,\n                uint32_t compD_ID)\n;\nvoid PA_meta_proc(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_meta_Strm,\n                tapa::ostream<uint64_t>& metaOutPA_Strm) //PLL, IDX, VAL\n;\nvoid PA_sum_out(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_BV_Strm,\n                tapa::ostream<_512b>& dataOutPA_Strm\n                )\n{\n#pragma HLS disaggregate variable = PA_Strm\n#pragma HLS interface ap_fifo port = PA_Strm._\n#pragma HLS aggregate variable = PA_Strm._ bit\n#pragma HLS interface ap_fifo port = PA_Strm._peek\n#pragma HLS aggregate variable = PA_Strm._peek bit\nvoid(PA_Strm._.empty());\nvoid(PA_Strm._peek.empty());\n\n#pragma HLS disaggregate variable = PA_BV_Strm\n#pragma HLS interface ap_fifo port = PA_BV_Strm._\n#pragma HLS aggregate variable = PA_BV_Strm._ bit\n#pragma HLS interface ap_fifo port = PA_BV_Strm._peek\n#pragma HLS aggregate variable = PA_BV_Strm._peek bit\nvoid(PA_BV_Strm._.empty());\nvoid(PA_BV_Strm._peek.empty());\n\n#pragma HLS disaggregate variable = dataOutPA_Strm\n#pragma HLS interface ap_fifo port = dataOutPA_Strm._\n#pragma HLS aggregate variable = dataOutPA_Strm._ bit\nvoid(dataOutPA_Strm._.full());\n\n    ap_uint<AXI_WIDTH> myNums;\n    ap_uint<AXI_WIDTH> bufferWriteStrm;\n    int32_t d[PEs] = {0};\n    int32_t num[PEs] = {0};\n    int32_t cin = 0;\n    sum_deltas0:for( ; ; )\n    {\n#pragma HLS pipeline II=1\n        if((!PA_Strm.empty()) && (!PA_BV_Strm.empty()))\n        {\n            myNums = PA_Strm.read();\n            cin = PA_BV_Strm.read();\n            delta_read:for(int i = 0; i < PEs; i++)\n            {\n#pragma HLS unroll\n                d[i] = myNums.range(((i*32)+31),(i*32));\n            }\n            sumNum:for(int i = 0; i < PEs; i++)\n            {\n#pragma HLS UNROLL\n                // #pragma HLS BIND_OP variable=num op=add impl=dsp\n                num[i] = cin + d[i]; //cin can be negative as well. Used int\n            }\n            dWriter:for(int i = 0; i < PEs; i++)\n            {\n#pragma HLS UNROLL\n                bufferWriteStrm.range(((i*32)+31),(i*32)) = num[i];\n            }\n            dataOutPA_Strm.write(bufferWriteStrm);\n        }\n    }\n}\nvoid Meta_Aligner(tapa::istream<uint64_t>& PA_metaStrm,\n                tapa::istream<uint64_t>& All_meta_Strm,\n                tapa::ostream<_128b>& meta_Out\n                )\n;\nvoid Meta_Writer(tapa::istream<_128b>& PA_metaStrm,\n                tapa::istream<bool>& rst_StrmDS,\n                // tapa::istream<uint32_t>& complete_count,\n                uint64_t  metaPort_Out\n                // uint32_t KRNL_Data_Write\n                )\n;\nvoid delta_sumNC_in(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                // ,uint32_t ID\n                )\n;\nvoid delta_sumNC_all(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_sum_2out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm1\n                )\n;\nvoid delta_sum_1out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                )\n;\nvoid delta_sum_0out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_Fsum(tapa::istreams<_512b, 4>& delta_Strm,\n                tapa::istreams<uint32_t, 4>& meta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostreams<_512b, 4>& dataOut_Strm\n                )\n;\nvoid Data_Aligner(tapa::istream<uint8_t>& inTrackStrm,\n                tapa::istreams<_512b, 4>& inDEStrm,\n                tapa::istreams<_512b, 4>& inDIStrm,\n                tapa::istreams<_512b, 4>& inPAStrm,\n                tapa::istream<_320b>& inSRStrm,\n                tapa::ostreams<_512b, 4>& outWRStrm )\n;\nvoid store_all(tapa::istreams<_512b, 4>& inAllStrm,\n            tapa::istream<bool>& rst_StrmL,\n            // tapa::istream<uint32_t>& dataCnt_strm,\n            uint64_t OUT0_32b_8b,\n            uint64_t OUT1_16b_8b,\n            uint64_t OUT2_16b_8b,\n            uint64_t OUT3_8b)\n;\nvoid data_decoding(uint64_t  input_port,\n                    uint64_t  output_port0_32b_8b,\n                    uint64_t  output_port1_16b_8b,\n                    uint64_t  output_port2_16b_8b,\n                    uint64_t  output_port3_8b,\n                    uint64_t  output_port4_Track,\n                    uint32_t wait_count,\n                    uint32_t data_count)\n;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "compSR": {
            "code": "\n\n\n #include <cstdint>\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <iostream>\n\n#include <fstream>\n\n#include <string>\n\n#include <vector>\n\n#include <algorithm>\n\n#include <inttypes.h>\n\n\n #include \"ap_int.h\"\n\n#include <tapa.h>\n\n// const uint32_t dataWR_Cnt = 934640;\n// const uint32_t metaWR_Cnt = 934640;  //2147483647;\nconst uint8_t SR = 0;\nconst uint8_t DIRECT = 1;\nconst uint8_t PATCHED = 2;\nconst uint8_t DELTA = 3;\nconst uint8_t HEADER_ST = 7;\nconst uint8_t SR_STATE = 0; // 0 from 8\nconst uint8_t DI_STATE = 1; // 1 from 5\nconst uint8_t PA_STATE = 2; // 2 from 7\nconst uint8_t DE_STATE = 3; // 3 from 2\nconst uint8_t ASSIGN_DATA = 4;\nconst uint8_t PA_META_PROC = 5;\nconst uint8_t TR_HEADER = 6;\nconst uint8_t HD_PROC = 8;\nconst uint8_t waste_cycles = 9;\nconst uint16_t AXI_WIDTH_2X = 1024;\nconst uint16_t AXI_WIDTH_4X = 2048;\nconst uint16_t AXI_WIDTH = 512;\nconst uint16_t SR_DATAW = 320;\nconst uint16_t AXI_WIDTH_H = 256;\nconst uint16_t AXI_WIDTH_HH = 128;\ntypedef ap_uint<AXI_WIDTH_4X> _2048b;\ntypedef ap_uint<AXI_WIDTH_2X> _1024b;\ntypedef ap_uint<AXI_WIDTH> _512b;\ntypedef ap_int<AXI_WIDTH> _512bi;\ntypedef ap_uint<SR_DATAW> _320b;\ntypedef ap_uint<AXI_WIDTH_H> _256b;\ntypedef ap_uint<AXI_WIDTH_HH> _128b;\nconst uint16_t PEs = 16;\n// Map to bit width value.\n// const uint16_t NDelta_BitMap[32] = {1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n// const uint16_t Delta_BitMap[32] = {0,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n\nvoid mmap2s(uint64_t  input_port,\n            tapa::ostream<_512b>& outLstrm,\n            tapa::ostream<bool>& rstStrmL,\n            tapa::ostream<bool>& rstStrmMeta,\n            tapa::ostream<bool>& rstStrmStore,\n            uint32_t wait_count,\n            uint32_t data_count)\n;\nvoid load(tapa::istream<_512b>& data_in,\n            tapa::istream<bool>& rstStrm,\n            tapa::ostream<_2048b>& outAll_Lstrm,\n            tapa::ostream<_256b> &out_strmC_Track,\n            tapa::ostream<_512b>& PA_DATA,\n            tapa::ostream<uint32_t>& PA_metaDATA\n            // tapa::ostream<uint32_t>& paCnt_strm\n            // uint32_t KRNL_Data_Write\n            // uint32_t data_count\n                 )\n;\nvoid data_Sender(tapa::istream<_2048b>& data_in,\n                tapa::istream<_256b>& meta_in,\n                // tapa::istream<bool> & rst_Strm,\n                tapa::ostreams<_512b,4>& outAll_Pstrm,\n                tapa::ostream<uint64_t>& outSR_Pstrm,\n                tapa::ostreams<_256b, 4>& meta_out,\n                tapa::ostream<uint8_t>& SR_meta_out,\n                tapa::ostream<uint64_t>& All_meta_out,\n                tapa::ostream<uint8_t>& Dec_type_Out\n                // tapa::ostream<uint32_t>& data_Cnt,\n                // tapa::ostream<uint32_t>& pa_Cnt\n                )\n;\nvoid compSR(tapa::istream<uint64_t>& outSR_Pstrm,\n            tapa::istream<uint8_t>& meta_out,\n            tapa::ostream<_320b>& SR_Dout)\n{\n#pragma HLS disaggregate variable = outSR_Pstrm\n#pragma HLS interface ap_fifo port = outSR_Pstrm._\n#pragma HLS aggregate variable = outSR_Pstrm._ bit\n#pragma HLS interface ap_fifo port = outSR_Pstrm._peek\n#pragma HLS aggregate variable = outSR_Pstrm._peek bit\nvoid(outSR_Pstrm._.empty());\nvoid(outSR_Pstrm._peek.empty());\n\n#pragma HLS disaggregate variable = meta_out\n#pragma HLS interface ap_fifo port = meta_out._\n#pragma HLS aggregate variable = meta_out._ bit\n#pragma HLS interface ap_fifo port = meta_out._peek\n#pragma HLS aggregate variable = meta_out._peek bit\nvoid(meta_out._.empty());\nvoid(meta_out._peek.empty());\n\n#pragma HLS disaggregate variable = SR_Dout\n#pragma HLS interface ap_fifo port = SR_Dout._\n#pragma HLS aggregate variable = SR_Dout._ bit\nvoid(SR_Dout._.full());\n\n    _320b bufferWriteStrm = 0;\n    uint32_t bufferUZZ = 0;\n    uint32_t bufferWrite = 0;\n    uint32_t bitShifter_32b = 0;\n    uint32_t bitShifter_24b = 0;\n    uint32_t bitShifter_16b = 0;\n    uint32_t bitShifter_8b = 0;\n    uint32_t bitSize = 0;\n    // uint8_t myMeta = 0;\n    ap_uint<64> myData = 0;\n    SR_PROC:for( ;; )\n    {\n#pragma HLS pipeline II=1\n        if((!outSR_Pstrm.empty()) && (!meta_out.empty()))\n        {\n            myData = outSR_Pstrm.read();\n            bitSize = meta_out.read();\n            // bitSize = myMeta.range(31,0);\n            bitShifter_8b = bitSize - 8;\n            bitShifter_16b = (bitSize <= 8) ? 40 : (bitSize - 16);\n            bitShifter_24b = (bitSize <= 16) ? 40 : (bitSize - 24);\n            bitShifter_32b = (bitSize <= 24) ? 40 : (bitSize - 32);\n            //EndianChange\n            bufferWrite = (myData.range(7,0) << bitShifter_8b) | (myData.range(15,8) << bitShifter_16b) |\n                            (myData.range(23,16) << bitShifter_24b) | (myData.range(31,24) << bitShifter_32b);\n            //Unzigzag\n            bufferUZZ = (ap_int<32>)((bufferWrite >> 1) ^ (-1*(bufferWrite & 1)));\n            //DataMultiplier for 10 times. Read runlength times from metadata\n            DM_SR:for(int i = 0; i < 10; i++)\n            {\n#pragma HLS UNROLL\n                bufferWriteStrm.range(((i*32)+31),(i*32)) = bufferUZZ;\n            }\n            SR_Dout.write(bufferWriteStrm);\n        }\n    }\n}\nvoid compute_delta(tapa::istream<_512b>& in_Cstrm,\n                tapa::istream<_256b>& in_Trstrm,\n                tapa::ostream<uint32_t>& out_Cmeta_strm,\n                tapa::ostream<_512b>& out_Cstrm,\n                tapa::ostream<_512b>& DI_strm,\n                tapa::ostream<_512b>& PA_strm,\n                tapa::ostream<uint32_t>& PA_meta_strm,\n                uint32_t compD_ID)\n;\nvoid PA_meta_proc(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_meta_Strm,\n                tapa::ostream<uint64_t>& metaOutPA_Strm) //PLL, IDX, VAL\n;\nvoid PA_sum_out(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_BV_Strm,\n                tapa::ostream<_512b>& dataOutPA_Strm\n                )\n;\nvoid Meta_Aligner(tapa::istream<uint64_t>& PA_metaStrm,\n                tapa::istream<uint64_t>& All_meta_Strm,\n                tapa::ostream<_128b>& meta_Out\n                )\n;\nvoid Meta_Writer(tapa::istream<_128b>& PA_metaStrm,\n                tapa::istream<bool>& rst_StrmDS,\n                // tapa::istream<uint32_t>& complete_count,\n                uint64_t  metaPort_Out\n                // uint32_t KRNL_Data_Write\n                )\n;\nvoid delta_sumNC_in(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                // ,uint32_t ID\n                )\n;\nvoid delta_sumNC_all(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_sum_2out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm1\n                )\n;\nvoid delta_sum_1out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                )\n;\nvoid delta_sum_0out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_Fsum(tapa::istreams<_512b, 4>& delta_Strm,\n                tapa::istreams<uint32_t, 4>& meta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostreams<_512b, 4>& dataOut_Strm\n                )\n;\nvoid Data_Aligner(tapa::istream<uint8_t>& inTrackStrm,\n                tapa::istreams<_512b, 4>& inDEStrm,\n                tapa::istreams<_512b, 4>& inDIStrm,\n                tapa::istreams<_512b, 4>& inPAStrm,\n                tapa::istream<_320b>& inSRStrm,\n                tapa::ostreams<_512b, 4>& outWRStrm )\n;\nvoid store_all(tapa::istreams<_512b, 4>& inAllStrm,\n            tapa::istream<bool>& rst_StrmL,\n            // tapa::istream<uint32_t>& dataCnt_strm,\n            uint64_t OUT0_32b_8b,\n            uint64_t OUT1_16b_8b,\n            uint64_t OUT2_16b_8b,\n            uint64_t OUT3_8b)\n;\nvoid data_decoding(uint64_t  input_port,\n                    uint64_t  output_port0_32b_8b,\n                    uint64_t  output_port1_16b_8b,\n                    uint64_t  output_port2_16b_8b,\n                    uint64_t  output_port3_8b,\n                    uint64_t  output_port4_Track,\n                    uint32_t wait_count,\n                    uint32_t data_count)\n;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "compute_delta": {
            "code": "\n\n\n #include <cstdint>\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <iostream>\n\n#include <fstream>\n\n#include <string>\n\n#include <vector>\n\n#include <algorithm>\n\n#include <inttypes.h>\n\n\n #include \"ap_int.h\"\n\n#include <tapa.h>\n\n// const uint32_t dataWR_Cnt = 934640;\n// const uint32_t metaWR_Cnt = 934640;  //2147483647;\nconst uint8_t SR = 0;\nconst uint8_t DIRECT = 1;\nconst uint8_t PATCHED = 2;\nconst uint8_t DELTA = 3;\nconst uint8_t HEADER_ST = 7;\nconst uint8_t SR_STATE = 0; // 0 from 8\nconst uint8_t DI_STATE = 1; // 1 from 5\nconst uint8_t PA_STATE = 2; // 2 from 7\nconst uint8_t DE_STATE = 3; // 3 from 2\nconst uint8_t ASSIGN_DATA = 4;\nconst uint8_t PA_META_PROC = 5;\nconst uint8_t TR_HEADER = 6;\nconst uint8_t HD_PROC = 8;\nconst uint8_t waste_cycles = 9;\nconst uint16_t AXI_WIDTH_2X = 1024;\nconst uint16_t AXI_WIDTH_4X = 2048;\nconst uint16_t AXI_WIDTH = 512;\nconst uint16_t SR_DATAW = 320;\nconst uint16_t AXI_WIDTH_H = 256;\nconst uint16_t AXI_WIDTH_HH = 128;\ntypedef ap_uint<AXI_WIDTH_4X> _2048b;\ntypedef ap_uint<AXI_WIDTH_2X> _1024b;\ntypedef ap_uint<AXI_WIDTH> _512b;\ntypedef ap_int<AXI_WIDTH> _512bi;\ntypedef ap_uint<SR_DATAW> _320b;\ntypedef ap_uint<AXI_WIDTH_H> _256b;\ntypedef ap_uint<AXI_WIDTH_HH> _128b;\nconst uint16_t PEs = 16;\n// Map to bit width value.\n// const uint16_t NDelta_BitMap[32] = {1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n// const uint16_t Delta_BitMap[32] = {0,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n\nvoid mmap2s(uint64_t  input_port,\n            tapa::ostream<_512b>& outLstrm,\n            tapa::ostream<bool>& rstStrmL,\n            tapa::ostream<bool>& rstStrmMeta,\n            tapa::ostream<bool>& rstStrmStore,\n            uint32_t wait_count,\n            uint32_t data_count)\n;\nvoid load(tapa::istream<_512b>& data_in,\n            tapa::istream<bool>& rstStrm,\n            tapa::ostream<_2048b>& outAll_Lstrm,\n            tapa::ostream<_256b> &out_strmC_Track,\n            tapa::ostream<_512b>& PA_DATA,\n            tapa::ostream<uint32_t>& PA_metaDATA\n            // tapa::ostream<uint32_t>& paCnt_strm\n            // uint32_t KRNL_Data_Write\n            // uint32_t data_count\n                 )\n;\nvoid data_Sender(tapa::istream<_2048b>& data_in,\n                tapa::istream<_256b>& meta_in,\n                // tapa::istream<bool> & rst_Strm,\n                tapa::ostreams<_512b,4>& outAll_Pstrm,\n                tapa::ostream<uint64_t>& outSR_Pstrm,\n                tapa::ostreams<_256b, 4>& meta_out,\n                tapa::ostream<uint8_t>& SR_meta_out,\n                tapa::ostream<uint64_t>& All_meta_out,\n                tapa::ostream<uint8_t>& Dec_type_Out\n                // tapa::ostream<uint32_t>& data_Cnt,\n                // tapa::ostream<uint32_t>& pa_Cnt\n                )\n;\nvoid compSR(tapa::istream<uint64_t>& outSR_Pstrm,\n            tapa::istream<uint8_t>& meta_out,\n            tapa::ostream<_320b>& SR_Dout)\n;\nvoid compute_delta(tapa::istream<_512b>& in_Cstrm,\n                tapa::istream<_256b>& in_Trstrm,\n                tapa::ostream<uint32_t>& out_Cmeta_strm,\n                tapa::ostream<_512b>& out_Cstrm,\n                tapa::ostream<_512b>& DI_strm,\n                tapa::ostream<_512b>& PA_strm,\n                tapa::ostream<uint32_t>& PA_meta_strm,\n                uint32_t compD_ID)\n{\n#pragma HLS disaggregate variable = in_Cstrm\n#pragma HLS interface ap_fifo port = in_Cstrm._\n#pragma HLS aggregate variable = in_Cstrm._ bit\n#pragma HLS interface ap_fifo port = in_Cstrm._peek\n#pragma HLS aggregate variable = in_Cstrm._peek bit\nvoid(in_Cstrm._.empty());\nvoid(in_Cstrm._peek.empty());\n\n#pragma HLS disaggregate variable = in_Trstrm\n#pragma HLS interface ap_fifo port = in_Trstrm._\n#pragma HLS aggregate variable = in_Trstrm._ bit\n#pragma HLS interface ap_fifo port = in_Trstrm._peek\n#pragma HLS aggregate variable = in_Trstrm._peek bit\nvoid(in_Trstrm._.empty());\nvoid(in_Trstrm._peek.empty());\n\n#pragma HLS disaggregate variable = out_Cmeta_strm\n#pragma HLS interface ap_fifo port = out_Cmeta_strm._\n#pragma HLS aggregate variable = out_Cmeta_strm._ bit\nvoid(out_Cmeta_strm._.full());\n\n#pragma HLS disaggregate variable = out_Cstrm\n#pragma HLS interface ap_fifo port = out_Cstrm._\n#pragma HLS aggregate variable = out_Cstrm._ bit\nvoid(out_Cstrm._.full());\n\n#pragma HLS disaggregate variable = DI_strm\n#pragma HLS interface ap_fifo port = DI_strm._\n#pragma HLS aggregate variable = DI_strm._ bit\nvoid(DI_strm._.full());\n\n#pragma HLS disaggregate variable = PA_strm\n#pragma HLS interface ap_fifo port = PA_strm._\n#pragma HLS aggregate variable = PA_strm._ bit\nvoid(PA_strm._.full());\n\n#pragma HLS disaggregate variable = PA_meta_strm\n#pragma HLS interface ap_fifo port = PA_meta_strm._\n#pragma HLS aggregate variable = PA_meta_strm._ bit\nvoid(PA_meta_strm._.full());\n\n\n    ap_uint<AXI_WIDTH> data_buffer = 0;\n    _256b track_buffer = 0;\n    uint32_t bitSize = 0;\n    uint8_t DecType = 0; //Last Data Cycle Flag\n    uint32_t BSF = 0; //Batch Start Flag\n    int32_t BV = 0;\n    int32_t DB = 0;\n    // uint16_t runLength = 0;\n    uint32_t metadata = 0;\n    ap_uint<32> bufferWriteTemp[PEs] = {0};\n    int32_t bufferWrite[PEs] = {0};\n    ap_uint<AXI_WIDTH> bufferWriteStrm = 0;\n    bool disableShift = false;\n    uint32_t bitShifter_32b = 0;\n    uint32_t bitShifter_24b = 0;\n    uint32_t bitShifter_16b = 0;\n    uint32_t bitShifter_8b = 0;\n    // #pragma HLS bind_storage variable=bufferWrite type=RAM_2P impl=bram\n    // #pragma HLS bind_storage variable=bufferWriteTemp type=RAM_2P impl=bram\n    compute_deltas:for(;;)\n    {\n#pragma HLS pipeline II=1\n        if((!in_Cstrm.empty()) && (!in_Trstrm.empty()))\n        {\n            bufferWriteStrm = 0;\n            bufferWriteTemp[PEs-1] = {0};\n            bufferWrite[PEs-1] = {0};\n            data_buffer = in_Cstrm.read();\n            //Data (BITSIZE, DecType, BSF, BV, DB)\n            track_buffer = in_Trstrm.read();\n            bitSize = track_buffer.range(31,0);\n            DecType = track_buffer.range(63,32);\n            // runLength = track_buffer.range(95,64);\n            BSF = track_buffer.range(127,96);\n            BV = track_buffer.range(159,128);\n            DB = track_buffer.range(191,160);\n            disableShift = track_buffer.range(193,192);\n            bitShifter_8b = bitSize - 8;\n            bitShifter_16b = (bitSize <= 8) ? 40 : (bitSize - 16);\n            bitShifter_24b = (bitSize <= 16) ? 40 : (bitSize - 24);\n            bitShifter_32b = (bitSize <= 24) ? 40 : (bitSize - 32);\n            DELTA_di_load:for(int i = 0; i < PEs; i++) //16\n            {\n#pragma HLS UNROLL\n                bufferWriteTemp[i] = data_buffer.range(((i+1)*bitSize)-1, i*bitSize); //BitSize == 32\n            }\n            if(disableShift)\n            {\n                delta_cpy:for(int i = 0; i < PEs; i++)\n                {\n#pragma HLS UNROLL\n                    bufferWrite[i] = bufferWriteTemp[i];\n                }\n            }\n            else\n            {\n                DELTA_di_endian:for(int i = 0; i < PEs; i++)\n                {\n#pragma HLS UNROLL\n                    bufferWrite[i] = (bufferWriteTemp[i].range(7,0) << bitShifter_8b) | (bufferWriteTemp[i].range(15,8) << bitShifter_16b) |\n                                    (bufferWriteTemp[i].range(23,16) << bitShifter_24b) | (bufferWriteTemp[i].range(31,24) << bitShifter_32b);\n                }\n            }\n            if(DecType == DIRECT)\n            {\n                unzigzag:for(int i = 0; i < PEs; i++)\n                {\n#pragma HLS UNROLL\n                    bufferWriteStrm.range(((i*32)+31),(i*32)) = (ap_int<32>)((((ap_uint<32>)bufferWrite[i]) >> 1) ^ (-1*(((ap_uint<32>)bufferWrite[i]) & 1)));\n                }\n                DI_strm.write(bufferWriteStrm);\n            }\n            else\n            {\n                if(DB < 0)\n                {\n                    NO_unzigzagA:for(int i = 0; i < PEs; i++)\n                    {\n#pragma HLS UNROLL\n                        bufferWriteStrm.range(((i*32)+31),(i*32)) = (int32_t)(-1*bufferWrite[i]);\n                    }\n                }\n                else\n                {\n                    NO_unzigzagB:for(int i = 0; i < PEs; i++)\n                    {\n#pragma HLS UNROLL\n                        bufferWriteStrm.range(((i*32)+31),(i*32)) = bufferWrite[i];\n                    }\n                }\n                if(DecType == DELTA)\n                {\n                    if(compD_ID == 0)\n                    {\n                        metadata = BSF;\n                        //Data (BSF, FDCF, LDCF)\n                        out_Cmeta_strm.write(metadata);\n                        if(BSF == 1)\n                        {\n                            bufferWriteStrm = (bufferWriteStrm << 32)| (uint32_t)(DB);\n                            bufferWriteStrm = (bufferWriteStrm << 32) | (uint32_t)(BV);\n                        }\n                        else\n                        {\n                            bufferWriteStrm = bufferWriteStrm;\n                        }\n                    }\n                    else\n                    {\n                        bufferWriteStrm = bufferWriteStrm;\n                    }\n                    out_Cstrm.write(bufferWriteStrm);\n                }\n                else\n                {\n                    PA_meta_strm.write((uint32_t)(BV)); //convert to int in the accumulator\n                    PA_strm.write(bufferWriteStrm);\n                }\n            }\n        }\n    }\n}\nvoid PA_meta_proc(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_meta_Strm,\n                tapa::ostream<uint64_t>& metaOutPA_Strm) //PLL, IDX, VAL\n;\nvoid PA_sum_out(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_BV_Strm,\n                tapa::ostream<_512b>& dataOutPA_Strm\n                )\n;\nvoid Meta_Aligner(tapa::istream<uint64_t>& PA_metaStrm,\n                tapa::istream<uint64_t>& All_meta_Strm,\n                tapa::ostream<_128b>& meta_Out\n                )\n;\nvoid Meta_Writer(tapa::istream<_128b>& PA_metaStrm,\n                tapa::istream<bool>& rst_StrmDS,\n                // tapa::istream<uint32_t>& complete_count,\n                uint64_t  metaPort_Out\n                // uint32_t KRNL_Data_Write\n                )\n;\nvoid delta_sumNC_in(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                // ,uint32_t ID\n                )\n;\nvoid delta_sumNC_all(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_sum_2out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm1\n                )\n;\nvoid delta_sum_1out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                )\n;\nvoid delta_sum_0out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_Fsum(tapa::istreams<_512b, 4>& delta_Strm,\n                tapa::istreams<uint32_t, 4>& meta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostreams<_512b, 4>& dataOut_Strm\n                )\n;\nvoid Data_Aligner(tapa::istream<uint8_t>& inTrackStrm,\n                tapa::istreams<_512b, 4>& inDEStrm,\n                tapa::istreams<_512b, 4>& inDIStrm,\n                tapa::istreams<_512b, 4>& inPAStrm,\n                tapa::istream<_320b>& inSRStrm,\n                tapa::ostreams<_512b, 4>& outWRStrm )\n;\nvoid store_all(tapa::istreams<_512b, 4>& inAllStrm,\n            tapa::istream<bool>& rst_StrmL,\n            // tapa::istream<uint32_t>& dataCnt_strm,\n            uint64_t OUT0_32b_8b,\n            uint64_t OUT1_16b_8b,\n            uint64_t OUT2_16b_8b,\n            uint64_t OUT3_8b)\n;\nvoid data_decoding(uint64_t  input_port,\n                    uint64_t  output_port0_32b_8b,\n                    uint64_t  output_port1_16b_8b,\n                    uint64_t  output_port2_16b_8b,\n                    uint64_t  output_port3_8b,\n                    uint64_t  output_port4_Track,\n                    uint32_t wait_count,\n                    uint32_t data_count)\n;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "data_Sender": {
            "code": "\n\n\n #include <cstdint>\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <iostream>\n\n#include <fstream>\n\n#include <string>\n\n#include <vector>\n\n#include <algorithm>\n\n#include <inttypes.h>\n\n\n #include \"ap_int.h\"\n\n#include <tapa.h>\n\n// const uint32_t dataWR_Cnt = 934640;\n// const uint32_t metaWR_Cnt = 934640;  //2147483647;\nconst uint8_t SR = 0;\nconst uint8_t DIRECT = 1;\nconst uint8_t PATCHED = 2;\nconst uint8_t DELTA = 3;\nconst uint8_t HEADER_ST = 7;\nconst uint8_t SR_STATE = 0; // 0 from 8\nconst uint8_t DI_STATE = 1; // 1 from 5\nconst uint8_t PA_STATE = 2; // 2 from 7\nconst uint8_t DE_STATE = 3; // 3 from 2\nconst uint8_t ASSIGN_DATA = 4;\nconst uint8_t PA_META_PROC = 5;\nconst uint8_t TR_HEADER = 6;\nconst uint8_t HD_PROC = 8;\nconst uint8_t waste_cycles = 9;\nconst uint16_t AXI_WIDTH_2X = 1024;\nconst uint16_t AXI_WIDTH_4X = 2048;\nconst uint16_t AXI_WIDTH = 512;\nconst uint16_t SR_DATAW = 320;\nconst uint16_t AXI_WIDTH_H = 256;\nconst uint16_t AXI_WIDTH_HH = 128;\ntypedef ap_uint<AXI_WIDTH_4X> _2048b;\ntypedef ap_uint<AXI_WIDTH_2X> _1024b;\ntypedef ap_uint<AXI_WIDTH> _512b;\ntypedef ap_int<AXI_WIDTH> _512bi;\ntypedef ap_uint<SR_DATAW> _320b;\ntypedef ap_uint<AXI_WIDTH_H> _256b;\ntypedef ap_uint<AXI_WIDTH_HH> _128b;\nconst uint16_t PEs = 16;\n// Map to bit width value.\n// const uint16_t NDelta_BitMap[32] = {1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n// const uint16_t Delta_BitMap[32] = {0,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n\nvoid mmap2s(uint64_t  input_port,\n            tapa::ostream<_512b>& outLstrm,\n            tapa::ostream<bool>& rstStrmL,\n            tapa::ostream<bool>& rstStrmMeta,\n            tapa::ostream<bool>& rstStrmStore,\n            uint32_t wait_count,\n            uint32_t data_count)\n;\nvoid load(tapa::istream<_512b>& data_in,\n            tapa::istream<bool>& rstStrm,\n            tapa::ostream<_2048b>& outAll_Lstrm,\n            tapa::ostream<_256b> &out_strmC_Track,\n            tapa::ostream<_512b>& PA_DATA,\n            tapa::ostream<uint32_t>& PA_metaDATA\n            // tapa::ostream<uint32_t>& paCnt_strm\n            // uint32_t KRNL_Data_Write\n            // uint32_t data_count\n                 )\n;\nvoid data_Sender(tapa::istream<_2048b>& data_in,\n                tapa::istream<_256b>& meta_in,\n                // tapa::istream<bool> & rst_Strm,\n                tapa::ostreams<_512b,4>& outAll_Pstrm,\n                tapa::ostream<uint64_t>& outSR_Pstrm,\n                tapa::ostreams<_256b, 4>& meta_out,\n                tapa::ostream<uint8_t>& SR_meta_out,\n                tapa::ostream<uint64_t>& All_meta_out,\n                tapa::ostream<uint8_t>& Dec_type_Out\n                // tapa::ostream<uint32_t>& data_Cnt,\n                // tapa::ostream<uint32_t>& pa_Cnt\n                )\n{\n#pragma HLS disaggregate variable = data_in\n#pragma HLS interface ap_fifo port = data_in._\n#pragma HLS aggregate variable = data_in._ bit\n#pragma HLS interface ap_fifo port = data_in._peek\n#pragma HLS aggregate variable = data_in._peek bit\nvoid(data_in._.empty());\nvoid(data_in._peek.empty());\n\n#pragma HLS disaggregate variable = meta_in\n#pragma HLS interface ap_fifo port = meta_in._\n#pragma HLS aggregate variable = meta_in._ bit\n#pragma HLS interface ap_fifo port = meta_in._peek\n#pragma HLS aggregate variable = meta_in._peek bit\nvoid(meta_in._.empty());\nvoid(meta_in._peek.empty());\n\n#pragma HLS disaggregate variable = outAll_Pstrm\n#pragma HLS array_partition variable = outAll_Pstrm complete\n#pragma HLS interface ap_fifo port = outAll_Pstrm[0]._\n#pragma HLS aggregate variable = outAll_Pstrm[0]._ bit\nvoid(outAll_Pstrm[0]._.full());\n#pragma HLS interface ap_fifo port = outAll_Pstrm[1]._\n#pragma HLS aggregate variable = outAll_Pstrm[1]._ bit\nvoid(outAll_Pstrm[1]._.full());\n#pragma HLS interface ap_fifo port = outAll_Pstrm[2]._\n#pragma HLS aggregate variable = outAll_Pstrm[2]._ bit\nvoid(outAll_Pstrm[2]._.full());\n#pragma HLS interface ap_fifo port = outAll_Pstrm[3]._\n#pragma HLS aggregate variable = outAll_Pstrm[3]._ bit\nvoid(outAll_Pstrm[3]._.full());\n\n#pragma HLS disaggregate variable = outSR_Pstrm\n#pragma HLS interface ap_fifo port = outSR_Pstrm._\n#pragma HLS aggregate variable = outSR_Pstrm._ bit\nvoid(outSR_Pstrm._.full());\n\n#pragma HLS disaggregate variable = meta_out\n#pragma HLS array_partition variable = meta_out complete\n#pragma HLS interface ap_fifo port = meta_out[0]._\n#pragma HLS aggregate variable = meta_out[0]._ bit\nvoid(meta_out[0]._.full());\n#pragma HLS interface ap_fifo port = meta_out[1]._\n#pragma HLS aggregate variable = meta_out[1]._ bit\nvoid(meta_out[1]._.full());\n#pragma HLS interface ap_fifo port = meta_out[2]._\n#pragma HLS aggregate variable = meta_out[2]._ bit\nvoid(meta_out[2]._.full());\n#pragma HLS interface ap_fifo port = meta_out[3]._\n#pragma HLS aggregate variable = meta_out[3]._ bit\nvoid(meta_out[3]._.full());\n\n#pragma HLS disaggregate variable = SR_meta_out\n#pragma HLS interface ap_fifo port = SR_meta_out._\n#pragma HLS aggregate variable = SR_meta_out._ bit\nvoid(SR_meta_out._.full());\n\n#pragma HLS disaggregate variable = All_meta_out\n#pragma HLS interface ap_fifo port = All_meta_out._\n#pragma HLS aggregate variable = All_meta_out._ bit\nvoid(All_meta_out._.full());\n\n#pragma HLS disaggregate variable = Dec_type_Out\n#pragma HLS interface ap_fifo port = Dec_type_Out._\n#pragma HLS aggregate variable = Dec_type_Out._ bit\nvoid(Dec_type_Out._.full());\n\n    bool dRead = true;\n    bool proc = false;\n    // bool my_proc =false;\n    _2048b myData = 0;\n    _512b tempData = 0;\n    _256b metaData = 0;\n    _256b MymetaData = 0;\n    uint32_t DrunLength = 0;\n    uint32_t d_count = 0;\n    uint8_t bitSize = 0;\n    uint8_t DecType = 0;\n    uint32_t runLength = 0;\n    bool BSF = 0;\n    bool mBSF = 0;\n    uint32_t BV = 0;\n    uint32_t DB = 0;\n    uint32_t SDS = 0;\n    uint32_t T_CYCLES = 0;\n    uint32_t PLL = 0;\n    uint32_t data_counter = 0;\n    uint32_t pa_counter = 0;\n    uint64_t metaPort_D = 0;\n    uint32_t PLL_SUM = 0;\n    // uint32_t temp_counter = 0;\n    data_sender:for(;;)\n    {\n#pragma HLS pipeline II=1\n        if(dRead)\n        {\n            if((!data_in.empty()) && (!meta_in.empty()))\n            {\n                proc = true;\n                myData = data_in.read();\n                metaData = meta_in.read();\n                DrunLength = myData.range(31,0);\n                bitSize = metaData.range(31,0);\n                DecType = metaData.range(63,32);\n                runLength = metaData.range(95,64);\n                BSF = metaData.range(127,96);\n                BV = metaData.range(159,128);\n                DB = metaData.range(191,160);\n                SDS = metaData.range(223,192);\n                PLL = metaData.range(255,224);\n                mBSF = BSF;\n                T_CYCLES = DrunLength;\n                dRead = (bitSize!=0) ? true:false;\n            }\n            //////////////////////////////////////////////\n        }\n        if(proc)\n        {\n            Dec_type_Out.write(DecType); //for data_aligner to check the streams\n            metaPort_D = BV;\n            metaPort_D = (metaPort_D << 16) | runLength;\n            metaPort_D = (metaPort_D << 16) | DecType;\n            //DecType, RL , BV\n            All_meta_out.write(metaPort_D); //Send Data for metaData Port required to handle patched\n            if(bitSize != 0)\n            {\n                proc = false;\n                // dRead = true;\n                MymetaData = metaData;\n                MymetaData.range(193,192) = 0; //Changes the endianness when it is 0\n                if(DecType == SR)\n                {\n                    outSR_Pstrm.write(myData.range(bitSize-1,0));\n                }\n                else if(BSF) //for delta only, for SR this is also 1\n                {\n                    if(bitSize == 32)\n                    {\n                        outAll_Pstrm[0].write(myData.range(447,0)); //Sending 448bits ~ 14Deltas\n                        outAll_Pstrm[1].write(myData.range(959,448)); //Sending 512*3bits ~ 16*3Deltas\n                        outAll_Pstrm[2].write(myData.range(1471,960)); //Sending 512*3bits ~ 16*3Deltas\n                        outAll_Pstrm[3].write(myData.range(1983,1472)); //Sending 512*3bits ~ 16*3Deltas\n                    }\n                    else if(bitSize == 24)\n                    {\n                        outAll_Pstrm[0].write(myData.range(335,0)); //Sending 336 ~ 14Deltas\n                        outAll_Pstrm[1].write(myData.range(719,336)); //Sending 384*3bits ~ 16*3Deltas\n                        outAll_Pstrm[2].write(myData.range(1103,720)); //Sending 384*3bits ~ 16*3Deltas\n                        outAll_Pstrm[3].write(myData.range(1487,1104)); //Sending 384*3bits ~ 16*3Deltas\n                    }\n                    else if(bitSize == 16)\n                    {\n                        outAll_Pstrm[0].write(myData.range(223,0)); //Sending 224 ~ 14Deltas\n                        outAll_Pstrm[1].write(myData.range(479,224)); //Sending 256*3bits ~ 16*3Deltas\n                        outAll_Pstrm[2].write(myData.range(735,480)); //Sending 256*3bits ~ 16*3Deltas\n                        outAll_Pstrm[3].write(myData.range(991,736)); //Sending 256*3bits ~ 16*3Deltas\n                    }\n                    else if(bitSize == 8)\n                    {\n                        outAll_Pstrm[0].write(myData.range(111,0)); //Sending 112 ~ 14Deltas\n                        outAll_Pstrm[1].write(myData.range(239,112)); //Sending 128*3bits ~ 16*3Deltas\n                        outAll_Pstrm[2].write(myData.range(367,240)); //Sending 128*3bits ~ 16*3Deltas\n                        outAll_Pstrm[3].write(myData.range(495,368)); //Sending 128*3bits ~ 16*3Deltas\n                    }\n                }\n                else\n                {\n                    data_WriterBS:for(int k = 0; k < 4; k++)\n                    {\n#pragma HLS UNROLL\n                        outAll_Pstrm[k].write(myData.range(((k+1)*SDS)-1,k*SDS)); //Sending 2048bits\n                    }\n                }\n            }\n            else //bitSize 0 for delta case\n            {\n                MymetaData = metaData;\n                MymetaData.range(31,0) = 32; //change the bitSize to 32 bcz of BV and DB being 32\n                MymetaData.range(127,96) = mBSF; //change BSF flag to 0 after 1st time\n                MymetaData.range(193,192) = 1; // To Skip the endiannness change\n                mBSF = 0;\n                //Compute Delta will use meta data and insert BV for BSF == 1\n                DB_COPY:for(int i = 0; i < PEs; i++)\n                {\n#pragma HLS unroll\n                    tempData.range((i*32)+31,(i*32)) = DB;\n                }\n                data_WriterBS0:for(int k = 0; k < 4; k++)\n                {\n#pragma HLS UNROLL\n                    outAll_Pstrm[k].write(tempData); //Sending 2048bits\n                }\n                if(d_count < T_CYCLES)\n                {\n                    d_count += 64;\n                }\n                else //(d_count >= DrunLength)\n                {\n                    d_count = 0;\n                    proc = false;\n                    dRead = true;\n                }\n            }\n            if(DecType == SR)\n            {\n                SR_meta_out.write(bitSize);\n            }\n            else\n            {\n                send_meta:for(int i = 0;i < 4;i++)\n                {\n#pragma HLS UNROLL\n                    meta_out[i].write(MymetaData);\n                }\n            }\n        }\n    }\n}\nvoid compSR(tapa::istream<uint64_t>& outSR_Pstrm,\n            tapa::istream<uint8_t>& meta_out,\n            tapa::ostream<_320b>& SR_Dout)\n;\nvoid compute_delta(tapa::istream<_512b>& in_Cstrm,\n                tapa::istream<_256b>& in_Trstrm,\n                tapa::ostream<uint32_t>& out_Cmeta_strm,\n                tapa::ostream<_512b>& out_Cstrm,\n                tapa::ostream<_512b>& DI_strm,\n                tapa::ostream<_512b>& PA_strm,\n                tapa::ostream<uint32_t>& PA_meta_strm,\n                uint32_t compD_ID)\n;\nvoid PA_meta_proc(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_meta_Strm,\n                tapa::ostream<uint64_t>& metaOutPA_Strm) //PLL, IDX, VAL\n;\nvoid PA_sum_out(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_BV_Strm,\n                tapa::ostream<_512b>& dataOutPA_Strm\n                )\n;\nvoid Meta_Aligner(tapa::istream<uint64_t>& PA_metaStrm,\n                tapa::istream<uint64_t>& All_meta_Strm,\n                tapa::ostream<_128b>& meta_Out\n                )\n;\nvoid Meta_Writer(tapa::istream<_128b>& PA_metaStrm,\n                tapa::istream<bool>& rst_StrmDS,\n                // tapa::istream<uint32_t>& complete_count,\n                uint64_t  metaPort_Out\n                // uint32_t KRNL_Data_Write\n                )\n;\nvoid delta_sumNC_in(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                // ,uint32_t ID\n                )\n;\nvoid delta_sumNC_all(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_sum_2out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm1\n                )\n;\nvoid delta_sum_1out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                )\n;\nvoid delta_sum_0out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_Fsum(tapa::istreams<_512b, 4>& delta_Strm,\n                tapa::istreams<uint32_t, 4>& meta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostreams<_512b, 4>& dataOut_Strm\n                )\n;\nvoid Data_Aligner(tapa::istream<uint8_t>& inTrackStrm,\n                tapa::istreams<_512b, 4>& inDEStrm,\n                tapa::istreams<_512b, 4>& inDIStrm,\n                tapa::istreams<_512b, 4>& inPAStrm,\n                tapa::istream<_320b>& inSRStrm,\n                tapa::ostreams<_512b, 4>& outWRStrm )\n;\nvoid store_all(tapa::istreams<_512b, 4>& inAllStrm,\n            tapa::istream<bool>& rst_StrmL,\n            // tapa::istream<uint32_t>& dataCnt_strm,\n            uint64_t OUT0_32b_8b,\n            uint64_t OUT1_16b_8b,\n            uint64_t OUT2_16b_8b,\n            uint64_t OUT3_8b)\n;\nvoid data_decoding(uint64_t  input_port,\n                    uint64_t  output_port0_32b_8b,\n                    uint64_t  output_port1_16b_8b,\n                    uint64_t  output_port2_16b_8b,\n                    uint64_t  output_port3_8b,\n                    uint64_t  output_port4_Track,\n                    uint32_t wait_count,\n                    uint32_t data_count)\n;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "data_decoding": {
            "code": "\n\n\n #include <cstdint>\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <iostream>\n\n#include <fstream>\n\n#include <string>\n\n#include <vector>\n\n#include <algorithm>\n\n#include <inttypes.h>\n\n\n #include \"ap_int.h\"\n\n#include <tapa.h>\n\n// const uint32_t dataWR_Cnt = 934640;\n// const uint32_t metaWR_Cnt = 934640;  //2147483647;\nconst uint8_t SR = 0;\nconst uint8_t DIRECT = 1;\nconst uint8_t PATCHED = 2;\nconst uint8_t DELTA = 3;\nconst uint8_t HEADER_ST = 7;\nconst uint8_t SR_STATE = 0; // 0 from 8\nconst uint8_t DI_STATE = 1; // 1 from 5\nconst uint8_t PA_STATE = 2; // 2 from 7\nconst uint8_t DE_STATE = 3; // 3 from 2\nconst uint8_t ASSIGN_DATA = 4;\nconst uint8_t PA_META_PROC = 5;\nconst uint8_t TR_HEADER = 6;\nconst uint8_t HD_PROC = 8;\nconst uint8_t waste_cycles = 9;\nconst uint16_t AXI_WIDTH_2X = 1024;\nconst uint16_t AXI_WIDTH_4X = 2048;\nconst uint16_t AXI_WIDTH = 512;\nconst uint16_t SR_DATAW = 320;\nconst uint16_t AXI_WIDTH_H = 256;\nconst uint16_t AXI_WIDTH_HH = 128;\ntypedef ap_uint<AXI_WIDTH_4X> _2048b;\ntypedef ap_uint<AXI_WIDTH_2X> _1024b;\ntypedef ap_uint<AXI_WIDTH> _512b;\ntypedef ap_int<AXI_WIDTH> _512bi;\ntypedef ap_uint<SR_DATAW> _320b;\ntypedef ap_uint<AXI_WIDTH_H> _256b;\ntypedef ap_uint<AXI_WIDTH_HH> _128b;\nconst uint16_t PEs = 16;\n// Map to bit width value.\n// const uint16_t NDelta_BitMap[32] = {1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n// const uint16_t Delta_BitMap[32] = {0,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n\nvoid mmap2s(uint64_t  input_port,\n            tapa::ostream<_512b>& outLstrm,\n            tapa::ostream<bool>& rstStrmL,\n            tapa::ostream<bool>& rstStrmMeta,\n            tapa::ostream<bool>& rstStrmStore,\n            uint32_t wait_count,\n            uint32_t data_count)\n;\nvoid load(tapa::istream<_512b>& data_in,\n            tapa::istream<bool>& rstStrm,\n            tapa::ostream<_2048b>& outAll_Lstrm,\n            tapa::ostream<_256b> &out_strmC_Track,\n            tapa::ostream<_512b>& PA_DATA,\n            tapa::ostream<uint32_t>& PA_metaDATA\n            // tapa::ostream<uint32_t>& paCnt_strm\n            // uint32_t KRNL_Data_Write\n            // uint32_t data_count\n                 )\n;\nvoid data_Sender(tapa::istream<_2048b>& data_in,\n                tapa::istream<_256b>& meta_in,\n                // tapa::istream<bool> & rst_Strm,\n                tapa::ostreams<_512b,4>& outAll_Pstrm,\n                tapa::ostream<uint64_t>& outSR_Pstrm,\n                tapa::ostreams<_256b, 4>& meta_out,\n                tapa::ostream<uint8_t>& SR_meta_out,\n                tapa::ostream<uint64_t>& All_meta_out,\n                tapa::ostream<uint8_t>& Dec_type_Out\n                // tapa::ostream<uint32_t>& data_Cnt,\n                // tapa::ostream<uint32_t>& pa_Cnt\n                )\n;\nvoid compSR(tapa::istream<uint64_t>& outSR_Pstrm,\n            tapa::istream<uint8_t>& meta_out,\n            tapa::ostream<_320b>& SR_Dout)\n;\nvoid compute_delta(tapa::istream<_512b>& in_Cstrm,\n                tapa::istream<_256b>& in_Trstrm,\n                tapa::ostream<uint32_t>& out_Cmeta_strm,\n                tapa::ostream<_512b>& out_Cstrm,\n                tapa::ostream<_512b>& DI_strm,\n                tapa::ostream<_512b>& PA_strm,\n                tapa::ostream<uint32_t>& PA_meta_strm,\n                uint32_t compD_ID)\n;\nvoid PA_meta_proc(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_meta_Strm,\n                tapa::ostream<uint64_t>& metaOutPA_Strm) //PLL, IDX, VAL\n;\nvoid PA_sum_out(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_BV_Strm,\n                tapa::ostream<_512b>& dataOutPA_Strm\n                )\n;\nvoid Meta_Aligner(tapa::istream<uint64_t>& PA_metaStrm,\n                tapa::istream<uint64_t>& All_meta_Strm,\n                tapa::ostream<_128b>& meta_Out\n                )\n;\nvoid Meta_Writer(tapa::istream<_128b>& PA_metaStrm,\n                tapa::istream<bool>& rst_StrmDS,\n                // tapa::istream<uint32_t>& complete_count,\n                uint64_t  metaPort_Out\n                // uint32_t KRNL_Data_Write\n                )\n;\nvoid delta_sumNC_in(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                // ,uint32_t ID\n                )\n;\nvoid delta_sumNC_all(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_sum_2out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm1\n                )\n;\nvoid delta_sum_1out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                )\n;\nvoid delta_sum_0out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_Fsum(tapa::istreams<_512b, 4>& delta_Strm,\n                tapa::istreams<uint32_t, 4>& meta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostreams<_512b, 4>& dataOut_Strm\n                )\n;\nvoid Data_Aligner(tapa::istream<uint8_t>& inTrackStrm,\n                tapa::istreams<_512b, 4>& inDEStrm,\n                tapa::istreams<_512b, 4>& inDIStrm,\n                tapa::istreams<_512b, 4>& inPAStrm,\n                tapa::istream<_320b>& inSRStrm,\n                tapa::ostreams<_512b, 4>& outWRStrm )\n;\nvoid store_all(tapa::istreams<_512b, 4>& inAllStrm,\n            tapa::istream<bool>& rst_StrmL,\n            // tapa::istream<uint32_t>& dataCnt_strm,\n            uint64_t OUT0_32b_8b,\n            uint64_t OUT1_16b_8b,\n            uint64_t OUT2_16b_8b,\n            uint64_t OUT3_8b)\n;\nextern \"C\" {\n\nvoid data_decoding(uint64_t  input_port,\n                    uint64_t  output_port0_32b_8b,\n                    uint64_t  output_port1_16b_8b,\n                    uint64_t  output_port2_16b_8b,\n                    uint64_t  output_port3_8b,\n                    uint64_t  output_port4_Track,\n                    uint32_t wait_count,\n                    uint32_t data_count)\n{\n\n#pragma HLS interface s_axilite port = input_port bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(input_port); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(input_port); }\n\n#pragma HLS interface s_axilite port = output_port0_32b_8b bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(output_port0_32b_8b); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(output_port0_32b_8b); }\n\n#pragma HLS interface s_axilite port = output_port1_16b_8b bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(output_port1_16b_8b); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(output_port1_16b_8b); }\n\n#pragma HLS interface s_axilite port = output_port2_16b_8b bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(output_port2_16b_8b); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(output_port2_16b_8b); }\n\n#pragma HLS interface s_axilite port = output_port3_8b bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(output_port3_8b); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(output_port3_8b); }\n\n#pragma HLS interface s_axilite port = output_port4_Track bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(output_port4_Track); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(output_port4_Track); }\n\n#pragma HLS interface s_axilite port = wait_count bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(wait_count); }\n\n#pragma HLS interface s_axilite port = data_count bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(data_count); }\n\n\n#pragma HLS interface s_axilite port = return bundle = control\n}\n\n\n}  // extern \"C\"\n\n",
            "fifos": {
                "All_meta_out_data_decoding": {
                    "consumed_by": [
                        "Meta_Aligner",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "data_Sender",
                        0
                    ]
                },
                "CarryOut0_Strm1_data_decoding": {
                    "consumed_by": [
                        "delta_sum_0out",
                        1
                    ],
                    "depth": 32,
                    "produced_by": [
                        "delta_sum_2out",
                        0
                    ]
                },
                "CarryOut0_Strm2_data_decoding": {
                    "consumed_by": [
                        "delta_Fsum",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "delta_sum_1out",
                        0
                    ]
                },
                "CarryOut1_Strm1_data_decoding": {
                    "consumed_by": [
                        "delta_sum_1out",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "delta_sum_2out",
                        0
                    ]
                },
                "CarryOut_Strm0_data_decoding[0]": {
                    "consumed_by": [
                        "delta_sum_2out",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "delta_sumNC_in",
                        0
                    ]
                },
                "CarryOut_Strm0_data_decoding[1]": {
                    "consumed_by": [
                        "delta_sum_0out",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "delta_sumNC_in",
                        1
                    ]
                },
                "DEOut_Strm_data_decoding[0]": {
                    "consumed_by": [
                        "Data_Aligner",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "delta_Fsum",
                        0
                    ]
                },
                "DEOut_Strm_data_decoding[1]": {
                    "consumed_by": [
                        "Data_Aligner",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "delta_Fsum",
                        0
                    ]
                },
                "DEOut_Strm_data_decoding[2]": {
                    "consumed_by": [
                        "Data_Aligner",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "delta_Fsum",
                        0
                    ]
                },
                "DEOut_Strm_data_decoding[3]": {
                    "consumed_by": [
                        "Data_Aligner",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "delta_Fsum",
                        0
                    ]
                },
                "DIOut_Strm_data_decoding[0]": {
                    "consumed_by": [
                        "Data_Aligner",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "compute_delta",
                        0
                    ]
                },
                "DIOut_Strm_data_decoding[1]": {
                    "consumed_by": [
                        "Data_Aligner",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "compute_delta",
                        1
                    ]
                },
                "DIOut_Strm_data_decoding[2]": {
                    "consumed_by": [
                        "Data_Aligner",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "compute_delta",
                        2
                    ]
                },
                "DIOut_Strm_data_decoding[3]": {
                    "consumed_by": [
                        "Data_Aligner",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "compute_delta",
                        3
                    ]
                },
                "MydataOut_data_decoding[0]": {
                    "consumed_by": [
                        "delta_Fsum",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "delta_sumNC_in",
                        0
                    ]
                },
                "MydataOut_data_decoding[1]": {
                    "consumed_by": [
                        "delta_Fsum",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "delta_sum_2out",
                        0
                    ]
                },
                "MydataOut_data_decoding[2]": {
                    "consumed_by": [
                        "delta_Fsum",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "delta_sum_0out",
                        1
                    ]
                },
                "MydataOut_data_decoding[3]": {
                    "consumed_by": [
                        "delta_Fsum",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "delta_sum_1out",
                        0
                    ]
                },
                "PA_DATA_data_decoding": {
                    "consumed_by": [
                        "PA_meta_proc",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "load",
                        0
                    ]
                },
                "PA_acc_meta_data_decoding[0]": {
                    "consumed_by": [
                        "PA_sum_out",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "compute_delta",
                        0
                    ]
                },
                "PA_acc_meta_data_decoding[1]": {
                    "consumed_by": [
                        "PA_sum_out",
                        1
                    ],
                    "depth": 32,
                    "produced_by": [
                        "compute_delta",
                        1
                    ]
                },
                "PA_acc_meta_data_decoding[2]": {
                    "consumed_by": [
                        "PA_sum_out",
                        2
                    ],
                    "depth": 32,
                    "produced_by": [
                        "compute_delta",
                        2
                    ]
                },
                "PA_acc_meta_data_decoding[3]": {
                    "consumed_by": [
                        "PA_sum_out",
                        3
                    ],
                    "depth": 32,
                    "produced_by": [
                        "compute_delta",
                        3
                    ]
                },
                "PA_acc_strm_data_decoding[0]": {
                    "consumed_by": [
                        "PA_sum_out",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "compute_delta",
                        0
                    ]
                },
                "PA_acc_strm_data_decoding[1]": {
                    "consumed_by": [
                        "PA_sum_out",
                        1
                    ],
                    "depth": 32,
                    "produced_by": [
                        "compute_delta",
                        1
                    ]
                },
                "PA_acc_strm_data_decoding[2]": {
                    "consumed_by": [
                        "PA_sum_out",
                        2
                    ],
                    "depth": 32,
                    "produced_by": [
                        "compute_delta",
                        2
                    ]
                },
                "PA_acc_strm_data_decoding[3]": {
                    "consumed_by": [
                        "PA_sum_out",
                        3
                    ],
                    "depth": 32,
                    "produced_by": [
                        "compute_delta",
                        3
                    ]
                },
                "PA_meta_Data_data_decoding": {
                    "consumed_by": [
                        "PA_meta_proc",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "load",
                        0
                    ]
                },
                "SR_Dout_data_decoding": {
                    "consumed_by": [
                        "Data_Aligner",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "compSR",
                        0
                    ]
                },
                "SR_meta_out_data_decoding": {
                    "consumed_by": [
                        "compSR",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "data_Sender",
                        0
                    ]
                },
                "dataOutPA_Strm_data_decoding[0]": {
                    "consumed_by": [
                        "Data_Aligner",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "PA_sum_out",
                        0
                    ]
                },
                "dataOutPA_Strm_data_decoding[1]": {
                    "consumed_by": [
                        "Data_Aligner",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "PA_sum_out",
                        1
                    ]
                },
                "dataOutPA_Strm_data_decoding[2]": {
                    "consumed_by": [
                        "Data_Aligner",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "PA_sum_out",
                        2
                    ]
                },
                "dataOutPA_Strm_data_decoding[3]": {
                    "consumed_by": [
                        "Data_Aligner",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "PA_sum_out",
                        3
                    ]
                },
                "dataOut_Strm0_data_decoding[0]": {
                    "consumed_by": [
                        "delta_sum_2out",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "delta_sumNC_all",
                        0
                    ]
                },
                "dataOut_Strm0_data_decoding[1]": {
                    "consumed_by": [
                        "delta_sum_0out",
                        1
                    ],
                    "depth": 32,
                    "produced_by": [
                        "delta_sumNC_in",
                        1
                    ]
                },
                "dataOut_Strm0_data_decoding[2]": {
                    "consumed_by": [
                        "delta_sum_0out",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "delta_sumNC_all",
                        1
                    ]
                },
                "dataOut_Strm1_data_decoding": {
                    "consumed_by": [
                        "delta_sum_1out",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "delta_sum_0out",
                        0
                    ]
                },
                "dataOut_Strm_data_decoding[0]": {
                    "consumed_by": [
                        "store_all",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "Data_Aligner",
                        0
                    ]
                },
                "dataOut_Strm_data_decoding[1]": {
                    "consumed_by": [
                        "store_all",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "Data_Aligner",
                        0
                    ]
                },
                "dataOut_Strm_data_decoding[2]": {
                    "consumed_by": [
                        "store_all",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "Data_Aligner",
                        0
                    ]
                },
                "dataOut_Strm_data_decoding[3]": {
                    "consumed_by": [
                        "store_all",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "Data_Aligner",
                        0
                    ]
                },
                "metaOutPA_Strm_data_decoding": {
                    "consumed_by": [
                        "Meta_Aligner",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "PA_meta_proc",
                        0
                    ]
                },
                "meta_Writer_Out_data_decoding": {
                    "consumed_by": [
                        "Meta_Writer",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "Meta_Aligner",
                        0
                    ]
                },
                "meta_out_data_decoding[0]": {
                    "consumed_by": [
                        "compute_delta",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "data_Sender",
                        0
                    ]
                },
                "meta_out_data_decoding[1]": {
                    "consumed_by": [
                        "compute_delta",
                        1
                    ],
                    "depth": 32,
                    "produced_by": [
                        "data_Sender",
                        0
                    ]
                },
                "meta_out_data_decoding[2]": {
                    "consumed_by": [
                        "compute_delta",
                        2
                    ],
                    "depth": 32,
                    "produced_by": [
                        "data_Sender",
                        0
                    ]
                },
                "meta_out_data_decoding[3]": {
                    "consumed_by": [
                        "compute_delta",
                        3
                    ],
                    "depth": 32,
                    "produced_by": [
                        "data_Sender",
                        0
                    ]
                },
                "outAll_Lstrm_data_decoding": {
                    "consumed_by": [
                        "data_Sender",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "load",
                        0
                    ]
                },
                "outAll_Pstrm_data_decoding[0]": {
                    "consumed_by": [
                        "compute_delta",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "data_Sender",
                        0
                    ]
                },
                "outAll_Pstrm_data_decoding[1]": {
                    "consumed_by": [
                        "compute_delta",
                        1
                    ],
                    "depth": 32,
                    "produced_by": [
                        "data_Sender",
                        0
                    ]
                },
                "outAll_Pstrm_data_decoding[2]": {
                    "consumed_by": [
                        "compute_delta",
                        2
                    ],
                    "depth": 32,
                    "produced_by": [
                        "data_Sender",
                        0
                    ]
                },
                "outAll_Pstrm_data_decoding[3]": {
                    "consumed_by": [
                        "compute_delta",
                        3
                    ],
                    "depth": 32,
                    "produced_by": [
                        "data_Sender",
                        0
                    ]
                },
                "outLstrm_data_decoding": {
                    "consumed_by": [
                        "load",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "mmap2s",
                        0
                    ]
                },
                "outSR_Pstrm_data_decoding": {
                    "consumed_by": [
                        "compSR",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "data_Sender",
                        0
                    ]
                },
                "out_Cmeta_strm_data_decoding[0]": {
                    "consumed_by": [
                        "delta_Fsum",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "compute_delta",
                        0
                    ]
                },
                "out_Cmeta_strm_data_decoding[1]": {
                    "consumed_by": [
                        "delta_Fsum",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "compute_delta",
                        1
                    ]
                },
                "out_Cmeta_strm_data_decoding[2]": {
                    "consumed_by": [
                        "delta_Fsum",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "compute_delta",
                        2
                    ]
                },
                "out_Cmeta_strm_data_decoding[3]": {
                    "consumed_by": [
                        "delta_Fsum",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "compute_delta",
                        3
                    ]
                },
                "out_DA_Track_data_decoding": {
                    "consumed_by": [
                        "Data_Aligner",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "data_Sender",
                        0
                    ]
                },
                "out_all_Cstrm_data_decoding[0]": {
                    "consumed_by": [
                        "delta_sumNC_in",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "compute_delta",
                        0
                    ]
                },
                "out_all_Cstrm_data_decoding[1]": {
                    "consumed_by": [
                        "delta_sumNC_all",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "compute_delta",
                        1
                    ]
                },
                "out_all_Cstrm_data_decoding[2]": {
                    "consumed_by": [
                        "delta_sumNC_in",
                        1
                    ],
                    "depth": 32,
                    "produced_by": [
                        "compute_delta",
                        2
                    ]
                },
                "out_all_Cstrm_data_decoding[3]": {
                    "consumed_by": [
                        "delta_sumNC_all",
                        1
                    ],
                    "depth": 32,
                    "produced_by": [
                        "compute_delta",
                        3
                    ]
                },
                "out_strmC_Track_data_decoding": {
                    "consumed_by": [
                        "data_Sender",
                        0
                    ],
                    "depth": 32,
                    "produced_by": [
                        "load",
                        0
                    ]
                },
                "rstStrmL_data_decoding": {
                    "consumed_by": [
                        "load",
                        0
                    ],
                    "depth": 8,
                    "produced_by": [
                        "mmap2s",
                        0
                    ]
                },
                "rstStrmMeta_data_decoding": {
                    "consumed_by": [
                        "Meta_Writer",
                        0
                    ],
                    "depth": 8,
                    "produced_by": [
                        "mmap2s",
                        0
                    ]
                },
                "rstStrmStore_data_decoding": {
                    "consumed_by": [
                        "store_all",
                        0
                    ],
                    "depth": 8,
                    "produced_by": [
                        "mmap2s",
                        0
                    ]
                }
            },
            "frt_interface": "#include <sstream>\n#include <stdexcept>\n#include <frt.h>\n\n\n\n\n #include <cstdint>\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <iostream>\n\n#include <fstream>\n\n#include <string>\n\n#include <vector>\n\n#include <algorithm>\n\n#include <inttypes.h>\n\n\n #include \"ap_int.h\"\n\n#include <tapa.h>\n\n// const uint32_t dataWR_Cnt = 934640;\n// const uint32_t metaWR_Cnt = 934640;  //2147483647;\nconst uint8_t SR = 0;\nconst uint8_t DIRECT = 1;\nconst uint8_t PATCHED = 2;\nconst uint8_t DELTA = 3;\nconst uint8_t HEADER_ST = 7;\nconst uint8_t SR_STATE = 0; // 0 from 8\nconst uint8_t DI_STATE = 1; // 1 from 5\nconst uint8_t PA_STATE = 2; // 2 from 7\nconst uint8_t DE_STATE = 3; // 3 from 2\nconst uint8_t ASSIGN_DATA = 4;\nconst uint8_t PA_META_PROC = 5;\nconst uint8_t TR_HEADER = 6;\nconst uint8_t HD_PROC = 8;\nconst uint8_t waste_cycles = 9;\nconst uint16_t AXI_WIDTH_2X = 1024;\nconst uint16_t AXI_WIDTH_4X = 2048;\nconst uint16_t AXI_WIDTH = 512;\nconst uint16_t SR_DATAW = 320;\nconst uint16_t AXI_WIDTH_H = 256;\nconst uint16_t AXI_WIDTH_HH = 128;\ntypedef ap_uint<AXI_WIDTH_4X> _2048b;\ntypedef ap_uint<AXI_WIDTH_2X> _1024b;\ntypedef ap_uint<AXI_WIDTH> _512b;\ntypedef ap_int<AXI_WIDTH> _512bi;\ntypedef ap_uint<SR_DATAW> _320b;\ntypedef ap_uint<AXI_WIDTH_H> _256b;\ntypedef ap_uint<AXI_WIDTH_HH> _128b;\nconst uint16_t PEs = 16;\n// Map to bit width value.\n// const uint16_t NDelta_BitMap[32] = {1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n// const uint16_t Delta_BitMap[32] = {0,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n\nvoid mmap2s(uint64_t  input_port,\n            tapa::ostream<_512b>& outLstrm,\n            tapa::ostream<bool>& rstStrmL,\n            tapa::ostream<bool>& rstStrmMeta,\n            tapa::ostream<bool>& rstStrmStore,\n            uint32_t wait_count,\n            uint32_t data_count)\n;\nvoid load(tapa::istream<_512b>& data_in,\n            tapa::istream<bool>& rstStrm,\n            tapa::ostream<_2048b>& outAll_Lstrm,\n            tapa::ostream<_256b> &out_strmC_Track,\n            tapa::ostream<_512b>& PA_DATA,\n            tapa::ostream<uint32_t>& PA_metaDATA\n            // tapa::ostream<uint32_t>& paCnt_strm\n            // uint32_t KRNL_Data_Write\n            // uint32_t data_count\n                 )\n;\nvoid data_Sender(tapa::istream<_2048b>& data_in,\n                tapa::istream<_256b>& meta_in,\n                // tapa::istream<bool> & rst_Strm,\n                tapa::ostreams<_512b,4>& outAll_Pstrm,\n                tapa::ostream<uint64_t>& outSR_Pstrm,\n                tapa::ostreams<_256b, 4>& meta_out,\n                tapa::ostream<uint8_t>& SR_meta_out,\n                tapa::ostream<uint64_t>& All_meta_out,\n                tapa::ostream<uint8_t>& Dec_type_Out\n                // tapa::ostream<uint32_t>& data_Cnt,\n                // tapa::ostream<uint32_t>& pa_Cnt\n                )\n;\nvoid compSR(tapa::istream<uint64_t>& outSR_Pstrm,\n            tapa::istream<uint8_t>& meta_out,\n            tapa::ostream<_320b>& SR_Dout)\n;\nvoid compute_delta(tapa::istream<_512b>& in_Cstrm,\n                tapa::istream<_256b>& in_Trstrm,\n                tapa::ostream<uint32_t>& out_Cmeta_strm,\n                tapa::ostream<_512b>& out_Cstrm,\n                tapa::ostream<_512b>& DI_strm,\n                tapa::ostream<_512b>& PA_strm,\n                tapa::ostream<uint32_t>& PA_meta_strm,\n                uint32_t compD_ID)\n;\nvoid PA_meta_proc(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_meta_Strm,\n                tapa::ostream<uint64_t>& metaOutPA_Strm) //PLL, IDX, VAL\n;\nvoid PA_sum_out(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_BV_Strm,\n                tapa::ostream<_512b>& dataOutPA_Strm\n                )\n;\nvoid Meta_Aligner(tapa::istream<uint64_t>& PA_metaStrm,\n                tapa::istream<uint64_t>& All_meta_Strm,\n                tapa::ostream<_128b>& meta_Out\n                )\n;\nvoid Meta_Writer(tapa::istream<_128b>& PA_metaStrm,\n                tapa::istream<bool>& rst_StrmDS,\n                // tapa::istream<uint32_t>& complete_count,\n                uint64_t  metaPort_Out\n                // uint32_t KRNL_Data_Write\n                )\n;\nvoid delta_sumNC_in(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                // ,uint32_t ID\n                )\n;\nvoid delta_sumNC_all(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_sum_2out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm1\n                )\n;\nvoid delta_sum_1out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                )\n;\nvoid delta_sum_0out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_Fsum(tapa::istreams<_512b, 4>& delta_Strm,\n                tapa::istreams<uint32_t, 4>& meta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostreams<_512b, 4>& dataOut_Strm\n                )\n;\nvoid Data_Aligner(tapa::istream<uint8_t>& inTrackStrm,\n                tapa::istreams<_512b, 4>& inDEStrm,\n                tapa::istreams<_512b, 4>& inDIStrm,\n                tapa::istreams<_512b, 4>& inPAStrm,\n                tapa::istream<_320b>& inSRStrm,\n                tapa::ostreams<_512b, 4>& outWRStrm )\n;\nvoid store_all(tapa::istreams<_512b, 4>& inAllStrm,\n            tapa::istream<bool>& rst_StrmL,\n            // tapa::istream<uint32_t>& dataCnt_strm,\n            uint64_t OUT0_32b_8b,\n            uint64_t OUT1_16b_8b,\n            uint64_t OUT2_16b_8b,\n            uint64_t OUT3_8b)\n;\nvoid data_decoding(tapa::mmap<_512b> input_port,\n                    tapa::mmap<_512b> output_port0_32b_8b,\n                    tapa::mmap<_512b> output_port1_16b_8b,\n                    tapa::mmap<_512b> output_port2_16b_8b,\n                    tapa::mmap<_512b> output_port3_8b,\n                    tapa::mmap<_128b> output_port4_Track,\n                    uint32_t wait_count,\n                    uint32_t data_count)\n{\n#define TAPAB_APP \"TAPAB_data_decoding\"\n#define TAPAB \"TAPAB\"\n  const char* _tapa_bitstream = nullptr;\n  if ((_tapa_bitstream = getenv(TAPAB_APP)) ||\n      (_tapa_bitstream = getenv(TAPAB))) {\n    fpga::Instance _tapa_instance(_tapa_bitstream);\n    int _tapa_arg_index = 0;\n    for (const auto& _tapa_arg_info : _tapa_instance.GetArgsInfo()) {\n      if (false) {\n      } else if (_tapa_arg_info.name == \"input_port\") {\n        auto _tapa_arg = fpga::ReadWrite(input_port.get(), input_port.size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"output_port0_32b_8b\") {\n        auto _tapa_arg = fpga::ReadWrite(output_port0_32b_8b.get(), output_port0_32b_8b.size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"output_port1_16b_8b\") {\n        auto _tapa_arg = fpga::ReadWrite(output_port1_16b_8b.get(), output_port1_16b_8b.size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"output_port2_16b_8b\") {\n        auto _tapa_arg = fpga::ReadWrite(output_port2_16b_8b.get(), output_port2_16b_8b.size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"output_port3_8b\") {\n        auto _tapa_arg = fpga::ReadWrite(output_port3_8b.get(), output_port3_8b.size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"output_port4_Track\") {\n        auto _tapa_arg = fpga::ReadWrite(output_port4_Track.get(), output_port4_Track.size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"wait_count\") {\n        _tapa_instance.SetArg(_tapa_arg_index, wait_count);\n      } else if (_tapa_arg_info.name == \"data_count\") {\n        _tapa_instance.SetArg(_tapa_arg_index, data_count);\n      } else {\n        std::stringstream ss;\n        ss << \"unknown argument: \" << _tapa_arg_info;\n        throw std::runtime_error(ss.str());\n      }\n      ++_tapa_arg_index;\n    }\n    _tapa_instance.WriteToDevice();\n    _tapa_instance.Exec();\n    _tapa_instance.ReadFromDevice();\n    _tapa_instance.Finish();\n  } else {\n    throw std::runtime_error(\"no bitstream found; please set `\" TAPAB_APP\n                             \"` or `\" TAPAB \"`\");\n  }\n}\n",
            "level": "upper",
            "ports": [
                {
                    "cat": "mmap",
                    "name": "input_port",
                    "type": "_512b*",
                    "width": 512
                },
                {
                    "cat": "mmap",
                    "name": "output_port0_32b_8b",
                    "type": "_512b*",
                    "width": 512
                },
                {
                    "cat": "mmap",
                    "name": "output_port1_16b_8b",
                    "type": "_512b*",
                    "width": 512
                },
                {
                    "cat": "mmap",
                    "name": "output_port2_16b_8b",
                    "type": "_512b*",
                    "width": 512
                },
                {
                    "cat": "mmap",
                    "name": "output_port3_8b",
                    "type": "_512b*",
                    "width": 512
                },
                {
                    "cat": "mmap",
                    "name": "output_port4_Track",
                    "type": "_128b*",
                    "width": 128
                },
                {
                    "cat": "scalar",
                    "name": "wait_count",
                    "type": "uint32_t",
                    "width": 32
                },
                {
                    "cat": "scalar",
                    "name": "data_count",
                    "type": "uint32_t",
                    "width": 32
                }
            ],
            "target": "hls",
            "tasks": {
                "Data_Aligner": [
                    {
                        "args": {
                            "inDEStrm[0]": {
                                "arg": "DEOut_Strm_data_decoding[0]",
                                "cat": "istream"
                            },
                            "inDEStrm[1]": {
                                "arg": "DEOut_Strm_data_decoding[1]",
                                "cat": "istream"
                            },
                            "inDEStrm[2]": {
                                "arg": "DEOut_Strm_data_decoding[2]",
                                "cat": "istream"
                            },
                            "inDEStrm[3]": {
                                "arg": "DEOut_Strm_data_decoding[3]",
                                "cat": "istream"
                            },
                            "inDIStrm[0]": {
                                "arg": "DIOut_Strm_data_decoding[0]",
                                "cat": "istream"
                            },
                            "inDIStrm[1]": {
                                "arg": "DIOut_Strm_data_decoding[1]",
                                "cat": "istream"
                            },
                            "inDIStrm[2]": {
                                "arg": "DIOut_Strm_data_decoding[2]",
                                "cat": "istream"
                            },
                            "inDIStrm[3]": {
                                "arg": "DIOut_Strm_data_decoding[3]",
                                "cat": "istream"
                            },
                            "inPAStrm[0]": {
                                "arg": "dataOutPA_Strm_data_decoding[0]",
                                "cat": "istream"
                            },
                            "inPAStrm[1]": {
                                "arg": "dataOutPA_Strm_data_decoding[1]",
                                "cat": "istream"
                            },
                            "inPAStrm[2]": {
                                "arg": "dataOutPA_Strm_data_decoding[2]",
                                "cat": "istream"
                            },
                            "inPAStrm[3]": {
                                "arg": "dataOutPA_Strm_data_decoding[3]",
                                "cat": "istream"
                            },
                            "inSRStrm": {
                                "arg": "SR_Dout_data_decoding",
                                "cat": "istream"
                            },
                            "inTrackStrm": {
                                "arg": "out_DA_Track_data_decoding",
                                "cat": "istream"
                            },
                            "outWRStrm[0]": {
                                "arg": "dataOut_Strm_data_decoding[0]",
                                "cat": "ostream"
                            },
                            "outWRStrm[1]": {
                                "arg": "dataOut_Strm_data_decoding[1]",
                                "cat": "ostream"
                            },
                            "outWRStrm[2]": {
                                "arg": "dataOut_Strm_data_decoding[2]",
                                "cat": "ostream"
                            },
                            "outWRStrm[3]": {
                                "arg": "dataOut_Strm_data_decoding[3]",
                                "cat": "ostream"
                            }
                        },
                        "step": -1
                    }
                ],
                "Meta_Aligner": [
                    {
                        "args": {
                            "All_meta_Strm": {
                                "arg": "All_meta_out_data_decoding",
                                "cat": "istream"
                            },
                            "PA_metaStrm": {
                                "arg": "metaOutPA_Strm_data_decoding",
                                "cat": "istream"
                            },
                            "meta_Out": {
                                "arg": "meta_Writer_Out_data_decoding",
                                "cat": "ostream"
                            }
                        },
                        "step": -1
                    }
                ],
                "Meta_Writer": [
                    {
                        "args": {
                            "PA_metaStrm": {
                                "arg": "meta_Writer_Out_data_decoding",
                                "cat": "istream"
                            },
                            "metaPort_Out": {
                                "arg": "output_port4_Track",
                                "cat": "async_mmap"
                            },
                            "rst_StrmDS": {
                                "arg": "rstStrmMeta_data_decoding",
                                "cat": "istream"
                            }
                        },
                        "step": -1
                    }
                ],
                "PA_meta_proc": [
                    {
                        "args": {
                            "PA_Strm": {
                                "arg": "PA_DATA_data_decoding",
                                "cat": "istream"
                            },
                            "PA_meta_Strm": {
                                "arg": "PA_meta_Data_data_decoding",
                                "cat": "istream"
                            },
                            "metaOutPA_Strm": {
                                "arg": "metaOutPA_Strm_data_decoding",
                                "cat": "ostream"
                            }
                        },
                        "step": -1
                    }
                ],
                "PA_sum_out": [
                    {
                        "args": {
                            "PA_BV_Strm": {
                                "arg": "PA_acc_meta_data_decoding[0]",
                                "cat": "istream"
                            },
                            "PA_Strm": {
                                "arg": "PA_acc_strm_data_decoding[0]",
                                "cat": "istream"
                            },
                            "dataOutPA_Strm": {
                                "arg": "dataOutPA_Strm_data_decoding[0]",
                                "cat": "ostream"
                            }
                        },
                        "step": -1
                    },
                    {
                        "args": {
                            "PA_BV_Strm": {
                                "arg": "PA_acc_meta_data_decoding[1]",
                                "cat": "istream"
                            },
                            "PA_Strm": {
                                "arg": "PA_acc_strm_data_decoding[1]",
                                "cat": "istream"
                            },
                            "dataOutPA_Strm": {
                                "arg": "dataOutPA_Strm_data_decoding[1]",
                                "cat": "ostream"
                            }
                        },
                        "step": -1
                    },
                    {
                        "args": {
                            "PA_BV_Strm": {
                                "arg": "PA_acc_meta_data_decoding[2]",
                                "cat": "istream"
                            },
                            "PA_Strm": {
                                "arg": "PA_acc_strm_data_decoding[2]",
                                "cat": "istream"
                            },
                            "dataOutPA_Strm": {
                                "arg": "dataOutPA_Strm_data_decoding[2]",
                                "cat": "ostream"
                            }
                        },
                        "step": -1
                    },
                    {
                        "args": {
                            "PA_BV_Strm": {
                                "arg": "PA_acc_meta_data_decoding[3]",
                                "cat": "istream"
                            },
                            "PA_Strm": {
                                "arg": "PA_acc_strm_data_decoding[3]",
                                "cat": "istream"
                            },
                            "dataOutPA_Strm": {
                                "arg": "dataOutPA_Strm_data_decoding[3]",
                                "cat": "ostream"
                            }
                        },
                        "step": -1
                    }
                ],
                "compSR": [
                    {
                        "args": {
                            "SR_Dout": {
                                "arg": "SR_Dout_data_decoding",
                                "cat": "ostream"
                            },
                            "meta_out": {
                                "arg": "SR_meta_out_data_decoding",
                                "cat": "istream"
                            },
                            "outSR_Pstrm": {
                                "arg": "outSR_Pstrm_data_decoding",
                                "cat": "istream"
                            }
                        },
                        "step": -1
                    }
                ],
                "compute_delta": [
                    {
                        "args": {
                            "DI_strm": {
                                "arg": "DIOut_Strm_data_decoding[0]",
                                "cat": "ostream"
                            },
                            "PA_meta_strm": {
                                "arg": "PA_acc_meta_data_decoding[0]",
                                "cat": "ostream"
                            },
                            "PA_strm": {
                                "arg": "PA_acc_strm_data_decoding[0]",
                                "cat": "ostream"
                            },
                            "compD_ID": {
                                "arg": "64'd0",
                                "cat": "scalar"
                            },
                            "in_Cstrm": {
                                "arg": "outAll_Pstrm_data_decoding[0]",
                                "cat": "istream"
                            },
                            "in_Trstrm": {
                                "arg": "meta_out_data_decoding[0]",
                                "cat": "istream"
                            },
                            "out_Cmeta_strm": {
                                "arg": "out_Cmeta_strm_data_decoding[0]",
                                "cat": "ostream"
                            },
                            "out_Cstrm": {
                                "arg": "out_all_Cstrm_data_decoding[0]",
                                "cat": "ostream"
                            }
                        },
                        "step": -1
                    },
                    {
                        "args": {
                            "DI_strm": {
                                "arg": "DIOut_Strm_data_decoding[1]",
                                "cat": "ostream"
                            },
                            "PA_meta_strm": {
                                "arg": "PA_acc_meta_data_decoding[1]",
                                "cat": "ostream"
                            },
                            "PA_strm": {
                                "arg": "PA_acc_strm_data_decoding[1]",
                                "cat": "ostream"
                            },
                            "compD_ID": {
                                "arg": "64'd1",
                                "cat": "scalar"
                            },
                            "in_Cstrm": {
                                "arg": "outAll_Pstrm_data_decoding[1]",
                                "cat": "istream"
                            },
                            "in_Trstrm": {
                                "arg": "meta_out_data_decoding[1]",
                                "cat": "istream"
                            },
                            "out_Cmeta_strm": {
                                "arg": "out_Cmeta_strm_data_decoding[1]",
                                "cat": "ostream"
                            },
                            "out_Cstrm": {
                                "arg": "out_all_Cstrm_data_decoding[1]",
                                "cat": "ostream"
                            }
                        },
                        "step": -1
                    },
                    {
                        "args": {
                            "DI_strm": {
                                "arg": "DIOut_Strm_data_decoding[2]",
                                "cat": "ostream"
                            },
                            "PA_meta_strm": {
                                "arg": "PA_acc_meta_data_decoding[2]",
                                "cat": "ostream"
                            },
                            "PA_strm": {
                                "arg": "PA_acc_strm_data_decoding[2]",
                                "cat": "ostream"
                            },
                            "compD_ID": {
                                "arg": "64'd2",
                                "cat": "scalar"
                            },
                            "in_Cstrm": {
                                "arg": "outAll_Pstrm_data_decoding[2]",
                                "cat": "istream"
                            },
                            "in_Trstrm": {
                                "arg": "meta_out_data_decoding[2]",
                                "cat": "istream"
                            },
                            "out_Cmeta_strm": {
                                "arg": "out_Cmeta_strm_data_decoding[2]",
                                "cat": "ostream"
                            },
                            "out_Cstrm": {
                                "arg": "out_all_Cstrm_data_decoding[2]",
                                "cat": "ostream"
                            }
                        },
                        "step": -1
                    },
                    {
                        "args": {
                            "DI_strm": {
                                "arg": "DIOut_Strm_data_decoding[3]",
                                "cat": "ostream"
                            },
                            "PA_meta_strm": {
                                "arg": "PA_acc_meta_data_decoding[3]",
                                "cat": "ostream"
                            },
                            "PA_strm": {
                                "arg": "PA_acc_strm_data_decoding[3]",
                                "cat": "ostream"
                            },
                            "compD_ID": {
                                "arg": "64'd3",
                                "cat": "scalar"
                            },
                            "in_Cstrm": {
                                "arg": "outAll_Pstrm_data_decoding[3]",
                                "cat": "istream"
                            },
                            "in_Trstrm": {
                                "arg": "meta_out_data_decoding[3]",
                                "cat": "istream"
                            },
                            "out_Cmeta_strm": {
                                "arg": "out_Cmeta_strm_data_decoding[3]",
                                "cat": "ostream"
                            },
                            "out_Cstrm": {
                                "arg": "out_all_Cstrm_data_decoding[3]",
                                "cat": "ostream"
                            }
                        },
                        "step": -1
                    }
                ],
                "data_Sender": [
                    {
                        "args": {
                            "All_meta_out": {
                                "arg": "All_meta_out_data_decoding",
                                "cat": "ostream"
                            },
                            "Dec_type_Out": {
                                "arg": "out_DA_Track_data_decoding",
                                "cat": "ostream"
                            },
                            "SR_meta_out": {
                                "arg": "SR_meta_out_data_decoding",
                                "cat": "ostream"
                            },
                            "data_in": {
                                "arg": "outAll_Lstrm_data_decoding",
                                "cat": "istream"
                            },
                            "meta_in": {
                                "arg": "out_strmC_Track_data_decoding",
                                "cat": "istream"
                            },
                            "meta_out[0]": {
                                "arg": "meta_out_data_decoding[0]",
                                "cat": "ostream"
                            },
                            "meta_out[1]": {
                                "arg": "meta_out_data_decoding[1]",
                                "cat": "ostream"
                            },
                            "meta_out[2]": {
                                "arg": "meta_out_data_decoding[2]",
                                "cat": "ostream"
                            },
                            "meta_out[3]": {
                                "arg": "meta_out_data_decoding[3]",
                                "cat": "ostream"
                            },
                            "outAll_Pstrm[0]": {
                                "arg": "outAll_Pstrm_data_decoding[0]",
                                "cat": "ostream"
                            },
                            "outAll_Pstrm[1]": {
                                "arg": "outAll_Pstrm_data_decoding[1]",
                                "cat": "ostream"
                            },
                            "outAll_Pstrm[2]": {
                                "arg": "outAll_Pstrm_data_decoding[2]",
                                "cat": "ostream"
                            },
                            "outAll_Pstrm[3]": {
                                "arg": "outAll_Pstrm_data_decoding[3]",
                                "cat": "ostream"
                            },
                            "outSR_Pstrm": {
                                "arg": "outSR_Pstrm_data_decoding",
                                "cat": "ostream"
                            }
                        },
                        "step": -1
                    }
                ],
                "delta_Fsum": [
                    {
                        "args": {
                            "CarryIn_Strm": {
                                "arg": "CarryOut0_Strm2_data_decoding",
                                "cat": "istream"
                            },
                            "dataOut_Strm[0]": {
                                "arg": "DEOut_Strm_data_decoding[0]",
                                "cat": "ostream"
                            },
                            "dataOut_Strm[1]": {
                                "arg": "DEOut_Strm_data_decoding[1]",
                                "cat": "ostream"
                            },
                            "dataOut_Strm[2]": {
                                "arg": "DEOut_Strm_data_decoding[2]",
                                "cat": "ostream"
                            },
                            "dataOut_Strm[3]": {
                                "arg": "DEOut_Strm_data_decoding[3]",
                                "cat": "ostream"
                            },
                            "delta_Strm[0]": {
                                "arg": "MydataOut_data_decoding[0]",
                                "cat": "istream"
                            },
                            "delta_Strm[1]": {
                                "arg": "MydataOut_data_decoding[1]",
                                "cat": "istream"
                            },
                            "delta_Strm[2]": {
                                "arg": "MydataOut_data_decoding[2]",
                                "cat": "istream"
                            },
                            "delta_Strm[3]": {
                                "arg": "MydataOut_data_decoding[3]",
                                "cat": "istream"
                            },
                            "meta_Strm[0]": {
                                "arg": "out_Cmeta_strm_data_decoding[0]",
                                "cat": "istream"
                            },
                            "meta_Strm[1]": {
                                "arg": "out_Cmeta_strm_data_decoding[1]",
                                "cat": "istream"
                            },
                            "meta_Strm[2]": {
                                "arg": "out_Cmeta_strm_data_decoding[2]",
                                "cat": "istream"
                            },
                            "meta_Strm[3]": {
                                "arg": "out_Cmeta_strm_data_decoding[3]",
                                "cat": "istream"
                            }
                        },
                        "step": -1
                    }
                ],
                "delta_sumNC_all": [
                    {
                        "args": {
                            "dataOut_Strm": {
                                "arg": "dataOut_Strm0_data_decoding[0]",
                                "cat": "ostream"
                            },
                            "delta_Strm": {
                                "arg": "out_all_Cstrm_data_decoding[1]",
                                "cat": "istream"
                            }
                        },
                        "step": -1
                    },
                    {
                        "args": {
                            "dataOut_Strm": {
                                "arg": "dataOut_Strm0_data_decoding[2]",
                                "cat": "ostream"
                            },
                            "delta_Strm": {
                                "arg": "out_all_Cstrm_data_decoding[3]",
                                "cat": "istream"
                            }
                        },
                        "step": -1
                    }
                ],
                "delta_sumNC_in": [
                    {
                        "args": {
                            "CarryOut_Strm": {
                                "arg": "CarryOut_Strm0_data_decoding[0]",
                                "cat": "ostream"
                            },
                            "dataOut_Strm": {
                                "arg": "MydataOut_data_decoding[0]",
                                "cat": "ostream"
                            },
                            "delta_Strm": {
                                "arg": "out_all_Cstrm_data_decoding[0]",
                                "cat": "istream"
                            }
                        },
                        "step": -1
                    },
                    {
                        "args": {
                            "CarryOut_Strm": {
                                "arg": "CarryOut_Strm0_data_decoding[1]",
                                "cat": "ostream"
                            },
                            "dataOut_Strm": {
                                "arg": "dataOut_Strm0_data_decoding[1]",
                                "cat": "ostream"
                            },
                            "delta_Strm": {
                                "arg": "out_all_Cstrm_data_decoding[2]",
                                "cat": "istream"
                            }
                        },
                        "step": -1
                    }
                ],
                "delta_sum_0out": [
                    {
                        "args": {
                            "CarryIn_Strm": {
                                "arg": "CarryOut_Strm0_data_decoding[1]",
                                "cat": "istream"
                            },
                            "dataOut_Strm": {
                                "arg": "dataOut_Strm1_data_decoding",
                                "cat": "ostream"
                            },
                            "delta_Strm": {
                                "arg": "dataOut_Strm0_data_decoding[2]",
                                "cat": "istream"
                            }
                        },
                        "step": -1
                    },
                    {
                        "args": {
                            "CarryIn_Strm": {
                                "arg": "CarryOut0_Strm1_data_decoding",
                                "cat": "istream"
                            },
                            "dataOut_Strm": {
                                "arg": "MydataOut_data_decoding[2]",
                                "cat": "ostream"
                            },
                            "delta_Strm": {
                                "arg": "dataOut_Strm0_data_decoding[1]",
                                "cat": "istream"
                            }
                        },
                        "step": -1
                    }
                ],
                "delta_sum_1out": [
                    {
                        "args": {
                            "CarryIn_Strm": {
                                "arg": "CarryOut1_Strm1_data_decoding",
                                "cat": "istream"
                            },
                            "CarryOut_Strm": {
                                "arg": "CarryOut0_Strm2_data_decoding",
                                "cat": "ostream"
                            },
                            "dataOut_Strm": {
                                "arg": "MydataOut_data_decoding[3]",
                                "cat": "ostream"
                            },
                            "delta_Strm": {
                                "arg": "dataOut_Strm1_data_decoding",
                                "cat": "istream"
                            }
                        },
                        "step": -1
                    }
                ],
                "delta_sum_2out": [
                    {
                        "args": {
                            "CarryIn_Strm": {
                                "arg": "CarryOut_Strm0_data_decoding[0]",
                                "cat": "istream"
                            },
                            "CarryOut_Strm": {
                                "arg": "CarryOut0_Strm1_data_decoding",
                                "cat": "ostream"
                            },
                            "CarryOut_Strm1": {
                                "arg": "CarryOut1_Strm1_data_decoding",
                                "cat": "ostream"
                            },
                            "dataOut_Strm": {
                                "arg": "MydataOut_data_decoding[1]",
                                "cat": "ostream"
                            },
                            "delta_Strm": {
                                "arg": "dataOut_Strm0_data_decoding[0]",
                                "cat": "istream"
                            }
                        },
                        "step": -1
                    }
                ],
                "load": [
                    {
                        "args": {
                            "PA_DATA": {
                                "arg": "PA_DATA_data_decoding",
                                "cat": "ostream"
                            },
                            "PA_metaDATA": {
                                "arg": "PA_meta_Data_data_decoding",
                                "cat": "ostream"
                            },
                            "data_in": {
                                "arg": "outLstrm_data_decoding",
                                "cat": "istream"
                            },
                            "outAll_Lstrm": {
                                "arg": "outAll_Lstrm_data_decoding",
                                "cat": "ostream"
                            },
                            "out_strmC_Track": {
                                "arg": "out_strmC_Track_data_decoding",
                                "cat": "ostream"
                            },
                            "rstStrm": {
                                "arg": "rstStrmL_data_decoding",
                                "cat": "istream"
                            }
                        },
                        "step": -1
                    }
                ],
                "mmap2s": [
                    {
                        "args": {
                            "data_count": {
                                "arg": "data_count",
                                "cat": "scalar"
                            },
                            "input_port": {
                                "arg": "input_port",
                                "cat": "async_mmap"
                            },
                            "outLstrm": {
                                "arg": "outLstrm_data_decoding",
                                "cat": "ostream"
                            },
                            "rstStrmL": {
                                "arg": "rstStrmL_data_decoding",
                                "cat": "ostream"
                            },
                            "rstStrmMeta": {
                                "arg": "rstStrmMeta_data_decoding",
                                "cat": "ostream"
                            },
                            "rstStrmStore": {
                                "arg": "rstStrmStore_data_decoding",
                                "cat": "ostream"
                            },
                            "wait_count": {
                                "arg": "wait_count",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    }
                ],
                "store_all": [
                    {
                        "args": {
                            "OUT0_32b_8b": {
                                "arg": "output_port0_32b_8b",
                                "cat": "async_mmap"
                            },
                            "OUT1_16b_8b": {
                                "arg": "output_port1_16b_8b",
                                "cat": "async_mmap"
                            },
                            "OUT2_16b_8b": {
                                "arg": "output_port2_16b_8b",
                                "cat": "async_mmap"
                            },
                            "OUT3_8b": {
                                "arg": "output_port3_8b",
                                "cat": "async_mmap"
                            },
                            "inAllStrm[0]": {
                                "arg": "dataOut_Strm_data_decoding[0]",
                                "cat": "istream"
                            },
                            "inAllStrm[1]": {
                                "arg": "dataOut_Strm_data_decoding[1]",
                                "cat": "istream"
                            },
                            "inAllStrm[2]": {
                                "arg": "dataOut_Strm_data_decoding[2]",
                                "cat": "istream"
                            },
                            "inAllStrm[3]": {
                                "arg": "dataOut_Strm_data_decoding[3]",
                                "cat": "istream"
                            },
                            "rst_StrmL": {
                                "arg": "rstStrmStore_data_decoding",
                                "cat": "istream"
                            }
                        },
                        "step": -1
                    }
                ]
            },
            "vendor": "xilinx"
        },
        "delta_Fsum": {
            "code": "\n\n\n #include <cstdint>\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <iostream>\n\n#include <fstream>\n\n#include <string>\n\n#include <vector>\n\n#include <algorithm>\n\n#include <inttypes.h>\n\n\n #include \"ap_int.h\"\n\n#include <tapa.h>\n\n// const uint32_t dataWR_Cnt = 934640;\n// const uint32_t metaWR_Cnt = 934640;  //2147483647;\nconst uint8_t SR = 0;\nconst uint8_t DIRECT = 1;\nconst uint8_t PATCHED = 2;\nconst uint8_t DELTA = 3;\nconst uint8_t HEADER_ST = 7;\nconst uint8_t SR_STATE = 0; // 0 from 8\nconst uint8_t DI_STATE = 1; // 1 from 5\nconst uint8_t PA_STATE = 2; // 2 from 7\nconst uint8_t DE_STATE = 3; // 3 from 2\nconst uint8_t ASSIGN_DATA = 4;\nconst uint8_t PA_META_PROC = 5;\nconst uint8_t TR_HEADER = 6;\nconst uint8_t HD_PROC = 8;\nconst uint8_t waste_cycles = 9;\nconst uint16_t AXI_WIDTH_2X = 1024;\nconst uint16_t AXI_WIDTH_4X = 2048;\nconst uint16_t AXI_WIDTH = 512;\nconst uint16_t SR_DATAW = 320;\nconst uint16_t AXI_WIDTH_H = 256;\nconst uint16_t AXI_WIDTH_HH = 128;\ntypedef ap_uint<AXI_WIDTH_4X> _2048b;\ntypedef ap_uint<AXI_WIDTH_2X> _1024b;\ntypedef ap_uint<AXI_WIDTH> _512b;\ntypedef ap_int<AXI_WIDTH> _512bi;\ntypedef ap_uint<SR_DATAW> _320b;\ntypedef ap_uint<AXI_WIDTH_H> _256b;\ntypedef ap_uint<AXI_WIDTH_HH> _128b;\nconst uint16_t PEs = 16;\n// Map to bit width value.\n// const uint16_t NDelta_BitMap[32] = {1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n// const uint16_t Delta_BitMap[32] = {0,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n\nvoid mmap2s(uint64_t  input_port,\n            tapa::ostream<_512b>& outLstrm,\n            tapa::ostream<bool>& rstStrmL,\n            tapa::ostream<bool>& rstStrmMeta,\n            tapa::ostream<bool>& rstStrmStore,\n            uint32_t wait_count,\n            uint32_t data_count)\n;\nvoid load(tapa::istream<_512b>& data_in,\n            tapa::istream<bool>& rstStrm,\n            tapa::ostream<_2048b>& outAll_Lstrm,\n            tapa::ostream<_256b> &out_strmC_Track,\n            tapa::ostream<_512b>& PA_DATA,\n            tapa::ostream<uint32_t>& PA_metaDATA\n            // tapa::ostream<uint32_t>& paCnt_strm\n            // uint32_t KRNL_Data_Write\n            // uint32_t data_count\n                 )\n;\nvoid data_Sender(tapa::istream<_2048b>& data_in,\n                tapa::istream<_256b>& meta_in,\n                // tapa::istream<bool> & rst_Strm,\n                tapa::ostreams<_512b,4>& outAll_Pstrm,\n                tapa::ostream<uint64_t>& outSR_Pstrm,\n                tapa::ostreams<_256b, 4>& meta_out,\n                tapa::ostream<uint8_t>& SR_meta_out,\n                tapa::ostream<uint64_t>& All_meta_out,\n                tapa::ostream<uint8_t>& Dec_type_Out\n                // tapa::ostream<uint32_t>& data_Cnt,\n                // tapa::ostream<uint32_t>& pa_Cnt\n                )\n;\nvoid compSR(tapa::istream<uint64_t>& outSR_Pstrm,\n            tapa::istream<uint8_t>& meta_out,\n            tapa::ostream<_320b>& SR_Dout)\n;\nvoid compute_delta(tapa::istream<_512b>& in_Cstrm,\n                tapa::istream<_256b>& in_Trstrm,\n                tapa::ostream<uint32_t>& out_Cmeta_strm,\n                tapa::ostream<_512b>& out_Cstrm,\n                tapa::ostream<_512b>& DI_strm,\n                tapa::ostream<_512b>& PA_strm,\n                tapa::ostream<uint32_t>& PA_meta_strm,\n                uint32_t compD_ID)\n;\nvoid PA_meta_proc(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_meta_Strm,\n                tapa::ostream<uint64_t>& metaOutPA_Strm) //PLL, IDX, VAL\n;\nvoid PA_sum_out(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_BV_Strm,\n                tapa::ostream<_512b>& dataOutPA_Strm\n                )\n;\nvoid Meta_Aligner(tapa::istream<uint64_t>& PA_metaStrm,\n                tapa::istream<uint64_t>& All_meta_Strm,\n                tapa::ostream<_128b>& meta_Out\n                )\n;\nvoid Meta_Writer(tapa::istream<_128b>& PA_metaStrm,\n                tapa::istream<bool>& rst_StrmDS,\n                // tapa::istream<uint32_t>& complete_count,\n                uint64_t  metaPort_Out\n                // uint32_t KRNL_Data_Write\n                )\n;\nvoid delta_sumNC_in(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                // ,uint32_t ID\n                )\n;\nvoid delta_sumNC_all(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_sum_2out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm1\n                )\n;\nvoid delta_sum_1out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                )\n;\nvoid delta_sum_0out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_Fsum(tapa::istreams<_512b, 4>& delta_Strm,\n                tapa::istreams<uint32_t, 4>& meta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostreams<_512b, 4>& dataOut_Strm\n                )\n{\n#pragma HLS disaggregate variable = delta_Strm\n#pragma HLS array_partition variable = delta_Strm complete\n#pragma HLS interface ap_fifo port = delta_Strm[0]._\n#pragma HLS aggregate variable = delta_Strm[0]._ bit\n#pragma HLS interface ap_fifo port = delta_Strm[0]._peek\n#pragma HLS aggregate variable = delta_Strm[0]._peek bit\nvoid(delta_Strm[0]._.empty());\nvoid(delta_Strm[0]._peek.empty());\n#pragma HLS interface ap_fifo port = delta_Strm[1]._\n#pragma HLS aggregate variable = delta_Strm[1]._ bit\n#pragma HLS interface ap_fifo port = delta_Strm[1]._peek\n#pragma HLS aggregate variable = delta_Strm[1]._peek bit\nvoid(delta_Strm[1]._.empty());\nvoid(delta_Strm[1]._peek.empty());\n#pragma HLS interface ap_fifo port = delta_Strm[2]._\n#pragma HLS aggregate variable = delta_Strm[2]._ bit\n#pragma HLS interface ap_fifo port = delta_Strm[2]._peek\n#pragma HLS aggregate variable = delta_Strm[2]._peek bit\nvoid(delta_Strm[2]._.empty());\nvoid(delta_Strm[2]._peek.empty());\n#pragma HLS interface ap_fifo port = delta_Strm[3]._\n#pragma HLS aggregate variable = delta_Strm[3]._ bit\n#pragma HLS interface ap_fifo port = delta_Strm[3]._peek\n#pragma HLS aggregate variable = delta_Strm[3]._peek bit\nvoid(delta_Strm[3]._.empty());\nvoid(delta_Strm[3]._peek.empty());\n\n#pragma HLS disaggregate variable = meta_Strm\n#pragma HLS array_partition variable = meta_Strm complete\n#pragma HLS interface ap_fifo port = meta_Strm[0]._\n#pragma HLS aggregate variable = meta_Strm[0]._ bit\n#pragma HLS interface ap_fifo port = meta_Strm[0]._peek\n#pragma HLS aggregate variable = meta_Strm[0]._peek bit\nvoid(meta_Strm[0]._.empty());\nvoid(meta_Strm[0]._peek.empty());\n#pragma HLS interface ap_fifo port = meta_Strm[1]._\n#pragma HLS aggregate variable = meta_Strm[1]._ bit\n#pragma HLS interface ap_fifo port = meta_Strm[1]._peek\n#pragma HLS aggregate variable = meta_Strm[1]._peek bit\nvoid(meta_Strm[1]._.empty());\nvoid(meta_Strm[1]._peek.empty());\n#pragma HLS interface ap_fifo port = meta_Strm[2]._\n#pragma HLS aggregate variable = meta_Strm[2]._ bit\n#pragma HLS interface ap_fifo port = meta_Strm[2]._peek\n#pragma HLS aggregate variable = meta_Strm[2]._peek bit\nvoid(meta_Strm[2]._.empty());\nvoid(meta_Strm[2]._peek.empty());\n#pragma HLS interface ap_fifo port = meta_Strm[3]._\n#pragma HLS aggregate variable = meta_Strm[3]._ bit\n#pragma HLS interface ap_fifo port = meta_Strm[3]._peek\n#pragma HLS aggregate variable = meta_Strm[3]._peek bit\nvoid(meta_Strm[3]._.empty());\nvoid(meta_Strm[3]._peek.empty());\n\n#pragma HLS disaggregate variable = CarryIn_Strm\n#pragma HLS interface ap_fifo port = CarryIn_Strm._\n#pragma HLS aggregate variable = CarryIn_Strm._ bit\n#pragma HLS interface ap_fifo port = CarryIn_Strm._peek\n#pragma HLS aggregate variable = CarryIn_Strm._peek bit\nvoid(CarryIn_Strm._.empty());\nvoid(CarryIn_Strm._peek.empty());\n\n#pragma HLS disaggregate variable = dataOut_Strm\n#pragma HLS array_partition variable = dataOut_Strm complete\n#pragma HLS interface ap_fifo port = dataOut_Strm[0]._\n#pragma HLS aggregate variable = dataOut_Strm[0]._ bit\nvoid(dataOut_Strm[0]._.full());\n#pragma HLS interface ap_fifo port = dataOut_Strm[1]._\n#pragma HLS aggregate variable = dataOut_Strm[1]._ bit\nvoid(dataOut_Strm[1]._.full());\n#pragma HLS interface ap_fifo port = dataOut_Strm[2]._\n#pragma HLS aggregate variable = dataOut_Strm[2]._ bit\nvoid(dataOut_Strm[2]._.full());\n#pragma HLS interface ap_fifo port = dataOut_Strm[3]._\n#pragma HLS aggregate variable = dataOut_Strm[3]._ bit\nvoid(dataOut_Strm[3]._.full());\n\n    ap_uint<AXI_WIDTH> myNums[4];\n    ap_uint<AXI_WIDTH> bufferWriteStrm[4];\n    // uint32_t d[PEs] = {0};\n    int32_t num0[PEs] = {0};\n    int32_t num1[PEs] = {0};\n    int32_t num2[PEs] = {0};\n    int32_t num3[PEs] = {0};\n    int32_t fnum0[PEs] = {0};\n    int32_t fnum1[PEs] = {0};\n    int32_t fnum2[PEs] = {0};\n    int32_t fnum3[PEs] = {0};\n    int32_t cin = 0;\n    int32_t store_cin = 0;\n    int32_t metaData = 0;\n    bool BSF = 0;\n    // #pragma HLS bind_storage variable=num0 type=RAM_2P impl=bram\n    // #pragma HLS bind_storage variable=num1 type=RAM_2P impl=bram\n    // #pragma HLS bind_storage variable=num2 type=RAM_2P impl=bram\n    // #pragma HLS bind_storage variable=num3 type=RAM_2P impl=bram\n    // #pragma HLS bind_storage variable=fnum0 type=RAM_2P impl=bram\n    // #pragma HLS bind_storage variable=fnum1 type=RAM_2P impl=bram\n    // #pragma HLS bind_storage variable=fnum2 type=RAM_2P impl=bram\n    // #pragma HLS bind_storage variable=fnum3 type=RAM_2P impl=bram\n    sum_deltas1:for( ; ; )\n    {\n#pragma HLS pipeline II=1\n        if((!delta_Strm[2].empty()) && (!delta_Strm[3].empty()))\n        {\n            metaData = meta_Strm[0].read();\n            BSF = metaData & 0xFF;\n            read_Nums:for(int i = 0; i < 4; i++)\n            {\n#pragma HLS UNROLL\n                myNums[i] = delta_Strm[i].read();\n            }\n            if(BSF)\n            {\n                cin = 0;\n                writeNums0:for(int i = 0; i < 4; i++)\n                {\n#pragma HLS UNROLL\n                    dataOut_Strm[i].write(myNums[i]);\n                }\n            }\n            else\n            {\n                cin = store_cin;\n                // read_Nums:for(int i = 0; i < 4; i++)\n                // {\n                //     #pragma HLS UNROLL\n                //     myNums[i] = delta_Strm[i].read();\n                // }\n                unPackNums:for(int i = 0; i < PEs; i++)\n                {\n#pragma HLS UNROLL\n                    num0[i] = myNums[0].range((i*32) + 31, i*32);\n                    num1[i] = myNums[1].range((i*32) + 31, i*32);\n                    num2[i] = myNums[2].range((i*32) + 31, i*32);\n                    num3[i] = myNums[3].range((i*32) + 31, i*32);\n                }\n                sumCIN:for(int i = 0; i < PEs; i++)\n                {\n#pragma HLS UNROLL\n                    // #pragma HLS BIND_OP variable=fnum0 op=add impl=dsp\n                    // #pragma HLS BIND_OP variable=fnum1 op=add impl=dsp\n                    // #pragma HLS BIND_OP variable=fnum2 op=add impl=dsp\n                    // #pragma HLS BIND_OP variable=fnum3 op=add impl=dsp\n                    fnum0[i] = num0[i] + cin;\n                    fnum1[i] = num1[i] + cin;\n                    fnum2[i] = num2[i] + cin;\n                    fnum3[i] = num3[i] + cin;\n                }\n                packNum:for(int i = 0; i < PEs; i++)\n                {\n                    bufferWriteStrm[0].range((i*32) + 31, i*32) = fnum0[i];\n                    bufferWriteStrm[1].range((i*32) + 31, i*32) = fnum1[i];\n                    bufferWriteStrm[2].range((i*32) + 31, i*32) = fnum2[i];\n                    bufferWriteStrm[3].range((i*32) + 31, i*32) = fnum3[i];\n                }\n                writeNums1:for(int i = 0; i < 4; i++)\n                {\n#pragma HLS UNROLL\n                    dataOut_Strm[i].write(bufferWriteStrm[i]);\n                }\n            }\n            store_cin = CarryIn_Strm.read() + cin;\n        }\n    }\n}\nvoid Data_Aligner(tapa::istream<uint8_t>& inTrackStrm,\n                tapa::istreams<_512b, 4>& inDEStrm,\n                tapa::istreams<_512b, 4>& inDIStrm,\n                tapa::istreams<_512b, 4>& inPAStrm,\n                tapa::istream<_320b>& inSRStrm,\n                tapa::ostreams<_512b, 4>& outWRStrm )\n;\nvoid store_all(tapa::istreams<_512b, 4>& inAllStrm,\n            tapa::istream<bool>& rst_StrmL,\n            // tapa::istream<uint32_t>& dataCnt_strm,\n            uint64_t OUT0_32b_8b,\n            uint64_t OUT1_16b_8b,\n            uint64_t OUT2_16b_8b,\n            uint64_t OUT3_8b)\n;\nvoid data_decoding(uint64_t  input_port,\n                    uint64_t  output_port0_32b_8b,\n                    uint64_t  output_port1_16b_8b,\n                    uint64_t  output_port2_16b_8b,\n                    uint64_t  output_port3_8b,\n                    uint64_t  output_port4_Track,\n                    uint32_t wait_count,\n                    uint32_t data_count)\n;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "delta_sumNC_all": {
            "code": "\n\n\n #include <cstdint>\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <iostream>\n\n#include <fstream>\n\n#include <string>\n\n#include <vector>\n\n#include <algorithm>\n\n#include <inttypes.h>\n\n\n #include \"ap_int.h\"\n\n#include <tapa.h>\n\n// const uint32_t dataWR_Cnt = 934640;\n// const uint32_t metaWR_Cnt = 934640;  //2147483647;\nconst uint8_t SR = 0;\nconst uint8_t DIRECT = 1;\nconst uint8_t PATCHED = 2;\nconst uint8_t DELTA = 3;\nconst uint8_t HEADER_ST = 7;\nconst uint8_t SR_STATE = 0; // 0 from 8\nconst uint8_t DI_STATE = 1; // 1 from 5\nconst uint8_t PA_STATE = 2; // 2 from 7\nconst uint8_t DE_STATE = 3; // 3 from 2\nconst uint8_t ASSIGN_DATA = 4;\nconst uint8_t PA_META_PROC = 5;\nconst uint8_t TR_HEADER = 6;\nconst uint8_t HD_PROC = 8;\nconst uint8_t waste_cycles = 9;\nconst uint16_t AXI_WIDTH_2X = 1024;\nconst uint16_t AXI_WIDTH_4X = 2048;\nconst uint16_t AXI_WIDTH = 512;\nconst uint16_t SR_DATAW = 320;\nconst uint16_t AXI_WIDTH_H = 256;\nconst uint16_t AXI_WIDTH_HH = 128;\ntypedef ap_uint<AXI_WIDTH_4X> _2048b;\ntypedef ap_uint<AXI_WIDTH_2X> _1024b;\ntypedef ap_uint<AXI_WIDTH> _512b;\ntypedef ap_int<AXI_WIDTH> _512bi;\ntypedef ap_uint<SR_DATAW> _320b;\ntypedef ap_uint<AXI_WIDTH_H> _256b;\ntypedef ap_uint<AXI_WIDTH_HH> _128b;\nconst uint16_t PEs = 16;\n// Map to bit width value.\n// const uint16_t NDelta_BitMap[32] = {1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n// const uint16_t Delta_BitMap[32] = {0,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n\nvoid mmap2s(uint64_t  input_port,\n            tapa::ostream<_512b>& outLstrm,\n            tapa::ostream<bool>& rstStrmL,\n            tapa::ostream<bool>& rstStrmMeta,\n            tapa::ostream<bool>& rstStrmStore,\n            uint32_t wait_count,\n            uint32_t data_count)\n;\nvoid load(tapa::istream<_512b>& data_in,\n            tapa::istream<bool>& rstStrm,\n            tapa::ostream<_2048b>& outAll_Lstrm,\n            tapa::ostream<_256b> &out_strmC_Track,\n            tapa::ostream<_512b>& PA_DATA,\n            tapa::ostream<uint32_t>& PA_metaDATA\n            // tapa::ostream<uint32_t>& paCnt_strm\n            // uint32_t KRNL_Data_Write\n            // uint32_t data_count\n                 )\n;\nvoid data_Sender(tapa::istream<_2048b>& data_in,\n                tapa::istream<_256b>& meta_in,\n                // tapa::istream<bool> & rst_Strm,\n                tapa::ostreams<_512b,4>& outAll_Pstrm,\n                tapa::ostream<uint64_t>& outSR_Pstrm,\n                tapa::ostreams<_256b, 4>& meta_out,\n                tapa::ostream<uint8_t>& SR_meta_out,\n                tapa::ostream<uint64_t>& All_meta_out,\n                tapa::ostream<uint8_t>& Dec_type_Out\n                // tapa::ostream<uint32_t>& data_Cnt,\n                // tapa::ostream<uint32_t>& pa_Cnt\n                )\n;\nvoid compSR(tapa::istream<uint64_t>& outSR_Pstrm,\n            tapa::istream<uint8_t>& meta_out,\n            tapa::ostream<_320b>& SR_Dout)\n;\nvoid compute_delta(tapa::istream<_512b>& in_Cstrm,\n                tapa::istream<_256b>& in_Trstrm,\n                tapa::ostream<uint32_t>& out_Cmeta_strm,\n                tapa::ostream<_512b>& out_Cstrm,\n                tapa::ostream<_512b>& DI_strm,\n                tapa::ostream<_512b>& PA_strm,\n                tapa::ostream<uint32_t>& PA_meta_strm,\n                uint32_t compD_ID)\n;\nvoid PA_meta_proc(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_meta_Strm,\n                tapa::ostream<uint64_t>& metaOutPA_Strm) //PLL, IDX, VAL\n;\nvoid PA_sum_out(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_BV_Strm,\n                tapa::ostream<_512b>& dataOutPA_Strm\n                )\n;\nvoid Meta_Aligner(tapa::istream<uint64_t>& PA_metaStrm,\n                tapa::istream<uint64_t>& All_meta_Strm,\n                tapa::ostream<_128b>& meta_Out\n                )\n;\nvoid Meta_Writer(tapa::istream<_128b>& PA_metaStrm,\n                tapa::istream<bool>& rst_StrmDS,\n                // tapa::istream<uint32_t>& complete_count,\n                uint64_t  metaPort_Out\n                // uint32_t KRNL_Data_Write\n                )\n;\nvoid delta_sumNC_in(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                // ,uint32_t ID\n                )\n;\nvoid delta_sumNC_all(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n{\n#pragma HLS disaggregate variable = delta_Strm\n#pragma HLS interface ap_fifo port = delta_Strm._\n#pragma HLS aggregate variable = delta_Strm._ bit\n#pragma HLS interface ap_fifo port = delta_Strm._peek\n#pragma HLS aggregate variable = delta_Strm._peek bit\nvoid(delta_Strm._.empty());\nvoid(delta_Strm._peek.empty());\n\n#pragma HLS disaggregate variable = dataOut_Strm\n#pragma HLS interface ap_fifo port = dataOut_Strm._\n#pragma HLS aggregate variable = dataOut_Strm._ bit\nvoid(dataOut_Strm._.full());\n\n    ap_uint<AXI_WIDTH> myNums;\n    ap_uint<AXI_WIDTH> bufferWriteStrm;\n    int32_t d[PEs] = {0};\n    int32_t num[PEs] = {0};\n    sum_deltas0:for( ; ; )\n    {\n#pragma HLS pipeline II=1\n        if(!delta_Strm.empty())\n        {\n            myNums = delta_Strm.read();\n            delta_read:for(int i = 0; i < PEs; i++)\n            {\n#pragma HLS unroll\n                d[i] = myNums.range(((i*32)+31),(i*32));\n            }\n            num[0] = d[0];\n            sumD:for(int i = 1; i < PEs; i++)\n            {\n#pragma HLS UNROLL\n                // #pragma HLS BIND_OP variable=num op=add impl=dsp\n                num[i] = num[i-1] + d[i];\n            }\n            dWriter:for(int i = 0; i < PEs; i++)\n            {\n#pragma HLS UNROLL\n                bufferWriteStrm.range(((i*32)+31),(i*32)) = num[i];\n            }\n            dataOut_Strm.write(bufferWriteStrm);\n        }\n    }\n}\nvoid delta_sum_2out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm1\n                )\n;\nvoid delta_sum_1out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                )\n;\nvoid delta_sum_0out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_Fsum(tapa::istreams<_512b, 4>& delta_Strm,\n                tapa::istreams<uint32_t, 4>& meta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostreams<_512b, 4>& dataOut_Strm\n                )\n;\nvoid Data_Aligner(tapa::istream<uint8_t>& inTrackStrm,\n                tapa::istreams<_512b, 4>& inDEStrm,\n                tapa::istreams<_512b, 4>& inDIStrm,\n                tapa::istreams<_512b, 4>& inPAStrm,\n                tapa::istream<_320b>& inSRStrm,\n                tapa::ostreams<_512b, 4>& outWRStrm )\n;\nvoid store_all(tapa::istreams<_512b, 4>& inAllStrm,\n            tapa::istream<bool>& rst_StrmL,\n            // tapa::istream<uint32_t>& dataCnt_strm,\n            uint64_t OUT0_32b_8b,\n            uint64_t OUT1_16b_8b,\n            uint64_t OUT2_16b_8b,\n            uint64_t OUT3_8b)\n;\nvoid data_decoding(uint64_t  input_port,\n                    uint64_t  output_port0_32b_8b,\n                    uint64_t  output_port1_16b_8b,\n                    uint64_t  output_port2_16b_8b,\n                    uint64_t  output_port3_8b,\n                    uint64_t  output_port4_Track,\n                    uint32_t wait_count,\n                    uint32_t data_count)\n;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "delta_sumNC_in": {
            "code": "\n\n\n #include <cstdint>\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <iostream>\n\n#include <fstream>\n\n#include <string>\n\n#include <vector>\n\n#include <algorithm>\n\n#include <inttypes.h>\n\n\n #include \"ap_int.h\"\n\n#include <tapa.h>\n\n// const uint32_t dataWR_Cnt = 934640;\n// const uint32_t metaWR_Cnt = 934640;  //2147483647;\nconst uint8_t SR = 0;\nconst uint8_t DIRECT = 1;\nconst uint8_t PATCHED = 2;\nconst uint8_t DELTA = 3;\nconst uint8_t HEADER_ST = 7;\nconst uint8_t SR_STATE = 0; // 0 from 8\nconst uint8_t DI_STATE = 1; // 1 from 5\nconst uint8_t PA_STATE = 2; // 2 from 7\nconst uint8_t DE_STATE = 3; // 3 from 2\nconst uint8_t ASSIGN_DATA = 4;\nconst uint8_t PA_META_PROC = 5;\nconst uint8_t TR_HEADER = 6;\nconst uint8_t HD_PROC = 8;\nconst uint8_t waste_cycles = 9;\nconst uint16_t AXI_WIDTH_2X = 1024;\nconst uint16_t AXI_WIDTH_4X = 2048;\nconst uint16_t AXI_WIDTH = 512;\nconst uint16_t SR_DATAW = 320;\nconst uint16_t AXI_WIDTH_H = 256;\nconst uint16_t AXI_WIDTH_HH = 128;\ntypedef ap_uint<AXI_WIDTH_4X> _2048b;\ntypedef ap_uint<AXI_WIDTH_2X> _1024b;\ntypedef ap_uint<AXI_WIDTH> _512b;\ntypedef ap_int<AXI_WIDTH> _512bi;\ntypedef ap_uint<SR_DATAW> _320b;\ntypedef ap_uint<AXI_WIDTH_H> _256b;\ntypedef ap_uint<AXI_WIDTH_HH> _128b;\nconst uint16_t PEs = 16;\n// Map to bit width value.\n// const uint16_t NDelta_BitMap[32] = {1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n// const uint16_t Delta_BitMap[32] = {0,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n\nvoid mmap2s(uint64_t  input_port,\n            tapa::ostream<_512b>& outLstrm,\n            tapa::ostream<bool>& rstStrmL,\n            tapa::ostream<bool>& rstStrmMeta,\n            tapa::ostream<bool>& rstStrmStore,\n            uint32_t wait_count,\n            uint32_t data_count)\n;\nvoid load(tapa::istream<_512b>& data_in,\n            tapa::istream<bool>& rstStrm,\n            tapa::ostream<_2048b>& outAll_Lstrm,\n            tapa::ostream<_256b> &out_strmC_Track,\n            tapa::ostream<_512b>& PA_DATA,\n            tapa::ostream<uint32_t>& PA_metaDATA\n            // tapa::ostream<uint32_t>& paCnt_strm\n            // uint32_t KRNL_Data_Write\n            // uint32_t data_count\n                 )\n;\nvoid data_Sender(tapa::istream<_2048b>& data_in,\n                tapa::istream<_256b>& meta_in,\n                // tapa::istream<bool> & rst_Strm,\n                tapa::ostreams<_512b,4>& outAll_Pstrm,\n                tapa::ostream<uint64_t>& outSR_Pstrm,\n                tapa::ostreams<_256b, 4>& meta_out,\n                tapa::ostream<uint8_t>& SR_meta_out,\n                tapa::ostream<uint64_t>& All_meta_out,\n                tapa::ostream<uint8_t>& Dec_type_Out\n                // tapa::ostream<uint32_t>& data_Cnt,\n                // tapa::ostream<uint32_t>& pa_Cnt\n                )\n;\nvoid compSR(tapa::istream<uint64_t>& outSR_Pstrm,\n            tapa::istream<uint8_t>& meta_out,\n            tapa::ostream<_320b>& SR_Dout)\n;\nvoid compute_delta(tapa::istream<_512b>& in_Cstrm,\n                tapa::istream<_256b>& in_Trstrm,\n                tapa::ostream<uint32_t>& out_Cmeta_strm,\n                tapa::ostream<_512b>& out_Cstrm,\n                tapa::ostream<_512b>& DI_strm,\n                tapa::ostream<_512b>& PA_strm,\n                tapa::ostream<uint32_t>& PA_meta_strm,\n                uint32_t compD_ID)\n;\nvoid PA_meta_proc(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_meta_Strm,\n                tapa::ostream<uint64_t>& metaOutPA_Strm) //PLL, IDX, VAL\n;\nvoid PA_sum_out(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_BV_Strm,\n                tapa::ostream<_512b>& dataOutPA_Strm\n                )\n;\nvoid Meta_Aligner(tapa::istream<uint64_t>& PA_metaStrm,\n                tapa::istream<uint64_t>& All_meta_Strm,\n                tapa::ostream<_128b>& meta_Out\n                )\n;\nvoid Meta_Writer(tapa::istream<_128b>& PA_metaStrm,\n                tapa::istream<bool>& rst_StrmDS,\n                // tapa::istream<uint32_t>& complete_count,\n                uint64_t  metaPort_Out\n                // uint32_t KRNL_Data_Write\n                )\n;\nvoid delta_sumNC_in(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                // ,uint32_t ID\n                )\n{\n#pragma HLS disaggregate variable = delta_Strm\n#pragma HLS interface ap_fifo port = delta_Strm._\n#pragma HLS aggregate variable = delta_Strm._ bit\n#pragma HLS interface ap_fifo port = delta_Strm._peek\n#pragma HLS aggregate variable = delta_Strm._peek bit\nvoid(delta_Strm._.empty());\nvoid(delta_Strm._peek.empty());\n\n#pragma HLS disaggregate variable = dataOut_Strm\n#pragma HLS interface ap_fifo port = dataOut_Strm._\n#pragma HLS aggregate variable = dataOut_Strm._ bit\nvoid(dataOut_Strm._.full());\n\n#pragma HLS disaggregate variable = CarryOut_Strm\n#pragma HLS interface ap_fifo port = CarryOut_Strm._\n#pragma HLS aggregate variable = CarryOut_Strm._ bit\nvoid(CarryOut_Strm._.full());\n\n    ap_uint<AXI_WIDTH> myNums;\n    ap_uint<AXI_WIDTH> bufferWriteStrm;\n    int32_t d[PEs] = {0};\n    int32_t num[PEs] = {0};\n    sum_deltas0:for( ; ; )\n    {\n#pragma HLS pipeline II=1\n        if(!delta_Strm.empty())\n        {\n            myNums = delta_Strm.read();\n            delta_read:for(int i = 0; i < PEs; i++)\n            {\n#pragma HLS unroll\n                d[i] = myNums.range(((i*32)+31),(i*32));\n            }\n            num[0] = d[0];\n            sumD:for(int i = 1; i < PEs; i++)\n            {\n#pragma HLS UNROLL\n                // #pragma HLS BIND_OP variable=num op=add impl=dsp\n                num[i] = num[i-1] + d[i];\n            }\n            CarryOut_Strm.write(num[15]);\n            dWriter:for(int i = 0; i < PEs; i++)\n            {\n#pragma HLS UNROLL\n                bufferWriteStrm.range(((i*32)+31),(i*32)) = num[i];\n            }\n            dataOut_Strm.write(bufferWriteStrm);\n        }\n    }\n}\nvoid delta_sumNC_all(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_sum_2out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm1\n                )\n;\nvoid delta_sum_1out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                )\n;\nvoid delta_sum_0out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_Fsum(tapa::istreams<_512b, 4>& delta_Strm,\n                tapa::istreams<uint32_t, 4>& meta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostreams<_512b, 4>& dataOut_Strm\n                )\n;\nvoid Data_Aligner(tapa::istream<uint8_t>& inTrackStrm,\n                tapa::istreams<_512b, 4>& inDEStrm,\n                tapa::istreams<_512b, 4>& inDIStrm,\n                tapa::istreams<_512b, 4>& inPAStrm,\n                tapa::istream<_320b>& inSRStrm,\n                tapa::ostreams<_512b, 4>& outWRStrm )\n;\nvoid store_all(tapa::istreams<_512b, 4>& inAllStrm,\n            tapa::istream<bool>& rst_StrmL,\n            // tapa::istream<uint32_t>& dataCnt_strm,\n            uint64_t OUT0_32b_8b,\n            uint64_t OUT1_16b_8b,\n            uint64_t OUT2_16b_8b,\n            uint64_t OUT3_8b)\n;\nvoid data_decoding(uint64_t  input_port,\n                    uint64_t  output_port0_32b_8b,\n                    uint64_t  output_port1_16b_8b,\n                    uint64_t  output_port2_16b_8b,\n                    uint64_t  output_port3_8b,\n                    uint64_t  output_port4_Track,\n                    uint32_t wait_count,\n                    uint32_t data_count)\n;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "delta_sum_0out": {
            "code": "\n\n\n #include <cstdint>\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <iostream>\n\n#include <fstream>\n\n#include <string>\n\n#include <vector>\n\n#include <algorithm>\n\n#include <inttypes.h>\n\n\n #include \"ap_int.h\"\n\n#include <tapa.h>\n\n// const uint32_t dataWR_Cnt = 934640;\n// const uint32_t metaWR_Cnt = 934640;  //2147483647;\nconst uint8_t SR = 0;\nconst uint8_t DIRECT = 1;\nconst uint8_t PATCHED = 2;\nconst uint8_t DELTA = 3;\nconst uint8_t HEADER_ST = 7;\nconst uint8_t SR_STATE = 0; // 0 from 8\nconst uint8_t DI_STATE = 1; // 1 from 5\nconst uint8_t PA_STATE = 2; // 2 from 7\nconst uint8_t DE_STATE = 3; // 3 from 2\nconst uint8_t ASSIGN_DATA = 4;\nconst uint8_t PA_META_PROC = 5;\nconst uint8_t TR_HEADER = 6;\nconst uint8_t HD_PROC = 8;\nconst uint8_t waste_cycles = 9;\nconst uint16_t AXI_WIDTH_2X = 1024;\nconst uint16_t AXI_WIDTH_4X = 2048;\nconst uint16_t AXI_WIDTH = 512;\nconst uint16_t SR_DATAW = 320;\nconst uint16_t AXI_WIDTH_H = 256;\nconst uint16_t AXI_WIDTH_HH = 128;\ntypedef ap_uint<AXI_WIDTH_4X> _2048b;\ntypedef ap_uint<AXI_WIDTH_2X> _1024b;\ntypedef ap_uint<AXI_WIDTH> _512b;\ntypedef ap_int<AXI_WIDTH> _512bi;\ntypedef ap_uint<SR_DATAW> _320b;\ntypedef ap_uint<AXI_WIDTH_H> _256b;\ntypedef ap_uint<AXI_WIDTH_HH> _128b;\nconst uint16_t PEs = 16;\n// Map to bit width value.\n// const uint16_t NDelta_BitMap[32] = {1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n// const uint16_t Delta_BitMap[32] = {0,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n\nvoid mmap2s(uint64_t  input_port,\n            tapa::ostream<_512b>& outLstrm,\n            tapa::ostream<bool>& rstStrmL,\n            tapa::ostream<bool>& rstStrmMeta,\n            tapa::ostream<bool>& rstStrmStore,\n            uint32_t wait_count,\n            uint32_t data_count)\n;\nvoid load(tapa::istream<_512b>& data_in,\n            tapa::istream<bool>& rstStrm,\n            tapa::ostream<_2048b>& outAll_Lstrm,\n            tapa::ostream<_256b> &out_strmC_Track,\n            tapa::ostream<_512b>& PA_DATA,\n            tapa::ostream<uint32_t>& PA_metaDATA\n            // tapa::ostream<uint32_t>& paCnt_strm\n            // uint32_t KRNL_Data_Write\n            // uint32_t data_count\n                 )\n;\nvoid data_Sender(tapa::istream<_2048b>& data_in,\n                tapa::istream<_256b>& meta_in,\n                // tapa::istream<bool> & rst_Strm,\n                tapa::ostreams<_512b,4>& outAll_Pstrm,\n                tapa::ostream<uint64_t>& outSR_Pstrm,\n                tapa::ostreams<_256b, 4>& meta_out,\n                tapa::ostream<uint8_t>& SR_meta_out,\n                tapa::ostream<uint64_t>& All_meta_out,\n                tapa::ostream<uint8_t>& Dec_type_Out\n                // tapa::ostream<uint32_t>& data_Cnt,\n                // tapa::ostream<uint32_t>& pa_Cnt\n                )\n;\nvoid compSR(tapa::istream<uint64_t>& outSR_Pstrm,\n            tapa::istream<uint8_t>& meta_out,\n            tapa::ostream<_320b>& SR_Dout)\n;\nvoid compute_delta(tapa::istream<_512b>& in_Cstrm,\n                tapa::istream<_256b>& in_Trstrm,\n                tapa::ostream<uint32_t>& out_Cmeta_strm,\n                tapa::ostream<_512b>& out_Cstrm,\n                tapa::ostream<_512b>& DI_strm,\n                tapa::ostream<_512b>& PA_strm,\n                tapa::ostream<uint32_t>& PA_meta_strm,\n                uint32_t compD_ID)\n;\nvoid PA_meta_proc(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_meta_Strm,\n                tapa::ostream<uint64_t>& metaOutPA_Strm) //PLL, IDX, VAL\n;\nvoid PA_sum_out(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_BV_Strm,\n                tapa::ostream<_512b>& dataOutPA_Strm\n                )\n;\nvoid Meta_Aligner(tapa::istream<uint64_t>& PA_metaStrm,\n                tapa::istream<uint64_t>& All_meta_Strm,\n                tapa::ostream<_128b>& meta_Out\n                )\n;\nvoid Meta_Writer(tapa::istream<_128b>& PA_metaStrm,\n                tapa::istream<bool>& rst_StrmDS,\n                // tapa::istream<uint32_t>& complete_count,\n                uint64_t  metaPort_Out\n                // uint32_t KRNL_Data_Write\n                )\n;\nvoid delta_sumNC_in(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                // ,uint32_t ID\n                )\n;\nvoid delta_sumNC_all(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_sum_2out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm1\n                )\n;\nvoid delta_sum_1out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                )\n;\nvoid delta_sum_0out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n{\n#pragma HLS disaggregate variable = delta_Strm\n#pragma HLS interface ap_fifo port = delta_Strm._\n#pragma HLS aggregate variable = delta_Strm._ bit\n#pragma HLS interface ap_fifo port = delta_Strm._peek\n#pragma HLS aggregate variable = delta_Strm._peek bit\nvoid(delta_Strm._.empty());\nvoid(delta_Strm._peek.empty());\n\n#pragma HLS disaggregate variable = CarryIn_Strm\n#pragma HLS interface ap_fifo port = CarryIn_Strm._\n#pragma HLS aggregate variable = CarryIn_Strm._ bit\n#pragma HLS interface ap_fifo port = CarryIn_Strm._peek\n#pragma HLS aggregate variable = CarryIn_Strm._peek bit\nvoid(CarryIn_Strm._.empty());\nvoid(CarryIn_Strm._peek.empty());\n\n#pragma HLS disaggregate variable = dataOut_Strm\n#pragma HLS interface ap_fifo port = dataOut_Strm._\n#pragma HLS aggregate variable = dataOut_Strm._ bit\nvoid(dataOut_Strm._.full());\n\n    ap_uint<AXI_WIDTH> myNums;\n    ap_uint<AXI_WIDTH> bufferWriteStrm;\n    int32_t d[PEs] = {0};\n    int32_t num[PEs] = {0};\n    int32_t cin = 0;\n    sum_deltas0:for( ; ; )\n    {\n#pragma HLS pipeline II=1\n        if(!delta_Strm.empty())\n        {\n            myNums = delta_Strm.read();\n            cin = CarryIn_Strm.read();\n            delta_read:for(int i = 0; i < PEs; i++)\n            {\n#pragma HLS unroll\n                d[i] = myNums.range(((i*32)+31),(i*32));\n            }\n            sumNum:for(int i = 0; i < PEs; i++)\n            {\n#pragma HLS UNROLL\n                // #pragma HLS BIND_OP variable=num op=add impl=dsp\n                num[i] = cin + d[i];\n            }\n            dWriter:for(int i = 0; i < PEs; i++)\n            {\n#pragma HLS UNROLL\n                bufferWriteStrm.range(((i*32)+31),(i*32)) = num[i];\n            }\n            dataOut_Strm.write(bufferWriteStrm);\n        }\n    }\n}\nvoid delta_Fsum(tapa::istreams<_512b, 4>& delta_Strm,\n                tapa::istreams<uint32_t, 4>& meta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostreams<_512b, 4>& dataOut_Strm\n                )\n;\nvoid Data_Aligner(tapa::istream<uint8_t>& inTrackStrm,\n                tapa::istreams<_512b, 4>& inDEStrm,\n                tapa::istreams<_512b, 4>& inDIStrm,\n                tapa::istreams<_512b, 4>& inPAStrm,\n                tapa::istream<_320b>& inSRStrm,\n                tapa::ostreams<_512b, 4>& outWRStrm )\n;\nvoid store_all(tapa::istreams<_512b, 4>& inAllStrm,\n            tapa::istream<bool>& rst_StrmL,\n            // tapa::istream<uint32_t>& dataCnt_strm,\n            uint64_t OUT0_32b_8b,\n            uint64_t OUT1_16b_8b,\n            uint64_t OUT2_16b_8b,\n            uint64_t OUT3_8b)\n;\nvoid data_decoding(uint64_t  input_port,\n                    uint64_t  output_port0_32b_8b,\n                    uint64_t  output_port1_16b_8b,\n                    uint64_t  output_port2_16b_8b,\n                    uint64_t  output_port3_8b,\n                    uint64_t  output_port4_Track,\n                    uint32_t wait_count,\n                    uint32_t data_count)\n;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "delta_sum_1out": {
            "code": "\n\n\n #include <cstdint>\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <iostream>\n\n#include <fstream>\n\n#include <string>\n\n#include <vector>\n\n#include <algorithm>\n\n#include <inttypes.h>\n\n\n #include \"ap_int.h\"\n\n#include <tapa.h>\n\n// const uint32_t dataWR_Cnt = 934640;\n// const uint32_t metaWR_Cnt = 934640;  //2147483647;\nconst uint8_t SR = 0;\nconst uint8_t DIRECT = 1;\nconst uint8_t PATCHED = 2;\nconst uint8_t DELTA = 3;\nconst uint8_t HEADER_ST = 7;\nconst uint8_t SR_STATE = 0; // 0 from 8\nconst uint8_t DI_STATE = 1; // 1 from 5\nconst uint8_t PA_STATE = 2; // 2 from 7\nconst uint8_t DE_STATE = 3; // 3 from 2\nconst uint8_t ASSIGN_DATA = 4;\nconst uint8_t PA_META_PROC = 5;\nconst uint8_t TR_HEADER = 6;\nconst uint8_t HD_PROC = 8;\nconst uint8_t waste_cycles = 9;\nconst uint16_t AXI_WIDTH_2X = 1024;\nconst uint16_t AXI_WIDTH_4X = 2048;\nconst uint16_t AXI_WIDTH = 512;\nconst uint16_t SR_DATAW = 320;\nconst uint16_t AXI_WIDTH_H = 256;\nconst uint16_t AXI_WIDTH_HH = 128;\ntypedef ap_uint<AXI_WIDTH_4X> _2048b;\ntypedef ap_uint<AXI_WIDTH_2X> _1024b;\ntypedef ap_uint<AXI_WIDTH> _512b;\ntypedef ap_int<AXI_WIDTH> _512bi;\ntypedef ap_uint<SR_DATAW> _320b;\ntypedef ap_uint<AXI_WIDTH_H> _256b;\ntypedef ap_uint<AXI_WIDTH_HH> _128b;\nconst uint16_t PEs = 16;\n// Map to bit width value.\n// const uint16_t NDelta_BitMap[32] = {1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n// const uint16_t Delta_BitMap[32] = {0,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n\nvoid mmap2s(uint64_t  input_port,\n            tapa::ostream<_512b>& outLstrm,\n            tapa::ostream<bool>& rstStrmL,\n            tapa::ostream<bool>& rstStrmMeta,\n            tapa::ostream<bool>& rstStrmStore,\n            uint32_t wait_count,\n            uint32_t data_count)\n;\nvoid load(tapa::istream<_512b>& data_in,\n            tapa::istream<bool>& rstStrm,\n            tapa::ostream<_2048b>& outAll_Lstrm,\n            tapa::ostream<_256b> &out_strmC_Track,\n            tapa::ostream<_512b>& PA_DATA,\n            tapa::ostream<uint32_t>& PA_metaDATA\n            // tapa::ostream<uint32_t>& paCnt_strm\n            // uint32_t KRNL_Data_Write\n            // uint32_t data_count\n                 )\n;\nvoid data_Sender(tapa::istream<_2048b>& data_in,\n                tapa::istream<_256b>& meta_in,\n                // tapa::istream<bool> & rst_Strm,\n                tapa::ostreams<_512b,4>& outAll_Pstrm,\n                tapa::ostream<uint64_t>& outSR_Pstrm,\n                tapa::ostreams<_256b, 4>& meta_out,\n                tapa::ostream<uint8_t>& SR_meta_out,\n                tapa::ostream<uint64_t>& All_meta_out,\n                tapa::ostream<uint8_t>& Dec_type_Out\n                // tapa::ostream<uint32_t>& data_Cnt,\n                // tapa::ostream<uint32_t>& pa_Cnt\n                )\n;\nvoid compSR(tapa::istream<uint64_t>& outSR_Pstrm,\n            tapa::istream<uint8_t>& meta_out,\n            tapa::ostream<_320b>& SR_Dout)\n;\nvoid compute_delta(tapa::istream<_512b>& in_Cstrm,\n                tapa::istream<_256b>& in_Trstrm,\n                tapa::ostream<uint32_t>& out_Cmeta_strm,\n                tapa::ostream<_512b>& out_Cstrm,\n                tapa::ostream<_512b>& DI_strm,\n                tapa::ostream<_512b>& PA_strm,\n                tapa::ostream<uint32_t>& PA_meta_strm,\n                uint32_t compD_ID)\n;\nvoid PA_meta_proc(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_meta_Strm,\n                tapa::ostream<uint64_t>& metaOutPA_Strm) //PLL, IDX, VAL\n;\nvoid PA_sum_out(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_BV_Strm,\n                tapa::ostream<_512b>& dataOutPA_Strm\n                )\n;\nvoid Meta_Aligner(tapa::istream<uint64_t>& PA_metaStrm,\n                tapa::istream<uint64_t>& All_meta_Strm,\n                tapa::ostream<_128b>& meta_Out\n                )\n;\nvoid Meta_Writer(tapa::istream<_128b>& PA_metaStrm,\n                tapa::istream<bool>& rst_StrmDS,\n                // tapa::istream<uint32_t>& complete_count,\n                uint64_t  metaPort_Out\n                // uint32_t KRNL_Data_Write\n                )\n;\nvoid delta_sumNC_in(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                // ,uint32_t ID\n                )\n;\nvoid delta_sumNC_all(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_sum_2out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm1\n                )\n;\nvoid delta_sum_1out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                )\n{\n#pragma HLS disaggregate variable = delta_Strm\n#pragma HLS interface ap_fifo port = delta_Strm._\n#pragma HLS aggregate variable = delta_Strm._ bit\n#pragma HLS interface ap_fifo port = delta_Strm._peek\n#pragma HLS aggregate variable = delta_Strm._peek bit\nvoid(delta_Strm._.empty());\nvoid(delta_Strm._peek.empty());\n\n#pragma HLS disaggregate variable = CarryIn_Strm\n#pragma HLS interface ap_fifo port = CarryIn_Strm._\n#pragma HLS aggregate variable = CarryIn_Strm._ bit\n#pragma HLS interface ap_fifo port = CarryIn_Strm._peek\n#pragma HLS aggregate variable = CarryIn_Strm._peek bit\nvoid(CarryIn_Strm._.empty());\nvoid(CarryIn_Strm._peek.empty());\n\n#pragma HLS disaggregate variable = dataOut_Strm\n#pragma HLS interface ap_fifo port = dataOut_Strm._\n#pragma HLS aggregate variable = dataOut_Strm._ bit\nvoid(dataOut_Strm._.full());\n\n#pragma HLS disaggregate variable = CarryOut_Strm\n#pragma HLS interface ap_fifo port = CarryOut_Strm._\n#pragma HLS aggregate variable = CarryOut_Strm._ bit\nvoid(CarryOut_Strm._.full());\n\n    ap_uint<AXI_WIDTH> myNums;\n    ap_uint<AXI_WIDTH> bufferWriteStrm;\n    int32_t d[PEs] = {0};\n    int32_t num[PEs] = {0};\n    int32_t cin = 0;\n    sum_deltas0:for( ; ; )\n    {\n#pragma HLS pipeline II=1\n        if(!delta_Strm.empty())\n        {\n            myNums = delta_Strm.read();\n            cin = CarryIn_Strm.read();\n            delta_read:for(int i = 0; i < PEs; i++)\n            {\n#pragma HLS unroll\n                d[i] = myNums.range(((i*32)+31),(i*32));\n            }\n            sumNum:for(int i = 0; i < PEs; i++)\n            {\n#pragma HLS UNROLL\n                // #pragma HLS BIND_OP variable=num op=add impl=dsp\n                num[i] = cin + d[i];\n            }\n            CarryOut_Strm.write(num[15]);\n            dWriter:for(int i = 0; i < PEs; i++)\n            {\n#pragma HLS UNROLL\n                bufferWriteStrm.range(((i*32)+31),(i*32)) = num[i];\n            }\n            dataOut_Strm.write(bufferWriteStrm);\n        }\n    }\n}\nvoid delta_sum_0out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_Fsum(tapa::istreams<_512b, 4>& delta_Strm,\n                tapa::istreams<uint32_t, 4>& meta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostreams<_512b, 4>& dataOut_Strm\n                )\n;\nvoid Data_Aligner(tapa::istream<uint8_t>& inTrackStrm,\n                tapa::istreams<_512b, 4>& inDEStrm,\n                tapa::istreams<_512b, 4>& inDIStrm,\n                tapa::istreams<_512b, 4>& inPAStrm,\n                tapa::istream<_320b>& inSRStrm,\n                tapa::ostreams<_512b, 4>& outWRStrm )\n;\nvoid store_all(tapa::istreams<_512b, 4>& inAllStrm,\n            tapa::istream<bool>& rst_StrmL,\n            // tapa::istream<uint32_t>& dataCnt_strm,\n            uint64_t OUT0_32b_8b,\n            uint64_t OUT1_16b_8b,\n            uint64_t OUT2_16b_8b,\n            uint64_t OUT3_8b)\n;\nvoid data_decoding(uint64_t  input_port,\n                    uint64_t  output_port0_32b_8b,\n                    uint64_t  output_port1_16b_8b,\n                    uint64_t  output_port2_16b_8b,\n                    uint64_t  output_port3_8b,\n                    uint64_t  output_port4_Track,\n                    uint32_t wait_count,\n                    uint32_t data_count)\n;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "delta_sum_2out": {
            "code": "\n\n\n #include <cstdint>\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <iostream>\n\n#include <fstream>\n\n#include <string>\n\n#include <vector>\n\n#include <algorithm>\n\n#include <inttypes.h>\n\n\n #include \"ap_int.h\"\n\n#include <tapa.h>\n\n// const uint32_t dataWR_Cnt = 934640;\n// const uint32_t metaWR_Cnt = 934640;  //2147483647;\nconst uint8_t SR = 0;\nconst uint8_t DIRECT = 1;\nconst uint8_t PATCHED = 2;\nconst uint8_t DELTA = 3;\nconst uint8_t HEADER_ST = 7;\nconst uint8_t SR_STATE = 0; // 0 from 8\nconst uint8_t DI_STATE = 1; // 1 from 5\nconst uint8_t PA_STATE = 2; // 2 from 7\nconst uint8_t DE_STATE = 3; // 3 from 2\nconst uint8_t ASSIGN_DATA = 4;\nconst uint8_t PA_META_PROC = 5;\nconst uint8_t TR_HEADER = 6;\nconst uint8_t HD_PROC = 8;\nconst uint8_t waste_cycles = 9;\nconst uint16_t AXI_WIDTH_2X = 1024;\nconst uint16_t AXI_WIDTH_4X = 2048;\nconst uint16_t AXI_WIDTH = 512;\nconst uint16_t SR_DATAW = 320;\nconst uint16_t AXI_WIDTH_H = 256;\nconst uint16_t AXI_WIDTH_HH = 128;\ntypedef ap_uint<AXI_WIDTH_4X> _2048b;\ntypedef ap_uint<AXI_WIDTH_2X> _1024b;\ntypedef ap_uint<AXI_WIDTH> _512b;\ntypedef ap_int<AXI_WIDTH> _512bi;\ntypedef ap_uint<SR_DATAW> _320b;\ntypedef ap_uint<AXI_WIDTH_H> _256b;\ntypedef ap_uint<AXI_WIDTH_HH> _128b;\nconst uint16_t PEs = 16;\n// Map to bit width value.\n// const uint16_t NDelta_BitMap[32] = {1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n// const uint16_t Delta_BitMap[32] = {0,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n\nvoid mmap2s(uint64_t  input_port,\n            tapa::ostream<_512b>& outLstrm,\n            tapa::ostream<bool>& rstStrmL,\n            tapa::ostream<bool>& rstStrmMeta,\n            tapa::ostream<bool>& rstStrmStore,\n            uint32_t wait_count,\n            uint32_t data_count)\n;\nvoid load(tapa::istream<_512b>& data_in,\n            tapa::istream<bool>& rstStrm,\n            tapa::ostream<_2048b>& outAll_Lstrm,\n            tapa::ostream<_256b> &out_strmC_Track,\n            tapa::ostream<_512b>& PA_DATA,\n            tapa::ostream<uint32_t>& PA_metaDATA\n            // tapa::ostream<uint32_t>& paCnt_strm\n            // uint32_t KRNL_Data_Write\n            // uint32_t data_count\n                 )\n;\nvoid data_Sender(tapa::istream<_2048b>& data_in,\n                tapa::istream<_256b>& meta_in,\n                // tapa::istream<bool> & rst_Strm,\n                tapa::ostreams<_512b,4>& outAll_Pstrm,\n                tapa::ostream<uint64_t>& outSR_Pstrm,\n                tapa::ostreams<_256b, 4>& meta_out,\n                tapa::ostream<uint8_t>& SR_meta_out,\n                tapa::ostream<uint64_t>& All_meta_out,\n                tapa::ostream<uint8_t>& Dec_type_Out\n                // tapa::ostream<uint32_t>& data_Cnt,\n                // tapa::ostream<uint32_t>& pa_Cnt\n                )\n;\nvoid compSR(tapa::istream<uint64_t>& outSR_Pstrm,\n            tapa::istream<uint8_t>& meta_out,\n            tapa::ostream<_320b>& SR_Dout)\n;\nvoid compute_delta(tapa::istream<_512b>& in_Cstrm,\n                tapa::istream<_256b>& in_Trstrm,\n                tapa::ostream<uint32_t>& out_Cmeta_strm,\n                tapa::ostream<_512b>& out_Cstrm,\n                tapa::ostream<_512b>& DI_strm,\n                tapa::ostream<_512b>& PA_strm,\n                tapa::ostream<uint32_t>& PA_meta_strm,\n                uint32_t compD_ID)\n;\nvoid PA_meta_proc(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_meta_Strm,\n                tapa::ostream<uint64_t>& metaOutPA_Strm) //PLL, IDX, VAL\n;\nvoid PA_sum_out(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_BV_Strm,\n                tapa::ostream<_512b>& dataOutPA_Strm\n                )\n;\nvoid Meta_Aligner(tapa::istream<uint64_t>& PA_metaStrm,\n                tapa::istream<uint64_t>& All_meta_Strm,\n                tapa::ostream<_128b>& meta_Out\n                )\n;\nvoid Meta_Writer(tapa::istream<_128b>& PA_metaStrm,\n                tapa::istream<bool>& rst_StrmDS,\n                // tapa::istream<uint32_t>& complete_count,\n                uint64_t  metaPort_Out\n                // uint32_t KRNL_Data_Write\n                )\n;\nvoid delta_sumNC_in(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                // ,uint32_t ID\n                )\n;\nvoid delta_sumNC_all(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_sum_2out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm1\n                )\n{\n#pragma HLS disaggregate variable = delta_Strm\n#pragma HLS interface ap_fifo port = delta_Strm._\n#pragma HLS aggregate variable = delta_Strm._ bit\n#pragma HLS interface ap_fifo port = delta_Strm._peek\n#pragma HLS aggregate variable = delta_Strm._peek bit\nvoid(delta_Strm._.empty());\nvoid(delta_Strm._peek.empty());\n\n#pragma HLS disaggregate variable = CarryIn_Strm\n#pragma HLS interface ap_fifo port = CarryIn_Strm._\n#pragma HLS aggregate variable = CarryIn_Strm._ bit\n#pragma HLS interface ap_fifo port = CarryIn_Strm._peek\n#pragma HLS aggregate variable = CarryIn_Strm._peek bit\nvoid(CarryIn_Strm._.empty());\nvoid(CarryIn_Strm._peek.empty());\n\n#pragma HLS disaggregate variable = dataOut_Strm\n#pragma HLS interface ap_fifo port = dataOut_Strm._\n#pragma HLS aggregate variable = dataOut_Strm._ bit\nvoid(dataOut_Strm._.full());\n\n#pragma HLS disaggregate variable = CarryOut_Strm\n#pragma HLS interface ap_fifo port = CarryOut_Strm._\n#pragma HLS aggregate variable = CarryOut_Strm._ bit\nvoid(CarryOut_Strm._.full());\n\n#pragma HLS disaggregate variable = CarryOut_Strm1\n#pragma HLS interface ap_fifo port = CarryOut_Strm1._\n#pragma HLS aggregate variable = CarryOut_Strm1._ bit\nvoid(CarryOut_Strm1._.full());\n\n    ap_uint<AXI_WIDTH> myNums;\n    ap_uint<AXI_WIDTH> bufferWriteStrm;\n    int32_t d[PEs] = {0};\n    int32_t num[PEs] = {0};\n    int32_t cin = 0;\n    sum_deltas0:for( ; ; )\n    {\n#pragma HLS pipeline II=1\n        if(!delta_Strm.empty())\n        {\n            myNums = delta_Strm.read();\n            cin = CarryIn_Strm.read();\n            delta_read:for(int i = 0; i < PEs; i++)\n            {\n#pragma HLS unroll\n                d[i] = myNums.range(((i*32)+31),(i*32));\n            }\n            sumNum:for(int i = 0; i < PEs; i++)\n            {\n#pragma HLS UNROLL\n                // #pragma HLS BIND_OP variable=num op=add impl=dsp\n                num[i] = cin + d[i];\n            }\n            CarryOut_Strm.write(num[15]);\n            CarryOut_Strm1.write(num[15]);\n            dWriter:for(int i = 0; i < PEs; i++)\n            {\n#pragma HLS UNROLL\n                bufferWriteStrm.range(((i*32)+31),(i*32)) = num[i];\n            }\n            dataOut_Strm.write(bufferWriteStrm);\n        }\n    }\n}\nvoid delta_sum_1out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                )\n;\nvoid delta_sum_0out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_Fsum(tapa::istreams<_512b, 4>& delta_Strm,\n                tapa::istreams<uint32_t, 4>& meta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostreams<_512b, 4>& dataOut_Strm\n                )\n;\nvoid Data_Aligner(tapa::istream<uint8_t>& inTrackStrm,\n                tapa::istreams<_512b, 4>& inDEStrm,\n                tapa::istreams<_512b, 4>& inDIStrm,\n                tapa::istreams<_512b, 4>& inPAStrm,\n                tapa::istream<_320b>& inSRStrm,\n                tapa::ostreams<_512b, 4>& outWRStrm )\n;\nvoid store_all(tapa::istreams<_512b, 4>& inAllStrm,\n            tapa::istream<bool>& rst_StrmL,\n            // tapa::istream<uint32_t>& dataCnt_strm,\n            uint64_t OUT0_32b_8b,\n            uint64_t OUT1_16b_8b,\n            uint64_t OUT2_16b_8b,\n            uint64_t OUT3_8b)\n;\nvoid data_decoding(uint64_t  input_port,\n                    uint64_t  output_port0_32b_8b,\n                    uint64_t  output_port1_16b_8b,\n                    uint64_t  output_port2_16b_8b,\n                    uint64_t  output_port3_8b,\n                    uint64_t  output_port4_Track,\n                    uint32_t wait_count,\n                    uint32_t data_count)\n;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "load": {
            "code": "\n\n\n #include <cstdint>\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <iostream>\n\n#include <fstream>\n\n#include <string>\n\n#include <vector>\n\n#include <algorithm>\n\n#include <inttypes.h>\n\n\n #include \"ap_int.h\"\n\n#include <tapa.h>\n\n// const uint32_t dataWR_Cnt = 934640;\n// const uint32_t metaWR_Cnt = 934640;  //2147483647;\nconst uint8_t SR = 0;\nconst uint8_t DIRECT = 1;\nconst uint8_t PATCHED = 2;\nconst uint8_t DELTA = 3;\nconst uint8_t HEADER_ST = 7;\nconst uint8_t SR_STATE = 0; // 0 from 8\nconst uint8_t DI_STATE = 1; // 1 from 5\nconst uint8_t PA_STATE = 2; // 2 from 7\nconst uint8_t DE_STATE = 3; // 3 from 2\nconst uint8_t ASSIGN_DATA = 4;\nconst uint8_t PA_META_PROC = 5;\nconst uint8_t TR_HEADER = 6;\nconst uint8_t HD_PROC = 8;\nconst uint8_t waste_cycles = 9;\nconst uint16_t AXI_WIDTH_2X = 1024;\nconst uint16_t AXI_WIDTH_4X = 2048;\nconst uint16_t AXI_WIDTH = 512;\nconst uint16_t SR_DATAW = 320;\nconst uint16_t AXI_WIDTH_H = 256;\nconst uint16_t AXI_WIDTH_HH = 128;\ntypedef ap_uint<AXI_WIDTH_4X> _2048b;\ntypedef ap_uint<AXI_WIDTH_2X> _1024b;\ntypedef ap_uint<AXI_WIDTH> _512b;\ntypedef ap_int<AXI_WIDTH> _512bi;\ntypedef ap_uint<SR_DATAW> _320b;\ntypedef ap_uint<AXI_WIDTH_H> _256b;\ntypedef ap_uint<AXI_WIDTH_HH> _128b;\nconst uint16_t PEs = 16;\n// Map to bit width value.\n// const uint16_t NDelta_BitMap[32] = {1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n// const uint16_t Delta_BitMap[32] = {0,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n\nvoid mmap2s(uint64_t  input_port,\n            tapa::ostream<_512b>& outLstrm,\n            tapa::ostream<bool>& rstStrmL,\n            tapa::ostream<bool>& rstStrmMeta,\n            tapa::ostream<bool>& rstStrmStore,\n            uint32_t wait_count,\n            uint32_t data_count)\n;\nvoid load(tapa::istream<_512b>& data_in,\n            tapa::istream<bool>& rstStrm,\n            tapa::ostream<_2048b>& outAll_Lstrm,\n            tapa::ostream<_256b> &out_strmC_Track,\n            tapa::ostream<_512b>& PA_DATA,\n            tapa::ostream<uint32_t>& PA_metaDATA\n            // tapa::ostream<uint32_t>& paCnt_strm\n            // uint32_t KRNL_Data_Write\n            // uint32_t data_count\n                 )\n{\n#pragma HLS disaggregate variable = data_in\n#pragma HLS interface ap_fifo port = data_in._\n#pragma HLS aggregate variable = data_in._ bit\n#pragma HLS interface ap_fifo port = data_in._peek\n#pragma HLS aggregate variable = data_in._peek bit\nvoid(data_in._.empty());\nvoid(data_in._peek.empty());\n\n#pragma HLS disaggregate variable = rstStrm\n#pragma HLS interface ap_fifo port = rstStrm._\n#pragma HLS aggregate variable = rstStrm._ bit\n#pragma HLS interface ap_fifo port = rstStrm._peek\n#pragma HLS aggregate variable = rstStrm._peek bit\nvoid(rstStrm._.empty());\nvoid(rstStrm._peek.empty());\n\n#pragma HLS disaggregate variable = outAll_Lstrm\n#pragma HLS interface ap_fifo port = outAll_Lstrm._\n#pragma HLS aggregate variable = outAll_Lstrm._ bit\nvoid(outAll_Lstrm._.full());\n\n#pragma HLS disaggregate variable = out_strmC_Track\n#pragma HLS interface ap_fifo port = out_strmC_Track._\n#pragma HLS aggregate variable = out_strmC_Track._ bit\nvoid(out_strmC_Track._.full());\n\n#pragma HLS disaggregate variable = PA_DATA\n#pragma HLS interface ap_fifo port = PA_DATA._\n#pragma HLS aggregate variable = PA_DATA._ bit\nvoid(PA_DATA._.full());\n\n#pragma HLS disaggregate variable = PA_metaDATA\n#pragma HLS interface ap_fifo port = PA_metaDATA._\n#pragma HLS aggregate variable = PA_metaDATA._ bit\nvoid(PA_metaDATA._.full());\n\n    ap_uint<AXI_WIDTH> b1 = 0; //Pipeline Depth of 7\n    ap_uint<3584> b2 = 0;\n    ap_uint<AXI_WIDTH> b3 = 0; //Just reducing the bitwidth of b2 by 512.\n    ap_uint<1536> headerProc = 0;\n    // ap_uint<1024> mheaderProc = 0;\n    ap_uint<8> dec_type = 0;\n    ap_uint<8> Datadec_type = 0;\n    uint8_t bitSize = 1;\n    uint32_t runLength = 0;\n    uint32_t SEC_SHIFTER = 0;\n    uint32_t FIRST_SHIFTER = 0;\n    int32_t mFIRST_SHIFTER = 0;\n    // uint16_t hd_off = 0;\n    uint16_t DS_SDS = 0;\n    uint8_t st_count = 0;\n    uint8_t mHD_READ_OFF = 0;\n    uint8_t HD_READ_OFF = 0;\n    uint8_t mbitSize = 1;\n    uint16_t mrunLength = 0;\n    uint16_t SRrunLength = 0;\n    uint32_t mSEC_SHIFTER = 0;\n    ap_uint<3584> dSEND = 0; //Need atleast 80 bits more than 2048\n    _256b TrackSEND = 0;\n    bool first_time = 0;\n    bool mfirst_time = 0;\n    bool check_header_wait = 0;\n    // bool shiftFlag = true;\n    // bool mshiftFlag = false;\n    // bool last_cycle = false;\n    // uint16_t tr_count = 0;\n    uint32_t shift_count = 0;\n    uint32_t myShift = 0;\n    uint32_t HD_COUNTS = 0;\n    uint32_t T_SHIFTs = 16384;\n    uint16_t d_loop = 0;\n    uint16_t SDS = 0; //second_data_sender\n    uint16_t FDS = 0; //First_data_sender\n    uint8_t state = HEADER_ST;\n    uint32_t myCount = 0;\n    uint8_t fbo = 0;\n    // uint32_t data_iter = 0;\n    uint32_t buf_header = 0;\n    // uint32_t data_counter = 0;\n    uint8_t start_proc = 0;\n    bool wait_adjust = 0;\n    bool wait_cycles = 0;\n    uint8_t wait_idx = 0;\n    uint8_t wait_count = 0;\n    bool bsf = 0;\n    bool start_cycle = 0;\n    uint8_t APPEND_DATA_SHIFTER = 0;\n    uint8_t mAPPEND_DATA_SHIFTER = 0;\n    // bool bit24head_FLG = 0;\n    //Delta Decoder\n    int32_t temp_val = 0;\n    uint16_t tmpBS_DE = 0;\n    uint8_t BV_idx = 0;\n    ap_uint<64> rd_bytes[10] = {0};\n    ap_uint<64> reg_data_0 = 0;\n    ap_uint<64> reg_data_1 = 0;\n    ap_uint<64> reg_data_2 = 0;\n    ap_uint<64> reg_data_3 = 0;\n    ap_uint<64> reg_data_4 = 0;\n    uint32_t base_value = 0;\n    uint32_t mbase_value = 0;\n    uint8_t DB_idx = 0;\n    uint32_t delta_base = 0;\n    uint32_t mdelta_base = 0;\n    uint8_t BV_S1 = 0;\n    uint8_t BV_S2 = 0;\n    uint8_t BV_S3 = 0;\n    uint8_t BV_S4 = 0;\n    uint8_t DB_S1 = 0;\n    uint8_t DB_S2 = 0;\n    uint8_t DB_S3 = 0;\n    uint8_t DB_S4 = 0;\n    uint32_t my_bv_val = 0;\n    // bool data_incoming = 0;\n    //Patched Decoder\n    ap_uint<1536> Patch_Data_Proc = 0;\n    uint8_t BV_Width = 0;\n    uint8_t BV_Bits = 0;\n    uint8_t PGW = 0;\n    uint8_t PW = 0;\n    uint8_t PLL = 0;\n    uint64_t BV_mask = 0;\n    uint8_t CLBW = 0;\n    ap_uint<32> BV_PA = 0;\n    int32_t BV_VAL_PA = 0;\n    uint32_t patch_shifter = 0;\n    uint8_t hd_waitCount = 0;\n    uint16_t rem_PatchD = 0;\n    uint16_t tr_thresh = 0;\n    uint16_t patch_data_L = 0;\n    uint8_t T_WAIT = 0;\n    uint32_t PA_metaData = 0;\n    uint32_t pa_counter = 0;\n    uint32_t start_shift = 0;\n    uint32_t patchPC_mul = 0;\n    uint8_t PA_bitShifter_8b = 0;\n    uint8_t PA_bitShifter_16b = 0;\n    uint8_t PA_bitShifter_24b = 0;\n    uint8_t PA_bitShifter_32b = 0;\n    uint8_t D_PLL = 0;\n    bool fPLL = 0;\n    bool mfPLL = 0;\n    bool temp_Rst = 0;\n    // int i_resp = 0;\n    // int My_Cntr = 0;\n    //Short Repeat\n    uint8_t SR_repWidth = 0;\n    // uint8_t SR_repCount = 0;\n    const uint16_t NDelta_BitMap[32] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\n                                12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n                                23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n    const uint8_t ClosestFixedBitsMap[65] = {\n      1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,\n      22, 23, 24, 26, 26, 28, 28, 30, 30, 32, 32, 40, 40, 40, 40, 40, 40, 40, 40, 48, 48, 48,\n      48, 48, 48, 48, 48, 56, 56, 56, 56, 56, 56, 56, 56, 64, 64, 64, 64, 64, 64, 64, 64};\n    // #pragma HLS bind_storage variable=NDelta_BitMap type=ROM_2P impl=bram\n    // #pragma HLS bind_storage variable=ClosestFixedBitsMap type=ROM_1P impl=bram\n#pragma HLS ARRAY_PARTITION variable=rd_bytes complete dim=0\n#pragma HLS BIND_OP variable=myCount op=mul impl=dsp latency=3\n#pragma HLS BIND_OP variable=patchPC_mul op=mul impl=dsp latency=1\n    LOAD_LOOP:for( ;; ) //7*64 (Pipeline Depth)*64...8*64=512\n    {\n#pragma HLS pipeline II=1\n        if(!rstStrm.empty())\n        {\n            temp_Rst = rstStrm.read();\n            b2 = 0; headerProc = 0; SRrunLength = 0; T_SHIFTs = 16384; //512=64*8\n            mbitSize = 1; bitSize = 1; hd_waitCount = 0; myShift = 0;\n            start_cycle = 0; wait_cycles = 0; start_proc = 0; dec_type = 0;\n            d_loop = 0; runLength = 0; start_shift = 0; state = HEADER_ST;\n            pa_counter = 0; HD_READ_OFF = 0; mSEC_SHIFTER = 0; wait_count = 0;\n            wait_idx = 0; mAPPEND_DATA_SHIFTER = 0; st_count = 0; myCount = 0;\n        }\n        else if(!data_in.empty())\n        {\n            //starting next batch waste cycle \n            if(wait_cycles == 1)\n            {\n                if(wait_idx == (wait_count))\n                {\n                    wait_idx = 0;\n                    // extra_waits = 0;\n                    wait_count = 0;\n                    wait_cycles = 0;\n                }\n                else\n                {\n                    wait_idx += 1;\n                }\n            }\n            else\n            {\n                if((d_loop < runLength)) //Last 512bits may or may not have data\n                {\n                    dSEND = 0;\n                    dSEND = (b2 << 512) | b3;\n                    //SEND DATA COUNT\n                    // uint16_t sum = (bitSize == 0) ? 512:64;\n                    d_loop = d_loop + 64;\n                    if(bitSize == 16)\n                    {\n                        wait_cycles = 1 - wait_adjust;\n                        // wait_count = 0; // wait 1 cycle\n                    }\n                    else if(bitSize == 24)\n                    {\n                        wait_cycles = 1;\n                        wait_count = 1 - wait_adjust; // wait 2 cycle\n                    }\n                    else if(bitSize == 32) // bitSize == 32\n                    {\n                        wait_cycles = 1;\n                        wait_count = 2 - wait_adjust; // wait 3 cycle\n                    }\n                    TrackSEND = 0;\n                    bsf = first_time;\n                    if(fPLL)\n                    {\n                        fPLL = 0;\n                        TrackSEND.range(255,224) = D_PLL;\n                    }\n                    else\n                    {\n                        TrackSEND.range(255,224) = 0;\n                    }\n                    TrackSEND.range(223,192) = DS_SDS;\n                    TrackSEND.range(191,160) = delta_base;\n                    TrackSEND.range(159,128) = base_value;\n                    TrackSEND.range(127,96) = bsf;\n                    TrackSEND.range(95,64) = runLength;\n                    TrackSEND.range(63,32) = Datadec_type;\n                    TrackSEND.range(31,0) = bitSize;\n                    //SEND METADATA\n                    //Data (BITSIZE, DecType, runLength, BSF, BV, DB)         \n                    out_strmC_Track.write(TrackSEND);\n                    //SEND DATA\n                    if(first_time)\n                    {\n                        first_time = 0;\n                        wait_adjust = 0;\n                        dSEND = dSEND >> FIRST_SHIFTER;\n                        if(APPEND_DATA_SHIFTER == 1)\n                        {\n                            buf_header = dSEND.range(511,504);\n                        }\n                        else\n                        {\n                            buf_header = 0;\n                        }\n                        if(Datadec_type == SR)\n                        {\n                            outAll_Lstrm.write(dSEND.range((bitSize-1)+512,512)); //offset 512 bcz data is not in b3\n                        }\n                        else\n                        {\n                            if(bitSize != 0)\n                            {\n                                outAll_Lstrm.write(dSEND.range(FDS,0)); //replace_F_SDS\n                            }\n                            else\n                            {\n                                outAll_Lstrm.write((runLength-64));\n                            }\n                        }\n                    }\n                    else\n                    {\n                        if(APPEND_DATA_SHIFTER == 1)\n                        {\n                            dSEND = (dSEND << 8) | buf_header;\n                            buf_header = dSEND.range(519,512);\n                        }\n                        else\n                        {\n                            dSEND = dSEND >> SEC_SHIFTER;\n                        }\n                        outAll_Lstrm.write(dSEND.range(SDS,0));\n                    }\n                }\n            }\n            if(start_proc == 3)\n            {\n                start_cycle = 1;\n            }\n            else\n            {\n                start_proc += 1;\n            }\n            //Header Processing\n            if(start_cycle)\n            {\n                if(state == HEADER_ST)\n                {\n                    //can be replaced with a next_state variable\n                    if(dec_type == PATCHED)\n                    {\n                        state = PA_META_PROC;\n                    }\n                    else\n                    {\n                        state = HD_PROC;\n                    }\n                    if(HD_READ_OFF == 0)\n                    {\n                        headerProc = b2.range(3583,2560); //normal\n                    }\n                    else if(HD_READ_OFF == 1)\n                    {\n                        headerProc = b2.range(3575,2552); //get extra 8bits\n                    }\n                    else\n                    {\n                        headerProc = b2.range(1023,0); //bs==0 or short rep\n                    }\n                    headerProc = headerProc >> mSEC_SHIFTER;\n                    check_header_wait = 0;\n                    mHD_READ_OFF = 0; //reset it\n                    st_count = 0;\n                }\n                else if(state == PA_META_PROC)\n                {\n                    uint32_t m_pa_shifter = 0;\n                    //Currently Only works for 512 bit of Patch meta data\n                    if(hd_waitCount >= T_WAIT) //Only if patches data exceed 512\n                    {\n                        state = HD_PROC;\n                        hd_waitCount = 0;\n                        // pa_counter = PLL;                              //For MetaWrite port\n                        PA_metaData = PLL; //To Complete the Data count\n                        PA_metaData = (PA_metaData << 8) | bitSize; //required to Patch Value\n                        PA_metaData = (PA_metaData << 8) | PW; //required to get the GAP value\n                        PA_metaData = (PA_metaData << 8) | CLBW; //required to Process the Data\n                        PA_metaDATA.write(PA_metaData);\n                        PA_DATA.write(headerProc.range(patch_data_L-1,0)); //patch_data_L should not be greater than 512\n                        // paCnt_strm.write(pa_counter);\n                        mSEC_SHIFTER = patch_shifter;\n                        if(T_WAIT > 0)\n                        {\n                            m_pa_shifter = patch_shifter;\n                            headerProc = Patch_Data_Proc;\n                        }\n                        else\n                        {\n                            m_pa_shifter = patch_data_L;\n                            headerProc = headerProc;\n                        }\n                        headerProc = headerProc >> m_pa_shifter;\n                    }\n                    else\n                    {\n                        hd_waitCount += 1;\n                        if(HD_READ_OFF == 0)\n                        {\n                            Patch_Data_Proc = b2.range(3583,2560); //get extra 8bits\n                        }\n                        else if(HD_READ_OFF == 1)\n                        {\n                            Patch_Data_Proc = b2.range(3575,2552); //get extra 8bits\n                        }\n                        else\n                        {\n                            Patch_Data_Proc = b2.range(1023,0); //get extra 8bits\n                        }\n                        state = PA_META_PROC;\n                    }\n                }\n                else if(state == HD_PROC)\n                {\n                    dec_type = (headerProc >> 6).range(1,0);\n                    patch_shifter = 0;\n                    // PLL = 0;\n                    mfPLL = 0;\n                    start_shift = 0;\n                    // mfirst_time = 1;\n                    mrunLength = (((uint16_t)(headerProc.range(0,0)) << 8) | ((uint16_t)((headerProc >> 8).range(7,0)))) + 1;\n                    SRrunLength = mrunLength;\n                    fbo = (headerProc >> 1).range(4,0);\n                    mbitSize = (fbo!=0) ? NDelta_BitMap[fbo] : 0;\n                    // myCount = (mrunLength*mbitSize);\n                    //PA\n                    PW = NDelta_BitMap[headerProc.range(20,16)];\n                    PGW = (headerProc.range(31,29)) + 1;\n                    PLL = headerProc.range(28,24);\n                    BV_Width = (headerProc.range(23,21)) + 1;\n                    state = dec_type;\n                    if(dec_type==SR)\n                    {\n                        headerProc = headerProc;\n                        mSEC_SHIFTER += 8;\n                    }\n                    else\n                    {\n                        headerProc = headerProc >> 16;\n                        mSEC_SHIFTER += 16;\n                    }\n                    BV_bytes:for(int i = 0; i < 10; i++)\n                    {\n#pragma HLS unroll\n                        rd_bytes[i] = headerProc.range((i*8)+7, (i*8));\n                    }\n                    BV_idx = ((rd_bytes[0].range(7,7)) == 0) ? 0 :\n                            ((rd_bytes[1].range(7,7)) == 0) ? 1 :\n                            ((rd_bytes[2].range(7,7)) == 0) ? 2 :\n                            ((rd_bytes[3].range(7,7)) == 0) ? 3 :\n                            ((rd_bytes[4].range(7,7)) == 0) ? 4 : 5;\n                }\n                else if(state == SR_STATE)\n                {\n                    if(SRrunLength == 1)\n                    {\n                        //final counts\n                        // state = waste_cycles;   //last cycle to waste the data\n                        myShift = 0;\n                        T_SHIFTs = 16384;\n                    }\n                    else\n                    {\n                        // state = SR_STATE;\n                        st_count += 1;\n                        if(st_count >= 3)\n                        {\n                            state = ASSIGN_DATA;\n                            st_count = 0;\n                            if(mFIRST_SHIFTER > 512)\n                            {\n                                mFIRST_SHIFTER = mFIRST_SHIFTER - 512;\n                                temp_val = mSEC_SHIFTER - 512; //to use the same last state as delta\n                                check_header_wait = 1; //it is reset at the start\n                                shift_count = mbitSize + 512;\n                            }\n                            else\n                            {\n                                temp_val = mSEC_SHIFTER;\n                                shift_count = mbitSize;\n                            }\n                        }\n                        else if(st_count == 2)\n                        {\n                            // mSEC_SHIFTER += mbitSize;\n                            start_shift = 512;\n                            // mbitSize = mbitSize << 3; //multiply by 8\n                            mAPPEND_DATA_SHIFTER = 0;\n                            mSEC_SHIFTER += mbitSize;\n                            mdelta_base = 0; //Compute delta checks this value\n                            mbase_value = 0;\n                            mHD_READ_OFF = 2; //stop\n                        }\n                        else\n                        {\n                            mfirst_time = 1; //\n                            // myCount = (mrunLength*mbitSize);\n                            mFIRST_SHIFTER = mSEC_SHIFTER;\n                            mbitSize = (headerProc.range(5,3) + 1) << 3; //Multiply 8 to get the bits\n                            mrunLength = headerProc.range(2,0) + 3; //repeat Count, min_repcount = 3\n                        }\n                    }\n                }\n                else if(state == PA_STATE)\n                {\n                    // state = PA_STATE;\n                    st_count += 1;\n                    if(st_count >= 3)\n                    {\n                        state = ASSIGN_DATA;\n                        st_count = 0;\n                        if(check_header_wait)\n                        {\n                            shift_count = myCount + 512;\n                        }\n                        else\n                        {\n                            shift_count = myCount;\n                        }\n                        if((BV_VAL_PA & BV_mask) != 0)\n                        {\n                            BV_VAL_PA = BV_VAL_PA & (~BV_mask);\n                            BV_VAL_PA = -BV_VAL_PA;\n                        }\n                        rem_PatchD = (patchPC_mul%8);\n                        // uint8_t offVal = (patch_data_L%8);\n                        if(rem_PatchD != 0)\n                        {\n                            patch_data_L = patchPC_mul + (8 - rem_PatchD);\n                        }\n                        else\n                        {\n                            patch_data_L = patchPC_mul;\n                        }\n                        patch_shifter = temp_val + patch_data_L;\n                        mAPPEND_DATA_SHIFTER = 0;\n                        mFIRST_SHIFTER = 0;\n                        mfirst_time = 0; //no need for this in PATCHED\n                        mdelta_base = 0; //Compute delta checks this value\n                        mbase_value = BV_VAL_PA; //Patch Data Base_Value\n                    }\n                    else if(st_count == 2)\n                    {\n                        // shift_count = myCount;    //read earlier to proc PA meta\n                        // CLBW = ClosestFixedBitsMap[PGW+PW];\n                        BV_mask = 1 << (BV_Bits - 1); //for neg check  BV_Bits = BV_Width*8\n                        //change endianness\n                        BV_PA = headerProc.range(BV_Bits-1, 0);\n                        BV_VAL_PA = (BV_PA.range(7,0) << PA_bitShifter_8b) | (BV_PA.range(15,8) << PA_bitShifter_16b) |\n                                    (BV_PA.range(23,16) << PA_bitShifter_24b) | (BV_PA.range(31,24) << PA_bitShifter_32b);\n                        patchPC_mul = PLL*CLBW;\n                        // patch_shifter = PLL*CLBW;\n                        mSEC_SHIFTER += BV_Bits;\n                        if(mSEC_SHIFTER > 512)\n                        {\n                            temp_val = mSEC_SHIFTER - 512; //to use the same last state as delta\n                            check_header_wait = 1; //it is reset at the start\n                        }\n                        else\n                        {\n                            temp_val = mSEC_SHIFTER;\n                        }\n                    }\n                    else //run on 1\n                    {\n                        CLBW = ClosestFixedBitsMap[PGW+PW];\n                        myCount = (mrunLength*mbitSize);\n                        BV_Bits = BV_Width << 3; //BV_Width*8\n                        // PW = NDelta_BitMap[headerProc.range(4,0)];\n                        // BV_Width = ((headerProc >> 5).range(2,0)) + 1;\n                        // PLL = (headerProc >> 8).range(4,0);\n                        // PGW = ((headerProc >> 13).range(2,0)) + 1;\n                        mfPLL = 1;\n                        mSEC_SHIFTER += 16; //4 bytes header with base value added\n                        headerProc = headerProc >> 16;\n                        PA_bitShifter_8b = BV_Bits - 8;\n                        PA_bitShifter_16b = (BV_Bits <= 8) ? 40 : (BV_Bits - 16);\n                        PA_bitShifter_24b = (BV_Bits <= 16) ? 40 : (BV_Bits - 24);\n                        PA_bitShifter_32b = (BV_Bits <= 24) ? 40 : (BV_Bits - 32);\n                    }\n                }\n                else if(state == DI_STATE)\n                {\n                    // state = DI_STATE;\n                    st_count += 1;\n                    if(st_count >= 3)\n                    {\n                        state = ASSIGN_DATA;\n                        st_count = 0;\n                        if(check_header_wait)\n                        {\n                            shift_count = myCount + 512;\n                        }\n                        else\n                        {\n                            shift_count = myCount;\n                        }\n                    }\n                    else if(st_count == 2)\n                    {\n                        // shift_count = myCount;\n                        mAPPEND_DATA_SHIFTER = 0;\n                        mFIRST_SHIFTER = 0;\n                        mfirst_time = 0; //no need for this in DIRECT\n                        mdelta_base = 0; //Compute delta checks this value\n                        mbase_value = 0;\n                    }\n                    else //run on 1\n                    {\n                        myCount = (mrunLength*mbitSize);\n                        if(mSEC_SHIFTER > 512)\n                        {\n                            temp_val = mSEC_SHIFTER - 512; //to use the same last state as delta\n                            check_header_wait = 1; //it is reset at the start\n                        }\n                        else\n                        {\n                            temp_val = mSEC_SHIFTER;\n                        }\n                    }\n                }\n                else if(state == DE_STATE)\n                {\n                    // state = DE_STATE;\n                    st_count += 1;\n                    if(st_count >= 3)\n                    {\n                        state = ASSIGN_DATA;\n                        st_count = 0;\n                        uint32_t temp_bv_db = (reg_data_0.range(6,0)) |\n                                    ((reg_data_1.range(6,0)) << DB_S1) |\n                                    ((reg_data_2.range(6,0)) << DB_S2) |\n                                    ((reg_data_3.range(6,0)) << DB_S3) |\n                                    ((reg_data_4.range(6,0)) << DB_S4);\n                        mbase_value = (my_bv_val >> 1) ^ (-(my_bv_val & 1));\n                        mdelta_base = (temp_bv_db >> 1) ^ (-(temp_bv_db & 1));\n                        // FIRST_SHIFTER %= 512;\n                        if(mFIRST_SHIFTER > 512)\n                        {\n                            mFIRST_SHIFTER = mFIRST_SHIFTER - 512;\n                            check_header_wait = 1;\n                            shift_count = myCount + 512 - tmpBS_DE;\n                        }\n                        else\n                        {\n                            shift_count = myCount - tmpBS_DE;\n                        }\n                        // myCount += check_header_wait;\n                        // #pragma HLS BIND_OP variable=temp_val op=mul impl=dsp\n                        if((mFIRST_SHIFTER == 8) && (mbitSize == 8))\n                        {\n                            temp_val = 0;\n                            mAPPEND_DATA_SHIFTER = 1; //gets reset in prev cycle\n                            mHD_READ_OFF = 1;\n                        }\n                        else if(mbitSize == 0)\n                        {\n                            temp_val = mFIRST_SHIFTER;\n                            mHD_READ_OFF = 2;\n                        }\n                        else\n                        {\n                            temp_val = mFIRST_SHIFTER - tmpBS_DE;\n                            mHD_READ_OFF = 0;\n                        }\n                        // header_bound = mheader_bound;\n                    }\n                    else if(st_count == 2)\n                    {\n                        // shift_count = myCount;\n                        mAPPEND_DATA_SHIFTER = 0;\n                        my_bv_val = (rd_bytes[0].range(6,0)) |\n                                    ((rd_bytes[1].range(6,0)) << BV_S1) |\n                                    ((rd_bytes[2].range(6,0)) << BV_S2) |\n                                    ((rd_bytes[3].range(6,0)) << BV_S3) |\n                                    ((rd_bytes[4].range(6,0)) << BV_S4);\n                        reg_data_0 = rd_bytes[BV_idx+1];\n                        reg_data_1 = rd_bytes[BV_idx+2];\n                        reg_data_2 = rd_bytes[BV_idx+3];\n                        reg_data_3 = rd_bytes[BV_idx+4];\n                        reg_data_4 = rd_bytes[BV_idx+5];\n                        // my_bv_val = bv_D[BV_idx];\n                        // S0 = (DB_idx*7);\n                        DB_S1 = (DB_idx >= 1) ? 7 : 40;\n                        DB_S2 = (DB_idx >= 2) ? 14 : 40;\n                        DB_S3 = (DB_idx >= 3) ? 21 : 40;\n                        DB_S4 = (DB_idx >= 4) ? 28 : 40;\n                        // #pragma HLS BIND_OP variable=mFIRST_SHIFTER op=add impl=dsp \n                        // #pragma HLS BIND_OP variable=mFIRST_SHIFTER op=mul impl=dsp\n                        mFIRST_SHIFTER += ((BV_idx+DB_idx+2)*8); //((BV_idx+DB_idx)*8)+16\n                    }\n                    else //run on 1\n                    {\n                        mfirst_time = 1;\n                        myCount = (mrunLength*mbitSize);\n                        tmpBS_DE = mbitSize << 1; //mbitSize*2 = mbitSize+mbitSize = mbitSize<<1\n                        // S0 = (BV_idx*7);\n                        BV_S1 = (BV_idx >= 1) ? 7 : 40;\n                        BV_S2 = (BV_idx >= 2) ? 14 : 40;\n                        BV_S3 = (BV_idx >= 3) ? 21 : 40;\n                        BV_S4 = (BV_idx >= 4) ? 28 : 40;\n                        //Get Delta Base\n                        DB_idx = ((rd_bytes[BV_idx+1].range(7,7)) == 0) ? 0 :\n                                    ((rd_bytes[BV_idx+2].range(7,7)) == 0) ? 1 :\n                                    ((rd_bytes[BV_idx+3].range(7,7)) == 0) ? 2 :\n                                    ((rd_bytes[BV_idx+4].range(7,7)) == 0) ? 3 :\n                                    ((rd_bytes[BV_idx+5].range(7,7)) == 0) ? 4 : 20;\n                        mFIRST_SHIFTER = mSEC_SHIFTER - (mAPPEND_DATA_SHIFTER*8);\n                    }\n                    //reset mAPPEND_DATA_SHIFTER = 0 in next cycle\n                }\n                else if(state == ASSIGN_DATA)\n                {\n                    state = TR_HEADER;\n                    // data_counter += mrunLength;                    \n                    d_loop = 0; //start the data sender\n                    myShift = start_shift; //reset the shifter, start it from 512. Bcz if total is less than 512 no shift\n                    if(patch_shifter > 512)\n                    {\n                        T_WAIT = 1;\n                        patch_shifter = patch_shifter - 512;\n                        T_SHIFTs = shift_count + 512;\n                    }\n                    else\n                    {\n                        T_SHIFTs = shift_count; //if you are reading header beyond 512 bits\n                        T_WAIT = 0;\n                    }\n                    if(temp_val < 0)\n                    {\n                        //\n                        HD_COUNTS = shift_count-512; //Header tracker to re-read new header, read early\n                        mSEC_SHIFTER = 512 + temp_val;\n                        wait_adjust = 1;\n                    }\n                    else\n                    {\n                        HD_COUNTS = shift_count; //Header tracker to re-read new header\n                        mSEC_SHIFTER = temp_val;\n                        wait_adjust = 0;\n                    }\n                    if(mbitSize == 8)\n                    {\n                        SDS = 511;\n                        DS_SDS = 128;\n                        FDS = 495;\n                    }\n                    else if(mbitSize == 16)\n                    {\n                        SDS = 1023;\n                        DS_SDS = 256;\n                        FDS = 991;\n                    }\n                    else if(mbitSize == 24)\n                    {\n                        SDS = 1535;\n                        DS_SDS = 384;\n                        FDS = 1487;\n                    }\n                    else if(mbitSize == 32)\n                    {\n                        SDS = 2047;\n                        DS_SDS = 512;\n                        FDS = 1983;\n                    }\n                    else //mbitSize == 0\n                    {\n                        d_loop = mrunLength - 64;\n                    }\n                    // data_counter += mrunLength;\n                    //Set these variables always in the last cycle of header Processing\n                    Datadec_type = dec_type;\n                    APPEND_DATA_SHIFTER = mAPPEND_DATA_SHIFTER;\n                    HD_READ_OFF = mHD_READ_OFF;\n                    FIRST_SHIFTER = mFIRST_SHIFTER;\n                    SEC_SHIFTER = mSEC_SHIFTER;\n                    bitSize = mbitSize;\n                    runLength = mrunLength;\n                    first_time = mfirst_time;\n                    delta_base = mdelta_base;\n                    base_value = mbase_value;\n                    fPLL = mfPLL;\n                    D_PLL = PLL;\n                    wait_cycles = check_header_wait && (mbitSize != 0);\n                }\n                else if(state == TR_HEADER)\n                {\n                    if(HD_COUNTS <= 3584)\n                    {\n                        HD_COUNTS = 0;\n                        state = HEADER_ST;\n                    }\n                    else\n                    {\n                        HD_COUNTS -= 512;\n                    }\n                }\n                // else if(state == waste_cycles)\n                // {\n                //     state = waste_cycles;\n                //     myShift = 0;\n                //     T_SHIFTs = 16384;\n                // }\n                // else\n                // {\n                //     state = waste_cycles;\n                //     #ifndef __SYNTHESIS__\n                //         // std::cout << \"Default state\" << std::endl;\n                //     #endif\n                // }\n            }\n            if(myShift < T_SHIFTs)\n            {\n                b3=b2;\n                b2= (b2 >> 512); //512 \n                b2.range(3583,3072) = b1; //Myb1_Data //Place at the MSB (2047,1536)\n                b1 = data_in.read();\n                myShift+=512;\n            }\n            // else\n            // {\n            //     #ifndef __SYNTHESIS__\n            //         // std::cout << \"RD_STOP\" << std::endl;\n            //     #endif\n            //     b3 = b3;\n            // }\n        }\n    }\n}\nvoid data_Sender(tapa::istream<_2048b>& data_in,\n                tapa::istream<_256b>& meta_in,\n                // tapa::istream<bool> & rst_Strm,\n                tapa::ostreams<_512b,4>& outAll_Pstrm,\n                tapa::ostream<uint64_t>& outSR_Pstrm,\n                tapa::ostreams<_256b, 4>& meta_out,\n                tapa::ostream<uint8_t>& SR_meta_out,\n                tapa::ostream<uint64_t>& All_meta_out,\n                tapa::ostream<uint8_t>& Dec_type_Out\n                // tapa::ostream<uint32_t>& data_Cnt,\n                // tapa::ostream<uint32_t>& pa_Cnt\n                )\n;\nvoid compSR(tapa::istream<uint64_t>& outSR_Pstrm,\n            tapa::istream<uint8_t>& meta_out,\n            tapa::ostream<_320b>& SR_Dout)\n;\nvoid compute_delta(tapa::istream<_512b>& in_Cstrm,\n                tapa::istream<_256b>& in_Trstrm,\n                tapa::ostream<uint32_t>& out_Cmeta_strm,\n                tapa::ostream<_512b>& out_Cstrm,\n                tapa::ostream<_512b>& DI_strm,\n                tapa::ostream<_512b>& PA_strm,\n                tapa::ostream<uint32_t>& PA_meta_strm,\n                uint32_t compD_ID)\n;\nvoid PA_meta_proc(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_meta_Strm,\n                tapa::ostream<uint64_t>& metaOutPA_Strm) //PLL, IDX, VAL\n;\nvoid PA_sum_out(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_BV_Strm,\n                tapa::ostream<_512b>& dataOutPA_Strm\n                )\n;\nvoid Meta_Aligner(tapa::istream<uint64_t>& PA_metaStrm,\n                tapa::istream<uint64_t>& All_meta_Strm,\n                tapa::ostream<_128b>& meta_Out\n                )\n;\nvoid Meta_Writer(tapa::istream<_128b>& PA_metaStrm,\n                tapa::istream<bool>& rst_StrmDS,\n                // tapa::istream<uint32_t>& complete_count,\n                uint64_t  metaPort_Out\n                // uint32_t KRNL_Data_Write\n                )\n;\nvoid delta_sumNC_in(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                // ,uint32_t ID\n                )\n;\nvoid delta_sumNC_all(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_sum_2out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm1\n                )\n;\nvoid delta_sum_1out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                )\n;\nvoid delta_sum_0out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_Fsum(tapa::istreams<_512b, 4>& delta_Strm,\n                tapa::istreams<uint32_t, 4>& meta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostreams<_512b, 4>& dataOut_Strm\n                )\n;\nvoid Data_Aligner(tapa::istream<uint8_t>& inTrackStrm,\n                tapa::istreams<_512b, 4>& inDEStrm,\n                tapa::istreams<_512b, 4>& inDIStrm,\n                tapa::istreams<_512b, 4>& inPAStrm,\n                tapa::istream<_320b>& inSRStrm,\n                tapa::ostreams<_512b, 4>& outWRStrm )\n;\nvoid store_all(tapa::istreams<_512b, 4>& inAllStrm,\n            tapa::istream<bool>& rst_StrmL,\n            // tapa::istream<uint32_t>& dataCnt_strm,\n            uint64_t OUT0_32b_8b,\n            uint64_t OUT1_16b_8b,\n            uint64_t OUT2_16b_8b,\n            uint64_t OUT3_8b)\n;\nvoid data_decoding(uint64_t  input_port,\n                    uint64_t  output_port0_32b_8b,\n                    uint64_t  output_port1_16b_8b,\n                    uint64_t  output_port2_16b_8b,\n                    uint64_t  output_port3_8b,\n                    uint64_t  output_port4_Track,\n                    uint32_t wait_count,\n                    uint32_t data_count)\n;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "mmap2s": {
            "code": "\n\n\n #include <cstdint>\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <iostream>\n\n#include <fstream>\n\n#include <string>\n\n#include <vector>\n\n#include <algorithm>\n\n#include <inttypes.h>\n\n\n #include \"ap_int.h\"\n\n#include <tapa.h>\n\n// const uint32_t dataWR_Cnt = 934640;\n// const uint32_t metaWR_Cnt = 934640;  //2147483647;\nconst uint8_t SR = 0;\nconst uint8_t DIRECT = 1;\nconst uint8_t PATCHED = 2;\nconst uint8_t DELTA = 3;\nconst uint8_t HEADER_ST = 7;\nconst uint8_t SR_STATE = 0; // 0 from 8\nconst uint8_t DI_STATE = 1; // 1 from 5\nconst uint8_t PA_STATE = 2; // 2 from 7\nconst uint8_t DE_STATE = 3; // 3 from 2\nconst uint8_t ASSIGN_DATA = 4;\nconst uint8_t PA_META_PROC = 5;\nconst uint8_t TR_HEADER = 6;\nconst uint8_t HD_PROC = 8;\nconst uint8_t waste_cycles = 9;\nconst uint16_t AXI_WIDTH_2X = 1024;\nconst uint16_t AXI_WIDTH_4X = 2048;\nconst uint16_t AXI_WIDTH = 512;\nconst uint16_t SR_DATAW = 320;\nconst uint16_t AXI_WIDTH_H = 256;\nconst uint16_t AXI_WIDTH_HH = 128;\ntypedef ap_uint<AXI_WIDTH_4X> _2048b;\ntypedef ap_uint<AXI_WIDTH_2X> _1024b;\ntypedef ap_uint<AXI_WIDTH> _512b;\ntypedef ap_int<AXI_WIDTH> _512bi;\ntypedef ap_uint<SR_DATAW> _320b;\ntypedef ap_uint<AXI_WIDTH_H> _256b;\ntypedef ap_uint<AXI_WIDTH_HH> _128b;\nconst uint16_t PEs = 16;\n// Map to bit width value.\n// const uint16_t NDelta_BitMap[32] = {1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n// const uint16_t Delta_BitMap[32] = {0,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n\nvoid mmap2s(tapa::async_mmap<_512b>& input_port,\n            tapa::ostream<_512b>& outLstrm,\n            tapa::ostream<bool>& rstStrmL,\n            tapa::ostream<bool>& rstStrmMeta,\n            tapa::ostream<bool>& rstStrmStore,\n            uint32_t wait_count,\n            uint32_t data_count)\n{\n#pragma HLS disaggregate variable = input_port\n#pragma HLS interface ap_fifo port = input_port.read_addr._\n#pragma HLS aggregate variable = input_port.read_addr._  bit\n#pragma HLS interface ap_fifo port = input_port.read_data._\n#pragma HLS aggregate variable = input_port.read_data._  bit\n#pragma HLS interface ap_fifo port = input_port.write_addr._\n#pragma HLS aggregate variable = input_port.write_addr._  bit\n#pragma HLS interface ap_fifo port = input_port.write_data._\n#pragma HLS aggregate variable = input_port.write_data._  bit\n#pragma HLS interface ap_fifo port = input_port.write_resp._\n#pragma HLS aggregate variable = input_port.write_resp._  bit\n#pragma HLS disaggregate variable = input_port .read_data\n#pragma HLS interface ap_fifo port = input_port.read_data._peek\n#pragma HLS aggregate variable = input_port.read_data._peek bit\n#pragma HLS disaggregate variable = input_port .write_resp\n#pragma HLS interface ap_fifo port = input_port.write_resp._peek\n#pragma HLS aggregate variable = input_port.write_resp._peek bit\nvoid(input_port.read_addr._.full());\nvoid(input_port.read_data._.empty());\nvoid(input_port.read_data._peek.empty());\nvoid(input_port.write_addr._.full());\nvoid(input_port.write_data._.full());\nvoid(input_port.write_resp._.empty());\nvoid(input_port.write_resp._peek.empty());\n\n#pragma HLS disaggregate variable = outLstrm\n#pragma HLS interface ap_fifo port = outLstrm._\n#pragma HLS aggregate variable = outLstrm._ bit\nvoid(outLstrm._.full());\n\n#pragma HLS disaggregate variable = rstStrmL\n#pragma HLS interface ap_fifo port = rstStrmL._\n#pragma HLS aggregate variable = rstStrmL._ bit\nvoid(rstStrmL._.full());\n\n#pragma HLS disaggregate variable = rstStrmMeta\n#pragma HLS interface ap_fifo port = rstStrmMeta._\n#pragma HLS aggregate variable = rstStrmMeta._ bit\nvoid(rstStrmMeta._.full());\n\n#pragma HLS disaggregate variable = rstStrmStore\n#pragma HLS interface ap_fifo port = rstStrmStore._\n#pragma HLS aggregate variable = rstStrmStore._ bit\nvoid(rstStrmStore._.full());\n\n\n\n    _512b data_read = 0;\n    int counter = 0;\n    rstStrmL.write(1);\n    rstStrmMeta.write(1);\n    rstStrmStore.write(1);\n    // uint32_t loop_bound = (data_count/64);    //ADD this extra depth in host.\n    mmap2s:for(uint32_t i_req = 0, i_resp = 0; i_resp < data_count;)\n    {\n#pragma HLS PIPELINE II = 1\n        if ((i_req < data_count) &&\n            (input_port.read_addr.try_write(i_req))) {\n        ++i_req;\n        }\n        if((!input_port.read_data.empty()))\n        {\n            data_read = input_port.read_data.read(nullptr);\n            ++i_resp;\n            outLstrm.write(data_read);\n        }\n    }\n    waitToFinish:for(uint32_t i_req = 0, i_resp = 0; counter < wait_count;)\n    {\n#pragma HLS PIPELINE II = 1\n        if((!input_port.read_data.empty()))\n        {\n            data_read = input_port.read_data.read(nullptr);\n            ++i_resp;\n            // outLstrm.write(data_read);\n        }\n        counter += 1;\n    }\n}\nvoid load(tapa::istream<_512b>& data_in,\n            tapa::istream<bool>& rstStrm,\n            tapa::ostream<_2048b>& outAll_Lstrm,\n            tapa::ostream<_256b> &out_strmC_Track,\n            tapa::ostream<_512b>& PA_DATA,\n            tapa::ostream<uint32_t>& PA_metaDATA\n            // tapa::ostream<uint32_t>& paCnt_strm\n            // uint32_t KRNL_Data_Write\n            // uint32_t data_count\n                 )\n;\nvoid data_Sender(tapa::istream<_2048b>& data_in,\n                tapa::istream<_256b>& meta_in,\n                // tapa::istream<bool> & rst_Strm,\n                tapa::ostreams<_512b,4>& outAll_Pstrm,\n                tapa::ostream<uint64_t>& outSR_Pstrm,\n                tapa::ostreams<_256b, 4>& meta_out,\n                tapa::ostream<uint8_t>& SR_meta_out,\n                tapa::ostream<uint64_t>& All_meta_out,\n                tapa::ostream<uint8_t>& Dec_type_Out\n                // tapa::ostream<uint32_t>& data_Cnt,\n                // tapa::ostream<uint32_t>& pa_Cnt\n                )\n;\nvoid compSR(tapa::istream<uint64_t>& outSR_Pstrm,\n            tapa::istream<uint8_t>& meta_out,\n            tapa::ostream<_320b>& SR_Dout)\n;\nvoid compute_delta(tapa::istream<_512b>& in_Cstrm,\n                tapa::istream<_256b>& in_Trstrm,\n                tapa::ostream<uint32_t>& out_Cmeta_strm,\n                tapa::ostream<_512b>& out_Cstrm,\n                tapa::ostream<_512b>& DI_strm,\n                tapa::ostream<_512b>& PA_strm,\n                tapa::ostream<uint32_t>& PA_meta_strm,\n                uint32_t compD_ID)\n;\nvoid PA_meta_proc(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_meta_Strm,\n                tapa::ostream<uint64_t>& metaOutPA_Strm) //PLL, IDX, VAL\n;\nvoid PA_sum_out(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_BV_Strm,\n                tapa::ostream<_512b>& dataOutPA_Strm\n                )\n;\nvoid Meta_Aligner(tapa::istream<uint64_t>& PA_metaStrm,\n                tapa::istream<uint64_t>& All_meta_Strm,\n                tapa::ostream<_128b>& meta_Out\n                )\n;\nvoid Meta_Writer(tapa::istream<_128b>& PA_metaStrm,\n                tapa::istream<bool>& rst_StrmDS,\n                // tapa::istream<uint32_t>& complete_count,\n                uint64_t  metaPort_Out\n                // uint32_t KRNL_Data_Write\n                )\n;\nvoid delta_sumNC_in(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                // ,uint32_t ID\n                )\n;\nvoid delta_sumNC_all(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_sum_2out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm1\n                )\n;\nvoid delta_sum_1out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                )\n;\nvoid delta_sum_0out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_Fsum(tapa::istreams<_512b, 4>& delta_Strm,\n                tapa::istreams<uint32_t, 4>& meta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostreams<_512b, 4>& dataOut_Strm\n                )\n;\nvoid Data_Aligner(tapa::istream<uint8_t>& inTrackStrm,\n                tapa::istreams<_512b, 4>& inDEStrm,\n                tapa::istreams<_512b, 4>& inDIStrm,\n                tapa::istreams<_512b, 4>& inPAStrm,\n                tapa::istream<_320b>& inSRStrm,\n                tapa::ostreams<_512b, 4>& outWRStrm )\n;\nvoid store_all(tapa::istreams<_512b, 4>& inAllStrm,\n            tapa::istream<bool>& rst_StrmL,\n            // tapa::istream<uint32_t>& dataCnt_strm,\n            uint64_t OUT0_32b_8b,\n            uint64_t OUT1_16b_8b,\n            uint64_t OUT2_16b_8b,\n            uint64_t OUT3_8b)\n;\nvoid data_decoding(uint64_t  input_port,\n                    uint64_t  output_port0_32b_8b,\n                    uint64_t  output_port1_16b_8b,\n                    uint64_t  output_port2_16b_8b,\n                    uint64_t  output_port3_8b,\n                    uint64_t  output_port4_Track,\n                    uint32_t wait_count,\n                    uint32_t data_count)\n;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "store_all": {
            "code": "\n\n\n #include <cstdint>\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <iostream>\n\n#include <fstream>\n\n#include <string>\n\n#include <vector>\n\n#include <algorithm>\n\n#include <inttypes.h>\n\n\n #include \"ap_int.h\"\n\n#include <tapa.h>\n\n// const uint32_t dataWR_Cnt = 934640;\n// const uint32_t metaWR_Cnt = 934640;  //2147483647;\nconst uint8_t SR = 0;\nconst uint8_t DIRECT = 1;\nconst uint8_t PATCHED = 2;\nconst uint8_t DELTA = 3;\nconst uint8_t HEADER_ST = 7;\nconst uint8_t SR_STATE = 0; // 0 from 8\nconst uint8_t DI_STATE = 1; // 1 from 5\nconst uint8_t PA_STATE = 2; // 2 from 7\nconst uint8_t DE_STATE = 3; // 3 from 2\nconst uint8_t ASSIGN_DATA = 4;\nconst uint8_t PA_META_PROC = 5;\nconst uint8_t TR_HEADER = 6;\nconst uint8_t HD_PROC = 8;\nconst uint8_t waste_cycles = 9;\nconst uint16_t AXI_WIDTH_2X = 1024;\nconst uint16_t AXI_WIDTH_4X = 2048;\nconst uint16_t AXI_WIDTH = 512;\nconst uint16_t SR_DATAW = 320;\nconst uint16_t AXI_WIDTH_H = 256;\nconst uint16_t AXI_WIDTH_HH = 128;\ntypedef ap_uint<AXI_WIDTH_4X> _2048b;\ntypedef ap_uint<AXI_WIDTH_2X> _1024b;\ntypedef ap_uint<AXI_WIDTH> _512b;\ntypedef ap_int<AXI_WIDTH> _512bi;\ntypedef ap_uint<SR_DATAW> _320b;\ntypedef ap_uint<AXI_WIDTH_H> _256b;\ntypedef ap_uint<AXI_WIDTH_HH> _128b;\nconst uint16_t PEs = 16;\n// Map to bit width value.\n// const uint16_t NDelta_BitMap[32] = {1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n// const uint16_t Delta_BitMap[32] = {0,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,\n//                                 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n//                                 23, 24, 26, 28, 30, 32, 40, 48, 56, 64};\n\nvoid mmap2s(uint64_t  input_port,\n            tapa::ostream<_512b>& outLstrm,\n            tapa::ostream<bool>& rstStrmL,\n            tapa::ostream<bool>& rstStrmMeta,\n            tapa::ostream<bool>& rstStrmStore,\n            uint32_t wait_count,\n            uint32_t data_count)\n;\nvoid load(tapa::istream<_512b>& data_in,\n            tapa::istream<bool>& rstStrm,\n            tapa::ostream<_2048b>& outAll_Lstrm,\n            tapa::ostream<_256b> &out_strmC_Track,\n            tapa::ostream<_512b>& PA_DATA,\n            tapa::ostream<uint32_t>& PA_metaDATA\n            // tapa::ostream<uint32_t>& paCnt_strm\n            // uint32_t KRNL_Data_Write\n            // uint32_t data_count\n                 )\n;\nvoid data_Sender(tapa::istream<_2048b>& data_in,\n                tapa::istream<_256b>& meta_in,\n                // tapa::istream<bool> & rst_Strm,\n                tapa::ostreams<_512b,4>& outAll_Pstrm,\n                tapa::ostream<uint64_t>& outSR_Pstrm,\n                tapa::ostreams<_256b, 4>& meta_out,\n                tapa::ostream<uint8_t>& SR_meta_out,\n                tapa::ostream<uint64_t>& All_meta_out,\n                tapa::ostream<uint8_t>& Dec_type_Out\n                // tapa::ostream<uint32_t>& data_Cnt,\n                // tapa::ostream<uint32_t>& pa_Cnt\n                )\n;\nvoid compSR(tapa::istream<uint64_t>& outSR_Pstrm,\n            tapa::istream<uint8_t>& meta_out,\n            tapa::ostream<_320b>& SR_Dout)\n;\nvoid compute_delta(tapa::istream<_512b>& in_Cstrm,\n                tapa::istream<_256b>& in_Trstrm,\n                tapa::ostream<uint32_t>& out_Cmeta_strm,\n                tapa::ostream<_512b>& out_Cstrm,\n                tapa::ostream<_512b>& DI_strm,\n                tapa::ostream<_512b>& PA_strm,\n                tapa::ostream<uint32_t>& PA_meta_strm,\n                uint32_t compD_ID)\n;\nvoid PA_meta_proc(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_meta_Strm,\n                tapa::ostream<uint64_t>& metaOutPA_Strm) //PLL, IDX, VAL\n;\nvoid PA_sum_out(tapa::istream<_512b>& PA_Strm,\n                tapa::istream<uint32_t>& PA_BV_Strm,\n                tapa::ostream<_512b>& dataOutPA_Strm\n                )\n;\nvoid Meta_Aligner(tapa::istream<uint64_t>& PA_metaStrm,\n                tapa::istream<uint64_t>& All_meta_Strm,\n                tapa::ostream<_128b>& meta_Out\n                )\n;\nvoid Meta_Writer(tapa::istream<_128b>& PA_metaStrm,\n                tapa::istream<bool>& rst_StrmDS,\n                // tapa::istream<uint32_t>& complete_count,\n                uint64_t  metaPort_Out\n                // uint32_t KRNL_Data_Write\n                )\n;\nvoid delta_sumNC_in(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                // ,uint32_t ID\n                )\n;\nvoid delta_sumNC_all(tapa::istream<_512b>& delta_Strm,\n                // tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_sum_2out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm1\n                )\n;\nvoid delta_sum_1out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm,\n                tapa::ostream<uint32_t>& CarryOut_Strm\n                )\n;\nvoid delta_sum_0out(tapa::istream<_512b>& delta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostream<_512b>& dataOut_Strm\n                )\n;\nvoid delta_Fsum(tapa::istreams<_512b, 4>& delta_Strm,\n                tapa::istreams<uint32_t, 4>& meta_Strm,\n                tapa::istream<uint32_t>& CarryIn_Strm,\n                tapa::ostreams<_512b, 4>& dataOut_Strm\n                )\n;\nvoid Data_Aligner(tapa::istream<uint8_t>& inTrackStrm,\n                tapa::istreams<_512b, 4>& inDEStrm,\n                tapa::istreams<_512b, 4>& inDIStrm,\n                tapa::istreams<_512b, 4>& inPAStrm,\n                tapa::istream<_320b>& inSRStrm,\n                tapa::ostreams<_512b, 4>& outWRStrm )\n;\nvoid store_all(tapa::istreams<_512b, 4>& inAllStrm,\n            tapa::istream<bool>& rst_StrmL,\n            // tapa::istream<uint32_t>& dataCnt_strm,\n            tapa::async_mmap<_512b> &OUT0_32b_8b,\n            tapa::async_mmap<_512b> &OUT1_16b_8b,\n            tapa::async_mmap<_512b> &OUT2_16b_8b,\n            tapa::async_mmap<_512b> &OUT3_8b)\n{\n#pragma HLS disaggregate variable = inAllStrm\n#pragma HLS array_partition variable = inAllStrm complete\n#pragma HLS interface ap_fifo port = inAllStrm[0]._\n#pragma HLS aggregate variable = inAllStrm[0]._ bit\n#pragma HLS interface ap_fifo port = inAllStrm[0]._peek\n#pragma HLS aggregate variable = inAllStrm[0]._peek bit\nvoid(inAllStrm[0]._.empty());\nvoid(inAllStrm[0]._peek.empty());\n#pragma HLS interface ap_fifo port = inAllStrm[1]._\n#pragma HLS aggregate variable = inAllStrm[1]._ bit\n#pragma HLS interface ap_fifo port = inAllStrm[1]._peek\n#pragma HLS aggregate variable = inAllStrm[1]._peek bit\nvoid(inAllStrm[1]._.empty());\nvoid(inAllStrm[1]._peek.empty());\n#pragma HLS interface ap_fifo port = inAllStrm[2]._\n#pragma HLS aggregate variable = inAllStrm[2]._ bit\n#pragma HLS interface ap_fifo port = inAllStrm[2]._peek\n#pragma HLS aggregate variable = inAllStrm[2]._peek bit\nvoid(inAllStrm[2]._.empty());\nvoid(inAllStrm[2]._peek.empty());\n#pragma HLS interface ap_fifo port = inAllStrm[3]._\n#pragma HLS aggregate variable = inAllStrm[3]._ bit\n#pragma HLS interface ap_fifo port = inAllStrm[3]._peek\n#pragma HLS aggregate variable = inAllStrm[3]._peek bit\nvoid(inAllStrm[3]._.empty());\nvoid(inAllStrm[3]._peek.empty());\n\n#pragma HLS disaggregate variable = rst_StrmL\n#pragma HLS interface ap_fifo port = rst_StrmL._\n#pragma HLS aggregate variable = rst_StrmL._ bit\n#pragma HLS interface ap_fifo port = rst_StrmL._peek\n#pragma HLS aggregate variable = rst_StrmL._peek bit\nvoid(rst_StrmL._.empty());\nvoid(rst_StrmL._peek.empty());\n\n#pragma HLS disaggregate variable = OUT0_32b_8b\n#pragma HLS interface ap_fifo port = OUT0_32b_8b.read_addr._\n#pragma HLS aggregate variable = OUT0_32b_8b.read_addr._  bit\n#pragma HLS interface ap_fifo port = OUT0_32b_8b.read_data._\n#pragma HLS aggregate variable = OUT0_32b_8b.read_data._  bit\n#pragma HLS interface ap_fifo port = OUT0_32b_8b.write_addr._\n#pragma HLS aggregate variable = OUT0_32b_8b.write_addr._  bit\n#pragma HLS interface ap_fifo port = OUT0_32b_8b.write_data._\n#pragma HLS aggregate variable = OUT0_32b_8b.write_data._  bit\n#pragma HLS interface ap_fifo port = OUT0_32b_8b.write_resp._\n#pragma HLS aggregate variable = OUT0_32b_8b.write_resp._  bit\n#pragma HLS disaggregate variable = OUT0_32b_8b .read_data\n#pragma HLS interface ap_fifo port = OUT0_32b_8b.read_data._peek\n#pragma HLS aggregate variable = OUT0_32b_8b.read_data._peek bit\n#pragma HLS disaggregate variable = OUT0_32b_8b .write_resp\n#pragma HLS interface ap_fifo port = OUT0_32b_8b.write_resp._peek\n#pragma HLS aggregate variable = OUT0_32b_8b.write_resp._peek bit\nvoid(OUT0_32b_8b.read_addr._.full());\nvoid(OUT0_32b_8b.read_data._.empty());\nvoid(OUT0_32b_8b.read_data._peek.empty());\nvoid(OUT0_32b_8b.write_addr._.full());\nvoid(OUT0_32b_8b.write_data._.full());\nvoid(OUT0_32b_8b.write_resp._.empty());\nvoid(OUT0_32b_8b.write_resp._peek.empty());\n\n#pragma HLS disaggregate variable = OUT1_16b_8b\n#pragma HLS interface ap_fifo port = OUT1_16b_8b.read_addr._\n#pragma HLS aggregate variable = OUT1_16b_8b.read_addr._  bit\n#pragma HLS interface ap_fifo port = OUT1_16b_8b.read_data._\n#pragma HLS aggregate variable = OUT1_16b_8b.read_data._  bit\n#pragma HLS interface ap_fifo port = OUT1_16b_8b.write_addr._\n#pragma HLS aggregate variable = OUT1_16b_8b.write_addr._  bit\n#pragma HLS interface ap_fifo port = OUT1_16b_8b.write_data._\n#pragma HLS aggregate variable = OUT1_16b_8b.write_data._  bit\n#pragma HLS interface ap_fifo port = OUT1_16b_8b.write_resp._\n#pragma HLS aggregate variable = OUT1_16b_8b.write_resp._  bit\n#pragma HLS disaggregate variable = OUT1_16b_8b .read_data\n#pragma HLS interface ap_fifo port = OUT1_16b_8b.read_data._peek\n#pragma HLS aggregate variable = OUT1_16b_8b.read_data._peek bit\n#pragma HLS disaggregate variable = OUT1_16b_8b .write_resp\n#pragma HLS interface ap_fifo port = OUT1_16b_8b.write_resp._peek\n#pragma HLS aggregate variable = OUT1_16b_8b.write_resp._peek bit\nvoid(OUT1_16b_8b.read_addr._.full());\nvoid(OUT1_16b_8b.read_data._.empty());\nvoid(OUT1_16b_8b.read_data._peek.empty());\nvoid(OUT1_16b_8b.write_addr._.full());\nvoid(OUT1_16b_8b.write_data._.full());\nvoid(OUT1_16b_8b.write_resp._.empty());\nvoid(OUT1_16b_8b.write_resp._peek.empty());\n\n#pragma HLS disaggregate variable = OUT2_16b_8b\n#pragma HLS interface ap_fifo port = OUT2_16b_8b.read_addr._\n#pragma HLS aggregate variable = OUT2_16b_8b.read_addr._  bit\n#pragma HLS interface ap_fifo port = OUT2_16b_8b.read_data._\n#pragma HLS aggregate variable = OUT2_16b_8b.read_data._  bit\n#pragma HLS interface ap_fifo port = OUT2_16b_8b.write_addr._\n#pragma HLS aggregate variable = OUT2_16b_8b.write_addr._  bit\n#pragma HLS interface ap_fifo port = OUT2_16b_8b.write_data._\n#pragma HLS aggregate variable = OUT2_16b_8b.write_data._  bit\n#pragma HLS interface ap_fifo port = OUT2_16b_8b.write_resp._\n#pragma HLS aggregate variable = OUT2_16b_8b.write_resp._  bit\n#pragma HLS disaggregate variable = OUT2_16b_8b .read_data\n#pragma HLS interface ap_fifo port = OUT2_16b_8b.read_data._peek\n#pragma HLS aggregate variable = OUT2_16b_8b.read_data._peek bit\n#pragma HLS disaggregate variable = OUT2_16b_8b .write_resp\n#pragma HLS interface ap_fifo port = OUT2_16b_8b.write_resp._peek\n#pragma HLS aggregate variable = OUT2_16b_8b.write_resp._peek bit\nvoid(OUT2_16b_8b.read_addr._.full());\nvoid(OUT2_16b_8b.read_data._.empty());\nvoid(OUT2_16b_8b.read_data._peek.empty());\nvoid(OUT2_16b_8b.write_addr._.full());\nvoid(OUT2_16b_8b.write_data._.full());\nvoid(OUT2_16b_8b.write_resp._.empty());\nvoid(OUT2_16b_8b.write_resp._peek.empty());\n\n#pragma HLS disaggregate variable = OUT3_8b\n#pragma HLS interface ap_fifo port = OUT3_8b.read_addr._\n#pragma HLS aggregate variable = OUT3_8b.read_addr._  bit\n#pragma HLS interface ap_fifo port = OUT3_8b.read_data._\n#pragma HLS aggregate variable = OUT3_8b.read_data._  bit\n#pragma HLS interface ap_fifo port = OUT3_8b.write_addr._\n#pragma HLS aggregate variable = OUT3_8b.write_addr._  bit\n#pragma HLS interface ap_fifo port = OUT3_8b.write_data._\n#pragma HLS aggregate variable = OUT3_8b.write_data._  bit\n#pragma HLS interface ap_fifo port = OUT3_8b.write_resp._\n#pragma HLS aggregate variable = OUT3_8b.write_resp._  bit\n#pragma HLS disaggregate variable = OUT3_8b .read_data\n#pragma HLS interface ap_fifo port = OUT3_8b.read_data._peek\n#pragma HLS aggregate variable = OUT3_8b.read_data._peek bit\n#pragma HLS disaggregate variable = OUT3_8b .write_resp\n#pragma HLS interface ap_fifo port = OUT3_8b.write_resp._peek\n#pragma HLS aggregate variable = OUT3_8b.write_resp._peek bit\nvoid(OUT3_8b.read_addr._.full());\nvoid(OUT3_8b.read_data._.empty());\nvoid(OUT3_8b.read_data._peek.empty());\nvoid(OUT3_8b.write_addr._.full());\nvoid(OUT3_8b.write_data._.full());\nvoid(OUT3_8b.write_resp._.empty());\nvoid(OUT3_8b.write_resp._peek.empty());\n\n    uint32_t i_req_0 = 0, i_resp_0 = 0,\n             i_req_1 = 0, i_resp_1 = 0,\n             i_req_2 = 0, i_resp_2 = 0,\n             i_req_3 = 0, i_resp_3 = 0;\n    // uint32_t write_count = dataWR_Cnt; //dataWR_Cnt; //2147483647;\n    // (i_resp_3 < write_count) ||\n    // (i_resp_2 < write_count) ||\n    // (i_resp_1 < write_count) ||\n    // (i_resp_0 < write_count)\n    store_loop32:for( ; ; )\n    {\n#pragma HLS pipeline II=1\n        //reset stream\n            if(!rst_StrmL.empty())\n            {\n                bool tmp = rst_StrmL.read();\n                i_req_0 = 0;\n                i_req_1 = 0;\n                i_req_2 = 0;\n                i_req_3 = 0;\n            }\n        // //Update Write Count\n        //     if(!dataCnt_strm.empty())\n        //     {\n        //         write_count = dataCnt_strm.read();\n        //     }\n        //------PORT0_32Bits _ 8bits--------\n            // issue write requests\n            if((!inAllStrm[0].empty()) &&\n                (!OUT0_32b_8b.write_addr.full()) &&\n                (!OUT0_32b_8b.write_data.full())\n                ){\n            OUT0_32b_8b.write_addr.try_write(i_req_0);\n            OUT0_32b_8b.write_data.try_write(inAllStrm[0].read(nullptr));\n            ++i_req_0;\n            }\n            // receive acks of write success\n            if (!OUT0_32b_8b.write_resp.empty()) {\n            i_resp_0 =\n                unsigned(OUT0_32b_8b.write_resp.read(nullptr)) + 1;\n            }\n        //------PORT1_16Bits _ 8bits--------\n            // issue write requests\n            if ((!inAllStrm[1].empty()) &&\n                (!OUT1_16b_8b.write_addr.full()) &&\n                (!OUT1_16b_8b.write_data.full())\n                ) {\n            OUT1_16b_8b.write_addr.try_write(i_req_1);\n            OUT1_16b_8b.write_data.try_write(inAllStrm[1].read(nullptr));\n            ++i_req_1;\n            }\n            // receive acks of write success\n            if (!OUT1_16b_8b.write_resp.empty()) {\n            i_resp_1 =\n                unsigned(OUT1_16b_8b.write_resp.read(nullptr)) + 1;\n            }\n        //------PORT2_16Bits _ 8bits--------\n            // issue write requests\n            if ((!inAllStrm[2].empty()) &&\n                (!OUT2_16b_8b.write_addr.full()) &&\n                (!OUT2_16b_8b.write_data.full())\n                ) {\n            OUT2_16b_8b.write_addr.try_write(i_req_2);\n            OUT2_16b_8b.write_data.try_write(inAllStrm[2].read(nullptr));\n            ++i_req_2;\n            }\n            // receive acks of write success\n            if (!OUT2_16b_8b.write_resp.empty()) {\n            i_resp_2 =\n                unsigned(OUT2_16b_8b.write_resp.read(nullptr)) + 1;\n            }\n        //------PORT3_8Bits--------\n            // issue write requests\n            if ((!inAllStrm[3].empty()) &&\n                (!OUT3_8b.write_addr.full()) &&\n                (!OUT3_8b.write_data.full())\n                ) {\n            OUT3_8b.write_addr.try_write(i_req_3);\n            OUT3_8b.write_data.try_write(inAllStrm[3].read(nullptr));\n            ++i_req_3;\n            }\n            // receive acks of write success\n            if (!OUT3_8b.write_resp.empty()) {\n            i_resp_3 =\n                unsigned(OUT3_8b.write_resp.read(nullptr)) + 1;\n            }\n        //------PORT4_SR--------\n            // // issue write requests\n            // if (!inSR_Strm.empty() &&\n            //     !OUT4_SR.write_addr.full() &&\n            //     !OUT4_SR.write_data.full()) {\n            // OUT4_SR.write_addr.try_write(i_req_4);\n            // OUT4_SR.write_data.try_write(inSR_Strm.read(nullptr));\n            // ++i_req_4;\n            // }\n            // // receive acks of write success\n            // if (!OUT4_SR.write_resp.empty()) {\n            // i_resp_4+ = \n            //     unsigned(OUT4_SR.write_resp.read(nullptr)) + 1;\n            // }\n    }\n}\nvoid data_decoding(uint64_t  input_port,\n                    uint64_t  output_port0_32b_8b,\n                    uint64_t  output_port1_16b_8b,\n                    uint64_t  output_port2_16b_8b,\n                    uint64_t  output_port3_8b,\n                    uint64_t  output_port4_Track,\n                    uint32_t wait_count,\n                    uint32_t data_count)\n;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        }
    },
    "top": "data_decoding"
}
