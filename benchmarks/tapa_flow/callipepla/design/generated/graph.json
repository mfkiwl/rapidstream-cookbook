{
    "cflags": [
        "-std=c++17",
        "-I",
        "/home/ylxiao/.local/lib/python3.10/site-packages/tapa/../../../src",
        "-isystem",
        "/tools/Xilinx/Vitis_HLS/2022.2/include"
    ],
    "tasks": {
        "Arbiter_Y": {
            "code": "\n\n #include <ap_int.h>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cassert>\n\n\n #include \"ap_utils.h\"\n\n#include <tapa.h>\n\n\n\n #include <ap_int.h>\n\n#include <tapa.h>\nconstexpr int NUM_CH_SPARSE = 16;\nconstexpr int X_PARTITION_FACTOR = 4; // BRAMs = 512 / 16 / 2 = 16 -> factor = 16 / (64 / 16)\nconstexpr int WINDOW_SIZE = X_PARTITION_FACTOR * 1024;\nconstexpr int DEP_DIST_LOAD_STORE = 7;\nconstexpr int URAM_DEPTH = 3 * 4096;\n// ch16: 3 * 4096 * 16 * 8 = 1,572,864\nusing double_v8 = tapa::vec_t<double, 8>;\nvoid Callipepla(tapa::mmap<int> edge_list_ptr,\n                tapa::mmaps<ap_uint<512>, NUM_CH_SPARSE> edge_list_ch,\n                tapa::mmaps<double_v8, 2> vec_x,\n                tapa::mmaps<double_v8, 2> vec_p,\n                tapa::mmap<double_v8> vec_Ap,\n                tapa::mmaps<double_v8, 2> vec_r,\n                tapa::mmap<double_v8> vec_digA,\n                tapa::mmap<double> vec_res,\n                const int NUM_ITE, const int NUM_A_LEN, const int M,\n                const int rp_time,\n                const double th_termination\n                );\n\nconstexpr int FIFO_DEPTH = 2;\nconstexpr int FIFO_DEPTH_M6 = 50;\nconst int NUM_CH_SPARSE_div_8 = NUM_CH_SPARSE / 8;\nconst int NUM_CH_SPARSE_mult_8 = NUM_CH_SPARSE * 8;\nconst int WINDOW_SIZE_div_8 = WINDOW_SIZE / 8;\nstruct MultXVec {\n    tapa::vec_t<ap_uint<18>, 8> row;\n    double_v8 axv;\n};\nstruct InstRdWr {\n    bool rd;\n    bool wr;\n    //bool require_response;\n    int base_addr;\n    int len;\n};\nstruct InstVCtrl {\n    bool rd;\n    bool wr;\n    int base_addr;\n    int len;\n    ap_uint<3> q_rd_idx;\n    //ap_uint<3> q_wr_idx;\n};\nstruct InstCmp {\n    int len;\n    double alpha;\n    ap_uint<3> q_idx;\n};\nstruct ResTerm {\n    double res;\n    bool term;\n};\ntemplate <typename T, typename R>\ninline void async_read(tapa::async_mmap<T> & A,\n                       tapa::ostream<T> & fifo_A,\n                       const R i_end_addr,\n                       R & i_req,\n                       R & i_resp) {\n#pragma HLS inline\n    if ((i_req < i_end_addr) &\n        !A.read_addr.full()) {\n        A.read_addr.try_write(i_req);\n        ++i_req;\n    }\n    if (!fifo_A.full() & !A.read_data.empty()) {\n        T tmp;\n        A.read_data.try_read(tmp);\n        fifo_A.try_write(tmp);\n        ++i_resp;\n    }\n}\ntemplate <typename T, typename R>\ninline void async_write(tapa::async_mmap<T> & Y_out,\n                        tapa::istream<T> & fifo_Y,\n                        const R num_ite_Y,\n                        R & i_req,\n                        R & i_resp\n                        ) {\n#pragma HLS inline\n    if ((i_req < num_ite_Y) &\n        !fifo_Y.empty() &\n        !Y_out.write_addr.full() &\n        !Y_out.write_data.full() ) {\n        Y_out.write_addr.try_write(i_req);\n        T tmpv;\n        fifo_Y.try_read(tmpv);\n        Y_out.write_data.try_write(tmpv);\n        ++i_req;\n    }\n    uint8_t n_resp;\n    if (Y_out.write_resp.try_read(n_resp)) {\n        i_resp += R(n_resp) + 1;\n    }\n}\nvoid rdwr_vec(uint64_t  vec_p,\n              tapa::istream<InstRdWr> & q_inst,\n              tapa::istream<double_v8> & q_din,\n              tapa::ostream<double_v8> & q_dout,\n              tapa::ostream<bool> & q_response\n              ) ;\ntemplate <typename data_t>\ninline void q2q(tapa::istream<data_t> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty() & !qout.full()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void clearq(tapa::istream<data_t> & qin,\n                   const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void q2q(tapa::istreams<data_t, 2> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite,\n                const int idx) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin[idx].empty() & !qout.full()) {\n            data_t tmp;\n            qin[idx].try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void qq2qq(tapa::istream<data_t> & qin_pe,\n                  tapa::ostreams<data_t, 2> & qout_mem,\n                  tapa::istreams<data_t, 2> & qin_mem,\n                  tapa::ostream<data_t> & qout_qe,\n                  const int num_ite,\n                  const int idx) {\n#pragma HLS inline\nqq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin_pe.empty() & !qout_mem[idx].full()) {\n            data_t tmp;\n            qin_pe.try_read(tmp);\n            qout_mem[idx].try_write(tmp);\n            ++i;\n        }\n        if (!qin_mem[1 - idx].empty() & !qout_qe.full()) {\n            data_t tmp;\n            qin_mem[1 - idx].try_read(tmp);\n            qout_qe.try_write(tmp);\n        }\n    }\n}\nvoid term_signal_router(tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_to_rdA,\n                        tapa::ostream<bool> & q_to_edgepointer,\n                        tapa::ostream<bool> & q_to_abiter,\n                        tapa::ostream<bool> & q_to_ctrlmem,\n                        tapa::ostream<bool> & q_to_mux\n                        ) ;\nvoid read_edge_list_ptr(const int num_ite,\n                        const int M,\n                        const int rp_time, //P_N,\n                        uint64_t  edge_list_ptr,\n                        tapa::ostream<int> & PE_inst,\n                        tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_gbc_out\n                        ) ;\nvoid read_vec(const int rp_time, //P_N\n              const int M, //K,\n              tapa::async_mmap<double_v8> & vec_X,\n              tapa::ostream<double_v8> & fifo_X\n              ) {\n    //const int rp_time = (P_N == 0)? 1 : P_N;\n    const int num_ite_X = (M + 7) >> 3;\nl_rp:\n    for(int rp = 0; rp < rp_time; rp++) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n    rd_X:\n        for(int i_req = 0, i_resp = 0; i_resp < num_ite_X;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n            async_read(vec_X,\n                       fifo_X,\n                       num_ite_X,\n                       i_req, i_resp);\n        }\n    }\n}\nvoid read_A(const int rp_time, //P_N,\n            const int A_len,\n            uint64_t  A,\n            tapa::ostream<ap_uint<512>> & fifo_A,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid PEG_Xvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<ap_uint<512>> & fifo_A,\n              tapa::istream<double_v8> & fifo_X_in,\n              tapa::ostream<int> & fifo_inst_out,\n              tapa::ostream<double_v8> & fifo_X_out,\n              // to PEG_Yvec\n              tapa::ostream<int> & fifo_inst_out_to_Yvec,\n              tapa::ostream<MultXVec> & fifo_aXvec,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out,\n              tapa::ostream<bool> & q_gbc_out_Y\n              ) ;\nvoid PEG_Yvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<MultXVec> & fifo_aXvec,\n              tapa::ostream<double> & fifo_Y_out,\n              tapa::istream<bool> & q_gbc\n              ) ;\nvoid Arbiter_Y(const int rp_time, //P_N,\n               const int M,\n               tapa::istreams<double, NUM_CH_SPARSE_div_8> & fifo_in, // 2 = 16 / 8\n               tapa::ostream<double> & fifo_out,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) {\n\n\n#pragma HLS disaggregate variable = fifo_in\n#pragma HLS array_partition variable = fifo_in complete\n#pragma HLS interface ap_fifo port = fifo_in[0]._\n#pragma HLS aggregate variable = fifo_in[0]._ bit\n#pragma HLS interface ap_fifo port = fifo_in[0]._peek\n#pragma HLS aggregate variable = fifo_in[0]._peek bit\nvoid(fifo_in[0]._.empty());\nvoid(fifo_in[0]._peek.empty());\n#pragma HLS interface ap_fifo port = fifo_in[1]._\n#pragma HLS aggregate variable = fifo_in[1]._ bit\n#pragma HLS interface ap_fifo port = fifo_in[1]._peek\n#pragma HLS aggregate variable = fifo_in[1]._peek bit\nvoid(fifo_in[1]._.empty());\nvoid(fifo_in[1]._peek.empty());\n\n#pragma HLS disaggregate variable = fifo_out\n#pragma HLS interface ap_fifo port = fifo_out._\n#pragma HLS aggregate variable = fifo_out._ bit\nvoid(fifo_out._.full());\n\n#pragma HLS disaggregate variable = q_gbc\n#pragma HLS interface ap_fifo port = q_gbc._\n#pragma HLS aggregate variable = q_gbc._ bit\n#pragma HLS interface ap_fifo port = q_gbc._peek\n#pragma HLS aggregate variable = q_gbc._peek bit\nvoid(q_gbc._.empty());\nvoid(q_gbc._peek.empty());\n\n#pragma HLS disaggregate variable = q_gbc_out\n#pragma HLS interface ap_fifo port = q_gbc_out._\n#pragma HLS aggregate variable = q_gbc_out._ bit\nvoid(q_gbc_out._.full());\n\n    //const int rp_time = (P_N == 0)? 1 : P_N;\n    const int num_pe_output = ((M + NUM_CH_SPARSE - 1) / NUM_CH_SPARSE) * NUM_CH_SPARSE_div_8;\n    const int num_out = (M + 7) >> 3;\n    const int num_ite_Y = num_pe_output * (rp_time + 1);\n    bool term_flag = false;\nl_rp:\n    for(int rp = -1; !term_flag & (rp < rp_time); rp++) {\n    aby:\n        for (int i = 0, c_idx = 0; i < num_pe_output;) {\n#pragma HLS loop_tripcount min=1 max=1800\n#pragma HLS pipeline II=1\n            if (!fifo_in[c_idx].empty() & !fifo_out.full()) {\n                double tmp; fifo_in[c_idx].try_read(tmp);\n                if (i < num_out) {\n                    fifo_out.try_write(tmp);\n                }\n                ++i;\n                c_idx++;\n                if (c_idx == NUM_CH_SPARSE_div_8) {c_idx = 0;}\n            }\n        }\n        ap_wait();\n        term_flag = q_gbc.read();\n        q_gbc_out.write(term_flag);\n    }\n    //cout << \"### exit Arbiter_Y\\n\";\n}\nvoid Merger_Y(tapa::istreams<double, 8> & fifo_in,\n              tapa::ostreams<double_v8, 2> & fifo_out) ;\ntemplate <typename data_t>\ninline void bh(tapa::istream<data_t> & q) {\n#pragma HLS inline\n    for (;;) {\n#pragma HLS pipeline II=1\n        data_t tmp; q.try_read(tmp);\n    }\n}\nvoid black_hole_int(tapa::istream<int> & fifo_in) ;\nvoid black_hole_double_v8(tapa::istream<double_v8> & fifo_in) ;\nvoid black_hole_bool(tapa::istream<bool> & fifo_in) ;\nvoid ctrl_P(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time, //P_N\n            const int M, //K,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_spmv,\n            tapa::ostream<double_v8> & q_dotp,\n            //tapa::ostream<double_v8> & q_updtx,\n            tapa::ostream<double_v8> & q_updtp,\n            tapa::istream<double_v8> & q_updated,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_AP(tapa::istream<double_v8> & qm_din,\n             tapa::ostream<double_v8> & qm_dout,\n             const int rp_time,\n             const int M,\n             tapa::ostream<InstRdWr> & q_inst,\n             tapa::ostream<double_v8> & q_updr,\n             tapa::istream<double_v8> & q_pe,\n             tapa::istream<bool> & q_res,\n             tapa::istream<bool> & q_gbc,\n             tapa::ostream<bool> & q_gbc_out\n             ) ;\nvoid ctrl_X(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_oldx,\n            tapa::istream<double_v8> & q_newx,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_R(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & qr_to_pe,\n            tapa::istream<double_v8> & qr_from_pe,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid read_digA(uint64_t  vec_mem,\n               const int rp_time, //P_N\n               const int M, //K,\n               tapa::ostream<double_v8> & q_dout,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n/*  computation modules  */\n//M2: alpha = rzold / (p' * Ap)\nvoid dot_alpha(const int rp_time,\n               const int M,\n               //const unsigned long rz0,\n               tapa::istream<double> & qrz,\n               tapa::istream<double_v8> & q1,\n               tapa::istream<double_v8> & q2,\n               tapa::ostreams<double, 2> & q3,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M end: res = r' * r\nvoid dot_res(const int rp_time,\n             const int M,\n             const double th_termination,\n             tapa::istream<double_v8> & q1,\n             tapa::ostream<ResTerm> & q2,\n             tapa::ostream<bool> & q_termination\n             ) ;\n//M6: rznew = r' * z\nvoid dot_rznew(const int rp_time,\n               const int M,\n               tapa::istream<double_v8> & qr,\n               tapa::istream<double_v8> & qz,\n               tapa::ostream<double_v8> & qr_out,\n               tapa::ostreams<double, 2> & qrz,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M3: x = x + alpha * p\nvoid updt_x(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qx,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M7: p = z + (rznew/rzold) * p\nvoid updt_p(const int rp_time,\n            const int M,\n            //const unsigned long rz0,\n            tapa::istream<double> & qrznew,\n            tapa::istream<double_v8> & qz,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qp2m3,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M4: r = r - alpha * Ap\nvoid updt_r(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qr,\n            tapa::istream<double_v8> & qap,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M5: z = diagA \\ r\nvoid left_div(const int rp_time,\n              const int M,\n              tapa::istream<double_v8> & qr,\n              tapa::istream<double_v8> & qdiagA,\n              tapa::ostreams<double_v8, 2> & qz,\n              tapa::ostream<double_v8> & qr_m6,\n              tapa::ostream<double_v8> & qrmem,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out\n              ) ;\nvoid wr_r(const int rp_time,\n          uint64_t  vec_r,\n          tapa::istream<ResTerm> & q_din\n          ) ;\nvoid duplicator(tapa::istream<double_v8> & q_in,\n                tapa::ostream<double_v8> & q_out1,\n                tapa::ostream<double_v8> & q_out2\n                ) ;\nvoid vecp_mux(const int rp_time,\n              const int M,\n              tapa::istream<bool> & q_gbc,\n              tapa::istream<double_v8> & q_in1,\n              tapa::istream<double_v8> & q_in2,\n              tapa::ostream<double_v8> & q_out\n              ) ;\nvoid Callipepla(uint64_t  edge_list_ptr,\n                uint64_t edge_list_ch_0, uint64_t edge_list_ch_1, uint64_t edge_list_ch_2, uint64_t edge_list_ch_3, uint64_t edge_list_ch_4, uint64_t edge_list_ch_5, uint64_t edge_list_ch_6, uint64_t edge_list_ch_7, uint64_t edge_list_ch_8, uint64_t edge_list_ch_9, uint64_t edge_list_ch_10, uint64_t edge_list_ch_11, uint64_t edge_list_ch_12, uint64_t edge_list_ch_13, uint64_t edge_list_ch_14, uint64_t edge_list_ch_15,\n                uint64_t vec_x_0, uint64_t vec_x_1,\n                uint64_t vec_p_0, uint64_t vec_p_1,\n                uint64_t  vec_Ap,\n                uint64_t vec_r_0, uint64_t vec_r_1,\n                uint64_t  vec_digA,\n                uint64_t  vec_res,\n                const int NUM_ITE,\n                const int NUM_A_LEN,\n                const int M,\n                const int rp_time,\n                const double th_termination\n                ) ;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "Callipepla": {
            "code": "\n\n #include <ap_int.h>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cassert>\n\n\n #include \"ap_utils.h\"\n\n#include <tapa.h>\n\n\n\n #include <ap_int.h>\n\n#include <tapa.h>\nconstexpr int NUM_CH_SPARSE = 16;\nconstexpr int X_PARTITION_FACTOR = 4; // BRAMs = 512 / 16 / 2 = 16 -> factor = 16 / (64 / 16)\nconstexpr int WINDOW_SIZE = X_PARTITION_FACTOR * 1024;\nconstexpr int DEP_DIST_LOAD_STORE = 7;\nconstexpr int URAM_DEPTH = 3 * 4096;\n// ch16: 3 * 4096 * 16 * 8 = 1,572,864\nusing double_v8 = tapa::vec_t<double, 8>;\nvoid Callipepla(tapa::mmap<int> edge_list_ptr,\n                tapa::mmaps<ap_uint<512>, NUM_CH_SPARSE> edge_list_ch,\n                tapa::mmaps<double_v8, 2> vec_x,\n                tapa::mmaps<double_v8, 2> vec_p,\n                tapa::mmap<double_v8> vec_Ap,\n                tapa::mmaps<double_v8, 2> vec_r,\n                tapa::mmap<double_v8> vec_digA,\n                tapa::mmap<double> vec_res,\n                const int NUM_ITE, const int NUM_A_LEN, const int M,\n                const int rp_time,\n                const double th_termination\n                );\n\nconstexpr int FIFO_DEPTH = 2;\nconstexpr int FIFO_DEPTH_M6 = 50;\nconst int NUM_CH_SPARSE_div_8 = NUM_CH_SPARSE / 8;\nconst int NUM_CH_SPARSE_mult_8 = NUM_CH_SPARSE * 8;\nconst int WINDOW_SIZE_div_8 = WINDOW_SIZE / 8;\nstruct MultXVec {\n    tapa::vec_t<ap_uint<18>, 8> row;\n    double_v8 axv;\n};\nstruct InstRdWr {\n    bool rd;\n    bool wr;\n    //bool require_response;\n    int base_addr;\n    int len;\n};\nstruct InstVCtrl {\n    bool rd;\n    bool wr;\n    int base_addr;\n    int len;\n    ap_uint<3> q_rd_idx;\n    //ap_uint<3> q_wr_idx;\n};\nstruct InstCmp {\n    int len;\n    double alpha;\n    ap_uint<3> q_idx;\n};\nstruct ResTerm {\n    double res;\n    bool term;\n};\ntemplate <typename T, typename R>\ninline void async_read(tapa::async_mmap<T> & A,\n                       tapa::ostream<T> & fifo_A,\n                       const R i_end_addr,\n                       R & i_req,\n                       R & i_resp) {\n#pragma HLS inline\n    if ((i_req < i_end_addr) &\n        !A.read_addr.full()) {\n        A.read_addr.try_write(i_req);\n        ++i_req;\n    }\n    if (!fifo_A.full() & !A.read_data.empty()) {\n        T tmp;\n        A.read_data.try_read(tmp);\n        fifo_A.try_write(tmp);\n        ++i_resp;\n    }\n}\ntemplate <typename T, typename R>\ninline void async_write(tapa::async_mmap<T> & Y_out,\n                        tapa::istream<T> & fifo_Y,\n                        const R num_ite_Y,\n                        R & i_req,\n                        R & i_resp\n                        ) {\n#pragma HLS inline\n    if ((i_req < num_ite_Y) &\n        !fifo_Y.empty() &\n        !Y_out.write_addr.full() &\n        !Y_out.write_data.full() ) {\n        Y_out.write_addr.try_write(i_req);\n        T tmpv;\n        fifo_Y.try_read(tmpv);\n        Y_out.write_data.try_write(tmpv);\n        ++i_req;\n    }\n    uint8_t n_resp;\n    if (Y_out.write_resp.try_read(n_resp)) {\n        i_resp += R(n_resp) + 1;\n    }\n}\nvoid rdwr_vec(uint64_t  vec_p,\n              tapa::istream<InstRdWr> & q_inst,\n              tapa::istream<double_v8> & q_din,\n              tapa::ostream<double_v8> & q_dout,\n              tapa::ostream<bool> & q_response\n              ) ;\ntemplate <typename data_t>\ninline void q2q(tapa::istream<data_t> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty() & !qout.full()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void clearq(tapa::istream<data_t> & qin,\n                   const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void q2q(tapa::istreams<data_t, 2> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite,\n                const int idx) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin[idx].empty() & !qout.full()) {\n            data_t tmp;\n            qin[idx].try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void qq2qq(tapa::istream<data_t> & qin_pe,\n                  tapa::ostreams<data_t, 2> & qout_mem,\n                  tapa::istreams<data_t, 2> & qin_mem,\n                  tapa::ostream<data_t> & qout_qe,\n                  const int num_ite,\n                  const int idx) {\n#pragma HLS inline\nqq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin_pe.empty() & !qout_mem[idx].full()) {\n            data_t tmp;\n            qin_pe.try_read(tmp);\n            qout_mem[idx].try_write(tmp);\n            ++i;\n        }\n        if (!qin_mem[1 - idx].empty() & !qout_qe.full()) {\n            data_t tmp;\n            qin_mem[1 - idx].try_read(tmp);\n            qout_qe.try_write(tmp);\n        }\n    }\n}\nvoid term_signal_router(tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_to_rdA,\n                        tapa::ostream<bool> & q_to_edgepointer,\n                        tapa::ostream<bool> & q_to_abiter,\n                        tapa::ostream<bool> & q_to_ctrlmem,\n                        tapa::ostream<bool> & q_to_mux\n                        ) ;\nvoid read_edge_list_ptr(const int num_ite,\n                        const int M,\n                        const int rp_time, //P_N,\n                        uint64_t  edge_list_ptr,\n                        tapa::ostream<int> & PE_inst,\n                        tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_gbc_out\n                        ) ;\nvoid read_vec(const int rp_time, //P_N\n              const int M, //K,\n              tapa::async_mmap<double_v8> & vec_X,\n              tapa::ostream<double_v8> & fifo_X\n              ) {\n    //const int rp_time = (P_N == 0)? 1 : P_N;\n    const int num_ite_X = (M + 7) >> 3;\nl_rp:\n    for(int rp = 0; rp < rp_time; rp++) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n    rd_X:\n        for(int i_req = 0, i_resp = 0; i_resp < num_ite_X;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n            async_read(vec_X,\n                       fifo_X,\n                       num_ite_X,\n                       i_req, i_resp);\n        }\n    }\n}\nvoid read_A(const int rp_time, //P_N,\n            const int A_len,\n            uint64_t  A,\n            tapa::ostream<ap_uint<512>> & fifo_A,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid PEG_Xvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<ap_uint<512>> & fifo_A,\n              tapa::istream<double_v8> & fifo_X_in,\n              tapa::ostream<int> & fifo_inst_out,\n              tapa::ostream<double_v8> & fifo_X_out,\n              // to PEG_Yvec\n              tapa::ostream<int> & fifo_inst_out_to_Yvec,\n              tapa::ostream<MultXVec> & fifo_aXvec,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out,\n              tapa::ostream<bool> & q_gbc_out_Y\n              ) ;\nvoid PEG_Yvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<MultXVec> & fifo_aXvec,\n              tapa::ostream<double> & fifo_Y_out,\n              tapa::istream<bool> & q_gbc\n              ) ;\nvoid Arbiter_Y(const int rp_time, //P_N,\n               const int M,\n               tapa::istreams<double, NUM_CH_SPARSE_div_8> & fifo_in, // 2 = 16 / 8\n               tapa::ostream<double> & fifo_out,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\nvoid Merger_Y(tapa::istreams<double, 8> & fifo_in,\n              tapa::ostreams<double_v8, 2> & fifo_out) ;\ntemplate <typename data_t>\ninline void bh(tapa::istream<data_t> & q) {\n#pragma HLS inline\n    for (;;) {\n#pragma HLS pipeline II=1\n        data_t tmp; q.try_read(tmp);\n    }\n}\nvoid black_hole_int(tapa::istream<int> & fifo_in) ;\nvoid black_hole_double_v8(tapa::istream<double_v8> & fifo_in) ;\nvoid black_hole_bool(tapa::istream<bool> & fifo_in) ;\nvoid ctrl_P(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time, //P_N\n            const int M, //K,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_spmv,\n            tapa::ostream<double_v8> & q_dotp,\n            //tapa::ostream<double_v8> & q_updtx,\n            tapa::ostream<double_v8> & q_updtp,\n            tapa::istream<double_v8> & q_updated,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_AP(tapa::istream<double_v8> & qm_din,\n             tapa::ostream<double_v8> & qm_dout,\n             const int rp_time,\n             const int M,\n             tapa::ostream<InstRdWr> & q_inst,\n             tapa::ostream<double_v8> & q_updr,\n             tapa::istream<double_v8> & q_pe,\n             tapa::istream<bool> & q_res,\n             tapa::istream<bool> & q_gbc,\n             tapa::ostream<bool> & q_gbc_out\n             ) ;\nvoid ctrl_X(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_oldx,\n            tapa::istream<double_v8> & q_newx,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_R(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & qr_to_pe,\n            tapa::istream<double_v8> & qr_from_pe,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid read_digA(uint64_t  vec_mem,\n               const int rp_time, //P_N\n               const int M, //K,\n               tapa::ostream<double_v8> & q_dout,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n/*  computation modules  */\n//M2: alpha = rzold / (p' * Ap)\nvoid dot_alpha(const int rp_time,\n               const int M,\n               //const unsigned long rz0,\n               tapa::istream<double> & qrz,\n               tapa::istream<double_v8> & q1,\n               tapa::istream<double_v8> & q2,\n               tapa::ostreams<double, 2> & q3,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M end: res = r' * r\nvoid dot_res(const int rp_time,\n             const int M,\n             const double th_termination,\n             tapa::istream<double_v8> & q1,\n             tapa::ostream<ResTerm> & q2,\n             tapa::ostream<bool> & q_termination\n             ) ;\n//M6: rznew = r' * z\nvoid dot_rznew(const int rp_time,\n               const int M,\n               tapa::istream<double_v8> & qr,\n               tapa::istream<double_v8> & qz,\n               tapa::ostream<double_v8> & qr_out,\n               tapa::ostreams<double, 2> & qrz,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M3: x = x + alpha * p\nvoid updt_x(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qx,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M7: p = z + (rznew/rzold) * p\nvoid updt_p(const int rp_time,\n            const int M,\n            //const unsigned long rz0,\n            tapa::istream<double> & qrznew,\n            tapa::istream<double_v8> & qz,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qp2m3,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M4: r = r - alpha * Ap\nvoid updt_r(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qr,\n            tapa::istream<double_v8> & qap,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M5: z = diagA \\ r\nvoid left_div(const int rp_time,\n              const int M,\n              tapa::istream<double_v8> & qr,\n              tapa::istream<double_v8> & qdiagA,\n              tapa::ostreams<double_v8, 2> & qz,\n              tapa::ostream<double_v8> & qr_m6,\n              tapa::ostream<double_v8> & qrmem,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out\n              ) ;\nvoid wr_r(const int rp_time,\n          uint64_t  vec_r,\n          tapa::istream<ResTerm> & q_din\n          ) ;\nvoid duplicator(tapa::istream<double_v8> & q_in,\n                tapa::ostream<double_v8> & q_out1,\n                tapa::ostream<double_v8> & q_out2\n                ) ;\nvoid vecp_mux(const int rp_time,\n              const int M,\n              tapa::istream<bool> & q_gbc,\n              tapa::istream<double_v8> & q_in1,\n              tapa::istream<double_v8> & q_in2,\n              tapa::ostream<double_v8> & q_out\n              ) ;\nextern \"C\" {\n\nvoid Callipepla(uint64_t  edge_list_ptr,\n                uint64_t edge_list_ch_0, uint64_t edge_list_ch_1, uint64_t edge_list_ch_2, uint64_t edge_list_ch_3, uint64_t edge_list_ch_4, uint64_t edge_list_ch_5, uint64_t edge_list_ch_6, uint64_t edge_list_ch_7, uint64_t edge_list_ch_8, uint64_t edge_list_ch_9, uint64_t edge_list_ch_10, uint64_t edge_list_ch_11, uint64_t edge_list_ch_12, uint64_t edge_list_ch_13, uint64_t edge_list_ch_14, uint64_t edge_list_ch_15,\n                uint64_t vec_x_0, uint64_t vec_x_1,\n                uint64_t vec_p_0, uint64_t vec_p_1,\n                uint64_t  vec_Ap,\n                uint64_t vec_r_0, uint64_t vec_r_1,\n                uint64_t  vec_digA,\n                uint64_t  vec_res,\n                const int NUM_ITE,\n                const int NUM_A_LEN,\n                const int M,\n                const int rp_time,\n                const double th_termination\n                ) {\n\n#pragma HLS interface s_axilite port = edge_list_ptr bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(edge_list_ptr); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(edge_list_ptr); }\n\n#pragma HLS interface s_axilite port = edge_list_ch_0 bundle = control\n#pragma HLS interface s_axilite port = edge_list_ch_1 bundle = control\n#pragma HLS interface s_axilite port = edge_list_ch_2 bundle = control\n#pragma HLS interface s_axilite port = edge_list_ch_3 bundle = control\n#pragma HLS interface s_axilite port = edge_list_ch_4 bundle = control\n#pragma HLS interface s_axilite port = edge_list_ch_5 bundle = control\n#pragma HLS interface s_axilite port = edge_list_ch_6 bundle = control\n#pragma HLS interface s_axilite port = edge_list_ch_7 bundle = control\n#pragma HLS interface s_axilite port = edge_list_ch_8 bundle = control\n#pragma HLS interface s_axilite port = edge_list_ch_9 bundle = control\n#pragma HLS interface s_axilite port = edge_list_ch_10 bundle = control\n#pragma HLS interface s_axilite port = edge_list_ch_11 bundle = control\n#pragma HLS interface s_axilite port = edge_list_ch_12 bundle = control\n#pragma HLS interface s_axilite port = edge_list_ch_13 bundle = control\n#pragma HLS interface s_axilite port = edge_list_ch_14 bundle = control\n#pragma HLS interface s_axilite port = edge_list_ch_15 bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(edge_list_ch_0); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(edge_list_ch_1); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(edge_list_ch_2); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(edge_list_ch_3); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(edge_list_ch_4); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(edge_list_ch_5); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(edge_list_ch_6); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(edge_list_ch_7); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(edge_list_ch_8); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(edge_list_ch_9); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(edge_list_ch_10); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(edge_list_ch_11); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(edge_list_ch_12); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(edge_list_ch_13); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(edge_list_ch_14); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(edge_list_ch_15); }\n\n#pragma HLS interface s_axilite port = vec_x_0 bundle = control\n#pragma HLS interface s_axilite port = vec_x_1 bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(vec_x_0); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(vec_x_1); }\n\n#pragma HLS interface s_axilite port = vec_p_0 bundle = control\n#pragma HLS interface s_axilite port = vec_p_1 bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(vec_p_0); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(vec_p_1); }\n\n#pragma HLS interface s_axilite port = vec_Ap bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(vec_Ap); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(vec_Ap); }\n\n#pragma HLS interface s_axilite port = vec_r_0 bundle = control\n#pragma HLS interface s_axilite port = vec_r_1 bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(vec_r_0); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(vec_r_1); }\n\n#pragma HLS interface s_axilite port = vec_digA bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(vec_digA); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(vec_digA); }\n\n#pragma HLS interface s_axilite port = vec_res bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(vec_res); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(vec_res); }\n\n#pragma HLS interface s_axilite port = NUM_ITE bundle = control\n{ auto val = reinterpret_cast<volatile const uint8_t&>(NUM_ITE); }\n\n#pragma HLS interface s_axilite port = NUM_A_LEN bundle = control\n{ auto val = reinterpret_cast<volatile const uint8_t&>(NUM_A_LEN); }\n\n#pragma HLS interface s_axilite port = M bundle = control\n{ auto val = reinterpret_cast<volatile const uint8_t&>(M); }\n\n#pragma HLS interface s_axilite port = rp_time bundle = control\n{ auto val = reinterpret_cast<volatile const uint8_t&>(rp_time); }\n\n#pragma HLS interface s_axilite port = th_termination bundle = control\n{ auto val = reinterpret_cast<volatile const uint8_t&>(th_termination); }\n\n\n#pragma HLS interface s_axilite port = return bundle = control\n}\n\n\n}  // extern \"C\"\n\n",
            "fifos": {
                "PE_inst_Callipepla[0]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_edge_list_ptr",
                        0
                    ]
                },
                "PE_inst_Callipepla[10]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        10
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        9
                    ]
                },
                "PE_inst_Callipepla[11]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        11
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        10
                    ]
                },
                "PE_inst_Callipepla[12]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        12
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        11
                    ]
                },
                "PE_inst_Callipepla[13]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        13
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        12
                    ]
                },
                "PE_inst_Callipepla[14]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        14
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        13
                    ]
                },
                "PE_inst_Callipepla[15]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        15
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        14
                    ]
                },
                "PE_inst_Callipepla[16]": {
                    "consumed_by": [
                        "black_hole_int",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        15
                    ]
                },
                "PE_inst_Callipepla[1]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        1
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        0
                    ]
                },
                "PE_inst_Callipepla[2]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        2
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        1
                    ]
                },
                "PE_inst_Callipepla[3]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        3
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        2
                    ]
                },
                "PE_inst_Callipepla[4]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        4
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        3
                    ]
                },
                "PE_inst_Callipepla[5]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        5
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        4
                    ]
                },
                "PE_inst_Callipepla[6]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        6
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        5
                    ]
                },
                "PE_inst_Callipepla[7]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        7
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        6
                    ]
                },
                "PE_inst_Callipepla[8]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        8
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        7
                    ]
                },
                "PE_inst_Callipepla[9]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        9
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        8
                    ]
                },
                "Yvec_inst_Callipepla[0]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        0
                    ]
                },
                "Yvec_inst_Callipepla[10]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        10
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        10
                    ]
                },
                "Yvec_inst_Callipepla[11]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        11
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        11
                    ]
                },
                "Yvec_inst_Callipepla[12]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        12
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        12
                    ]
                },
                "Yvec_inst_Callipepla[13]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        13
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        13
                    ]
                },
                "Yvec_inst_Callipepla[14]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        14
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        14
                    ]
                },
                "Yvec_inst_Callipepla[15]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        15
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        15
                    ]
                },
                "Yvec_inst_Callipepla[1]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        1
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        1
                    ]
                },
                "Yvec_inst_Callipepla[2]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        2
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        2
                    ]
                },
                "Yvec_inst_Callipepla[3]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        3
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        3
                    ]
                },
                "Yvec_inst_Callipepla[4]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        4
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        4
                    ]
                },
                "Yvec_inst_Callipepla[5]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        5
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        5
                    ]
                },
                "Yvec_inst_Callipepla[6]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        6
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        6
                    ]
                },
                "Yvec_inst_Callipepla[7]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        7
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        7
                    ]
                },
                "Yvec_inst_Callipepla[8]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        8
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        8
                    ]
                },
                "Yvec_inst_Callipepla[9]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        9
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        9
                    ]
                },
                "fifo_AP_Callipepla": {
                    "consumed_by": [
                        "updt_r",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "ctrl_AP",
                        0
                    ]
                },
                "fifo_AP_M1_Callipepla[0]": {
                    "consumed_by": [
                        "ctrl_AP",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "Merger_Y",
                        0
                    ]
                },
                "fifo_AP_M1_Callipepla[1]": {
                    "consumed_by": [
                        "dot_alpha",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "Merger_Y",
                        0
                    ]
                },
                "fifo_A_Callipepla[0]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_A",
                        0
                    ]
                },
                "fifo_A_Callipepla[10]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        10
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_A",
                        10
                    ]
                },
                "fifo_A_Callipepla[11]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        11
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_A",
                        11
                    ]
                },
                "fifo_A_Callipepla[12]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        12
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_A",
                        12
                    ]
                },
                "fifo_A_Callipepla[13]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        13
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_A",
                        13
                    ]
                },
                "fifo_A_Callipepla[14]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        14
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_A",
                        14
                    ]
                },
                "fifo_A_Callipepla[15]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        15
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_A",
                        15
                    ]
                },
                "fifo_A_Callipepla[1]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        1
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_A",
                        1
                    ]
                },
                "fifo_A_Callipepla[2]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        2
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_A",
                        2
                    ]
                },
                "fifo_A_Callipepla[3]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        3
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_A",
                        3
                    ]
                },
                "fifo_A_Callipepla[4]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        4
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_A",
                        4
                    ]
                },
                "fifo_A_Callipepla[5]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        5
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_A",
                        5
                    ]
                },
                "fifo_A_Callipepla[6]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        6
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_A",
                        6
                    ]
                },
                "fifo_A_Callipepla[7]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        7
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_A",
                        7
                    ]
                },
                "fifo_A_Callipepla[8]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        8
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_A",
                        8
                    ]
                },
                "fifo_A_Callipepla[9]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        9
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_A",
                        9
                    ]
                },
                "fifo_P_dot_Callipepla": {
                    "consumed_by": [
                        "dot_alpha",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "ctrl_P",
                        0
                    ]
                },
                "fifo_P_from_mem_Callipepla": {
                    "consumed_by": [
                        "vecp_mux",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "ctrl_P",
                        0
                    ]
                },
                "fifo_P_pe_Callipepla[0]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "vecp_mux",
                        0
                    ]
                },
                "fifo_P_pe_Callipepla[10]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        10
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        9
                    ]
                },
                "fifo_P_pe_Callipepla[11]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        11
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        10
                    ]
                },
                "fifo_P_pe_Callipepla[12]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        12
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        11
                    ]
                },
                "fifo_P_pe_Callipepla[13]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        13
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        12
                    ]
                },
                "fifo_P_pe_Callipepla[14]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        14
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        13
                    ]
                },
                "fifo_P_pe_Callipepla[15]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        15
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        14
                    ]
                },
                "fifo_P_pe_Callipepla[16]": {
                    "consumed_by": [
                        "black_hole_double_v8",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        15
                    ]
                },
                "fifo_P_pe_Callipepla[1]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        1
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        0
                    ]
                },
                "fifo_P_pe_Callipepla[2]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        2
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        1
                    ]
                },
                "fifo_P_pe_Callipepla[3]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        3
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        2
                    ]
                },
                "fifo_P_pe_Callipepla[4]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        4
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        3
                    ]
                },
                "fifo_P_pe_Callipepla[5]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        5
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        4
                    ]
                },
                "fifo_P_pe_Callipepla[6]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        6
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        5
                    ]
                },
                "fifo_P_pe_Callipepla[7]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        7
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        6
                    ]
                },
                "fifo_P_pe_Callipepla[8]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        8
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        7
                    ]
                },
                "fifo_P_pe_Callipepla[9]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        9
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        8
                    ]
                },
                "fifo_P_to_dup_Callipepla": {
                    "consumed_by": [
                        "duplicator",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "updt_p",
                        0
                    ]
                },
                "fifo_P_to_mux_Callipepla": {
                    "consumed_by": [
                        "vecp_mux",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "duplicator",
                        0
                    ]
                },
                "fifo_P_updated_Callipepla": {
                    "consumed_by": [
                        "ctrl_P",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "duplicator",
                        0
                    ]
                },
                "fifo_P_updtp_Callipepla": {
                    "consumed_by": [
                        "updt_p",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "ctrl_P",
                        0
                    ]
                },
                "fifo_P_updtx_Callipepla": {
                    "consumed_by": [
                        "updt_x",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "updt_p",
                        0
                    ]
                },
                "fifo_RR_Callipepla": {
                    "consumed_by": [
                        "wr_r",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "dot_res",
                        0
                    ]
                },
                "fifo_R_Callipepla": {
                    "consumed_by": [
                        "updt_r",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "ctrl_R",
                        0
                    ]
                },
                "fifo_R_tomem_Callipepla": {
                    "consumed_by": [
                        "ctrl_R",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "left_div",
                        0
                    ]
                },
                "fifo_R_updtd_m5_Callipepla": {
                    "consumed_by": [
                        "left_div",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "updt_r",
                        0
                    ]
                },
                "fifo_R_updtd_m6_Callipepla": {
                    "consumed_by": [
                        "dot_rznew",
                        0
                    ],
                    "depth": 50,
                    "produced_by": [
                        "left_div",
                        0
                    ]
                },
                "fifo_R_updtd_rr_Callipepla": {
                    "consumed_by": [
                        "dot_res",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "dot_rznew",
                        0
                    ]
                },
                "fifo_X_Callipepla": {
                    "consumed_by": [
                        "updt_x",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "ctrl_X",
                        0
                    ]
                },
                "fifo_X_updated_Callipepla": {
                    "consumed_by": [
                        "ctrl_X",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "updt_x",
                        0
                    ]
                },
                "fifo_Y_pe_Callipepla[0]": {
                    "consumed_by": [
                        "Arbiter_Y",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Yvec",
                        0
                    ]
                },
                "fifo_Y_pe_Callipepla[10]": {
                    "consumed_by": [
                        "Arbiter_Y",
                        5
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Yvec",
                        10
                    ]
                },
                "fifo_Y_pe_Callipepla[11]": {
                    "consumed_by": [
                        "Arbiter_Y",
                        5
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Yvec",
                        11
                    ]
                },
                "fifo_Y_pe_Callipepla[12]": {
                    "consumed_by": [
                        "Arbiter_Y",
                        6
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Yvec",
                        12
                    ]
                },
                "fifo_Y_pe_Callipepla[13]": {
                    "consumed_by": [
                        "Arbiter_Y",
                        6
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Yvec",
                        13
                    ]
                },
                "fifo_Y_pe_Callipepla[14]": {
                    "consumed_by": [
                        "Arbiter_Y",
                        7
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Yvec",
                        14
                    ]
                },
                "fifo_Y_pe_Callipepla[15]": {
                    "consumed_by": [
                        "Arbiter_Y",
                        7
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Yvec",
                        15
                    ]
                },
                "fifo_Y_pe_Callipepla[1]": {
                    "consumed_by": [
                        "Arbiter_Y",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Yvec",
                        1
                    ]
                },
                "fifo_Y_pe_Callipepla[2]": {
                    "consumed_by": [
                        "Arbiter_Y",
                        1
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Yvec",
                        2
                    ]
                },
                "fifo_Y_pe_Callipepla[3]": {
                    "consumed_by": [
                        "Arbiter_Y",
                        1
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Yvec",
                        3
                    ]
                },
                "fifo_Y_pe_Callipepla[4]": {
                    "consumed_by": [
                        "Arbiter_Y",
                        2
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Yvec",
                        4
                    ]
                },
                "fifo_Y_pe_Callipepla[5]": {
                    "consumed_by": [
                        "Arbiter_Y",
                        2
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Yvec",
                        5
                    ]
                },
                "fifo_Y_pe_Callipepla[6]": {
                    "consumed_by": [
                        "Arbiter_Y",
                        3
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Yvec",
                        6
                    ]
                },
                "fifo_Y_pe_Callipepla[7]": {
                    "consumed_by": [
                        "Arbiter_Y",
                        3
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Yvec",
                        7
                    ]
                },
                "fifo_Y_pe_Callipepla[8]": {
                    "consumed_by": [
                        "Arbiter_Y",
                        4
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Yvec",
                        8
                    ]
                },
                "fifo_Y_pe_Callipepla[9]": {
                    "consumed_by": [
                        "Arbiter_Y",
                        4
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Yvec",
                        9
                    ]
                },
                "fifo_Y_pe_abd_Callipepla[0]": {
                    "consumed_by": [
                        "Merger_Y",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "Arbiter_Y",
                        0
                    ]
                },
                "fifo_Y_pe_abd_Callipepla[1]": {
                    "consumed_by": [
                        "Merger_Y",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "Arbiter_Y",
                        1
                    ]
                },
                "fifo_Y_pe_abd_Callipepla[2]": {
                    "consumed_by": [
                        "Merger_Y",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "Arbiter_Y",
                        2
                    ]
                },
                "fifo_Y_pe_abd_Callipepla[3]": {
                    "consumed_by": [
                        "Merger_Y",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "Arbiter_Y",
                        3
                    ]
                },
                "fifo_Y_pe_abd_Callipepla[4]": {
                    "consumed_by": [
                        "Merger_Y",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "Arbiter_Y",
                        4
                    ]
                },
                "fifo_Y_pe_abd_Callipepla[5]": {
                    "consumed_by": [
                        "Merger_Y",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "Arbiter_Y",
                        5
                    ]
                },
                "fifo_Y_pe_abd_Callipepla[6]": {
                    "consumed_by": [
                        "Merger_Y",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "Arbiter_Y",
                        6
                    ]
                },
                "fifo_Y_pe_abd_Callipepla[7]": {
                    "consumed_by": [
                        "Merger_Y",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "Arbiter_Y",
                        7
                    ]
                },
                "fifo_Z_Callipepla[0]": {
                    "consumed_by": [
                        "dot_rznew",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "left_div",
                        0
                    ]
                },
                "fifo_Z_Callipepla[1]": {
                    "consumed_by": [
                        "updt_p",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "left_div",
                        0
                    ]
                },
                "fifo_aXvec_Callipepla[0]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        0
                    ]
                },
                "fifo_aXvec_Callipepla[10]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        10
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        10
                    ]
                },
                "fifo_aXvec_Callipepla[11]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        11
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        11
                    ]
                },
                "fifo_aXvec_Callipepla[12]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        12
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        12
                    ]
                },
                "fifo_aXvec_Callipepla[13]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        13
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        13
                    ]
                },
                "fifo_aXvec_Callipepla[14]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        14
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        14
                    ]
                },
                "fifo_aXvec_Callipepla[15]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        15
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        15
                    ]
                },
                "fifo_aXvec_Callipepla[1]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        1
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        1
                    ]
                },
                "fifo_aXvec_Callipepla[2]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        2
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        2
                    ]
                },
                "fifo_aXvec_Callipepla[3]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        3
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        3
                    ]
                },
                "fifo_aXvec_Callipepla[4]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        4
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        4
                    ]
                },
                "fifo_aXvec_Callipepla[5]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        5
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        5
                    ]
                },
                "fifo_aXvec_Callipepla[6]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        6
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        6
                    ]
                },
                "fifo_aXvec_Callipepla[7]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        7
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        7
                    ]
                },
                "fifo_aXvec_Callipepla[8]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        8
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        8
                    ]
                },
                "fifo_aXvec_Callipepla[9]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        9
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        9
                    ]
                },
                "fifo_alpha_Callipepla[0]": {
                    "consumed_by": [
                        "updt_x",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "dot_alpha",
                        0
                    ]
                },
                "fifo_alpha_Callipepla[1]": {
                    "consumed_by": [
                        "updt_r",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "dot_alpha",
                        0
                    ]
                },
                "fifo_dA_Callipepla": {
                    "consumed_by": [
                        "left_div",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_digA",
                        0
                    ]
                },
                "fifo_din_AP_Callipepla": {
                    "consumed_by": [
                        "ctrl_AP",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "rdwr_vec",
                        6
                    ]
                },
                "fifo_din_P_Callipepla[0]": {
                    "consumed_by": [
                        "ctrl_P",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "rdwr_vec",
                        0
                    ]
                },
                "fifo_din_P_Callipepla[1]": {
                    "consumed_by": [
                        "ctrl_P",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "rdwr_vec",
                        1
                    ]
                },
                "fifo_din_R_Callipepla[0]": {
                    "consumed_by": [
                        "ctrl_R",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "rdwr_vec",
                        2
                    ]
                },
                "fifo_din_R_Callipepla[1]": {
                    "consumed_by": [
                        "ctrl_R",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "rdwr_vec",
                        3
                    ]
                },
                "fifo_din_X_Callipepla[0]": {
                    "consumed_by": [
                        "ctrl_X",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "rdwr_vec",
                        4
                    ]
                },
                "fifo_din_X_Callipepla[1]": {
                    "consumed_by": [
                        "ctrl_X",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "rdwr_vec",
                        5
                    ]
                },
                "fifo_dout_AP_Callipepla": {
                    "consumed_by": [
                        "rdwr_vec",
                        6
                    ],
                    "depth": 2,
                    "produced_by": [
                        "ctrl_AP",
                        0
                    ]
                },
                "fifo_dout_P_Callipepla[0]": {
                    "consumed_by": [
                        "rdwr_vec",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "ctrl_P",
                        0
                    ]
                },
                "fifo_dout_P_Callipepla[1]": {
                    "consumed_by": [
                        "rdwr_vec",
                        1
                    ],
                    "depth": 2,
                    "produced_by": [
                        "ctrl_P",
                        0
                    ]
                },
                "fifo_dout_R_Callipepla[0]": {
                    "consumed_by": [
                        "rdwr_vec",
                        2
                    ],
                    "depth": 2,
                    "produced_by": [
                        "ctrl_R",
                        0
                    ]
                },
                "fifo_dout_R_Callipepla[1]": {
                    "consumed_by": [
                        "rdwr_vec",
                        3
                    ],
                    "depth": 2,
                    "produced_by": [
                        "ctrl_R",
                        0
                    ]
                },
                "fifo_dout_X_Callipepla[0]": {
                    "consumed_by": [
                        "rdwr_vec",
                        4
                    ],
                    "depth": 2,
                    "produced_by": [
                        "ctrl_X",
                        0
                    ]
                },
                "fifo_dout_X_Callipepla[1]": {
                    "consumed_by": [
                        "rdwr_vec",
                        5
                    ],
                    "depth": 2,
                    "produced_by": [
                        "ctrl_X",
                        0
                    ]
                },
                "fifo_mi_AP_Callipepla": {
                    "consumed_by": [
                        "rdwr_vec",
                        6
                    ],
                    "depth": 2,
                    "produced_by": [
                        "ctrl_AP",
                        0
                    ]
                },
                "fifo_mi_P_Callipepla[0]": {
                    "consumed_by": [
                        "rdwr_vec",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "ctrl_P",
                        0
                    ]
                },
                "fifo_mi_P_Callipepla[1]": {
                    "consumed_by": [
                        "rdwr_vec",
                        1
                    ],
                    "depth": 2,
                    "produced_by": [
                        "ctrl_P",
                        0
                    ]
                },
                "fifo_mi_R_Callipepla[0]": {
                    "consumed_by": [
                        "rdwr_vec",
                        2
                    ],
                    "depth": 2,
                    "produced_by": [
                        "ctrl_R",
                        0
                    ]
                },
                "fifo_mi_R_Callipepla[1]": {
                    "consumed_by": [
                        "rdwr_vec",
                        3
                    ],
                    "depth": 2,
                    "produced_by": [
                        "ctrl_R",
                        0
                    ]
                },
                "fifo_mi_X_Callipepla[0]": {
                    "consumed_by": [
                        "rdwr_vec",
                        4
                    ],
                    "depth": 2,
                    "produced_by": [
                        "ctrl_X",
                        0
                    ]
                },
                "fifo_mi_X_Callipepla[1]": {
                    "consumed_by": [
                        "rdwr_vec",
                        5
                    ],
                    "depth": 2,
                    "produced_by": [
                        "ctrl_X",
                        0
                    ]
                },
                "fifo_resp_AP_Callipepla": {
                    "consumed_by": [
                        "ctrl_AP",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "rdwr_vec",
                        6
                    ]
                },
                "fifo_resp_P_Callipepla[0]": {
                    "consumed_by": [
                        "ctrl_P",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "rdwr_vec",
                        0
                    ]
                },
                "fifo_resp_P_Callipepla[1]": {
                    "consumed_by": [
                        "ctrl_P",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "rdwr_vec",
                        1
                    ]
                },
                "fifo_resp_R_Callipepla[0]": {
                    "consumed_by": [
                        "ctrl_R",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "rdwr_vec",
                        2
                    ]
                },
                "fifo_resp_R_Callipepla[1]": {
                    "consumed_by": [
                        "ctrl_R",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "rdwr_vec",
                        3
                    ]
                },
                "fifo_resp_X_Callipepla[0]": {
                    "consumed_by": [
                        "ctrl_X",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "rdwr_vec",
                        4
                    ]
                },
                "fifo_resp_X_Callipepla[1]": {
                    "consumed_by": [
                        "ctrl_X",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "rdwr_vec",
                        5
                    ]
                },
                "fifo_rz_Callipepla[0]": {
                    "consumed_by": [
                        "dot_alpha",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "dot_rznew",
                        0
                    ]
                },
                "fifo_rz_Callipepla[1]": {
                    "consumed_by": [
                        "updt_p",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "dot_rznew",
                        0
                    ]
                },
                "tsignal_Y_Callipepla[0]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        0
                    ]
                },
                "tsignal_Y_Callipepla[10]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        10
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        10
                    ]
                },
                "tsignal_Y_Callipepla[11]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        11
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        11
                    ]
                },
                "tsignal_Y_Callipepla[12]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        12
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        12
                    ]
                },
                "tsignal_Y_Callipepla[13]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        13
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        13
                    ]
                },
                "tsignal_Y_Callipepla[14]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        14
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        14
                    ]
                },
                "tsignal_Y_Callipepla[15]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        15
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        15
                    ]
                },
                "tsignal_Y_Callipepla[1]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        1
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        1
                    ]
                },
                "tsignal_Y_Callipepla[2]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        2
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        2
                    ]
                },
                "tsignal_Y_Callipepla[3]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        3
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        3
                    ]
                },
                "tsignal_Y_Callipepla[4]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        4
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        4
                    ]
                },
                "tsignal_Y_Callipepla[5]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        5
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        5
                    ]
                },
                "tsignal_Y_Callipepla[6]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        6
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        6
                    ]
                },
                "tsignal_Y_Callipepla[7]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        7
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        7
                    ]
                },
                "tsignal_Y_Callipepla[8]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        8
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        8
                    ]
                },
                "tsignal_Y_Callipepla[9]": {
                    "consumed_by": [
                        "PEG_Yvec",
                        9
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        9
                    ]
                },
                "tsignal_aby_Callipepla[0]": {
                    "consumed_by": [
                        "Arbiter_Y",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "term_signal_router",
                        0
                    ]
                },
                "tsignal_aby_Callipepla[1]": {
                    "consumed_by": [
                        "Arbiter_Y",
                        1
                    ],
                    "depth": 2,
                    "produced_by": [
                        "Arbiter_Y",
                        0
                    ]
                },
                "tsignal_aby_Callipepla[2]": {
                    "consumed_by": [
                        "Arbiter_Y",
                        2
                    ],
                    "depth": 2,
                    "produced_by": [
                        "Arbiter_Y",
                        1
                    ]
                },
                "tsignal_aby_Callipepla[3]": {
                    "consumed_by": [
                        "Arbiter_Y",
                        3
                    ],
                    "depth": 2,
                    "produced_by": [
                        "Arbiter_Y",
                        2
                    ]
                },
                "tsignal_aby_Callipepla[4]": {
                    "consumed_by": [
                        "Arbiter_Y",
                        4
                    ],
                    "depth": 2,
                    "produced_by": [
                        "Arbiter_Y",
                        3
                    ]
                },
                "tsignal_aby_Callipepla[5]": {
                    "consumed_by": [
                        "Arbiter_Y",
                        5
                    ],
                    "depth": 2,
                    "produced_by": [
                        "Arbiter_Y",
                        4
                    ]
                },
                "tsignal_aby_Callipepla[6]": {
                    "consumed_by": [
                        "Arbiter_Y",
                        6
                    ],
                    "depth": 2,
                    "produced_by": [
                        "Arbiter_Y",
                        5
                    ]
                },
                "tsignal_aby_Callipepla[7]": {
                    "consumed_by": [
                        "Arbiter_Y",
                        7
                    ],
                    "depth": 2,
                    "produced_by": [
                        "Arbiter_Y",
                        6
                    ]
                },
                "tsignal_aby_Callipepla[8]": {
                    "consumed_by": [
                        "dot_alpha",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "Arbiter_Y",
                        7
                    ]
                },
                "tsignal_ctrlAP_Callipepla": {
                    "consumed_by": [
                        "ctrl_AP",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "ctrl_P",
                        0
                    ]
                },
                "tsignal_ctrlP_Callipepla": {
                    "consumed_by": [
                        "ctrl_P",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "term_signal_router",
                        0
                    ]
                },
                "tsignal_ctrlR_Callipepla": {
                    "consumed_by": [
                        "ctrl_R",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_digA",
                        0
                    ]
                },
                "tsignal_ctrlX_Callipepla": {
                    "consumed_by": [
                        "ctrl_X",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "ctrl_R",
                        0
                    ]
                },
                "tsignal_ctrldigA_Callipepla": {
                    "consumed_by": [
                        "read_digA",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "ctrl_AP",
                        0
                    ]
                },
                "tsignal_edgepointer_Callipepla[0]": {
                    "consumed_by": [
                        "read_edge_list_ptr",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "term_signal_router",
                        0
                    ]
                },
                "tsignal_edgepointer_Callipepla[10]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        9
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        8
                    ]
                },
                "tsignal_edgepointer_Callipepla[11]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        10
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        9
                    ]
                },
                "tsignal_edgepointer_Callipepla[12]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        11
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        10
                    ]
                },
                "tsignal_edgepointer_Callipepla[13]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        12
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        11
                    ]
                },
                "tsignal_edgepointer_Callipepla[14]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        13
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        12
                    ]
                },
                "tsignal_edgepointer_Callipepla[15]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        14
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        13
                    ]
                },
                "tsignal_edgepointer_Callipepla[16]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        15
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        14
                    ]
                },
                "tsignal_edgepointer_Callipepla[17]": {
                    "consumed_by": [
                        "black_hole_bool",
                        1
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        15
                    ]
                },
                "tsignal_edgepointer_Callipepla[1]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_edge_list_ptr",
                        0
                    ]
                },
                "tsignal_edgepointer_Callipepla[2]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        1
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        0
                    ]
                },
                "tsignal_edgepointer_Callipepla[3]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        2
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        1
                    ]
                },
                "tsignal_edgepointer_Callipepla[4]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        3
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        2
                    ]
                },
                "tsignal_edgepointer_Callipepla[5]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        4
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        3
                    ]
                },
                "tsignal_edgepointer_Callipepla[6]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        5
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        4
                    ]
                },
                "tsignal_edgepointer_Callipepla[7]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        6
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        5
                    ]
                },
                "tsignal_edgepointer_Callipepla[8]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        7
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        6
                    ]
                },
                "tsignal_edgepointer_Callipepla[9]": {
                    "consumed_by": [
                        "PEG_Xvec",
                        8
                    ],
                    "depth": 2,
                    "produced_by": [
                        "PEG_Xvec",
                        7
                    ]
                },
                "tsignal_mux_Callipepla": {
                    "consumed_by": [
                        "vecp_mux",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "term_signal_router",
                        0
                    ]
                },
                "tsignal_rdA_Callipepla[0]": {
                    "consumed_by": [
                        "read_A",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "term_signal_router",
                        0
                    ]
                },
                "tsignal_rdA_Callipepla[10]": {
                    "consumed_by": [
                        "read_A",
                        10
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_A",
                        9
                    ]
                },
                "tsignal_rdA_Callipepla[11]": {
                    "consumed_by": [
                        "read_A",
                        11
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_A",
                        10
                    ]
                },
                "tsignal_rdA_Callipepla[12]": {
                    "consumed_by": [
                        "read_A",
                        12
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_A",
                        11
                    ]
                },
                "tsignal_rdA_Callipepla[13]": {
                    "consumed_by": [
                        "read_A",
                        13
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_A",
                        12
                    ]
                },
                "tsignal_rdA_Callipepla[14]": {
                    "consumed_by": [
                        "read_A",
                        14
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_A",
                        13
                    ]
                },
                "tsignal_rdA_Callipepla[15]": {
                    "consumed_by": [
                        "read_A",
                        15
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_A",
                        14
                    ]
                },
                "tsignal_rdA_Callipepla[16]": {
                    "consumed_by": [
                        "black_hole_bool",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_A",
                        15
                    ]
                },
                "tsignal_rdA_Callipepla[1]": {
                    "consumed_by": [
                        "read_A",
                        1
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_A",
                        0
                    ]
                },
                "tsignal_rdA_Callipepla[2]": {
                    "consumed_by": [
                        "read_A",
                        2
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_A",
                        1
                    ]
                },
                "tsignal_rdA_Callipepla[3]": {
                    "consumed_by": [
                        "read_A",
                        3
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_A",
                        2
                    ]
                },
                "tsignal_rdA_Callipepla[4]": {
                    "consumed_by": [
                        "read_A",
                        4
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_A",
                        3
                    ]
                },
                "tsignal_rdA_Callipepla[5]": {
                    "consumed_by": [
                        "read_A",
                        5
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_A",
                        4
                    ]
                },
                "tsignal_rdA_Callipepla[6]": {
                    "consumed_by": [
                        "read_A",
                        6
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_A",
                        5
                    ]
                },
                "tsignal_rdA_Callipepla[7]": {
                    "consumed_by": [
                        "read_A",
                        7
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_A",
                        6
                    ]
                },
                "tsignal_rdA_Callipepla[8]": {
                    "consumed_by": [
                        "read_A",
                        8
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_A",
                        7
                    ]
                },
                "tsignal_rdA_Callipepla[9]": {
                    "consumed_by": [
                        "read_A",
                        9
                    ],
                    "depth": 2,
                    "produced_by": [
                        "read_A",
                        8
                    ]
                },
                "tsignal_res_Callipepla": {
                    "consumed_by": [
                        "term_signal_router",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "dot_res",
                        0
                    ]
                },
                "tsignal_toM3_Callipepla": {
                    "consumed_by": [
                        "updt_x",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "updt_p",
                        0
                    ]
                },
                "tsignal_toM4_Callipepla": {
                    "consumed_by": [
                        "updt_r",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "dot_alpha",
                        0
                    ]
                },
                "tsignal_toM5_Callipepla": {
                    "consumed_by": [
                        "left_div",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "updt_r",
                        0
                    ]
                },
                "tsignal_toM6_Callipepla": {
                    "consumed_by": [
                        "dot_rznew",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "left_div",
                        0
                    ]
                },
                "tsignal_toM7_Callipepla": {
                    "consumed_by": [
                        "updt_p",
                        0
                    ],
                    "depth": 2,
                    "produced_by": [
                        "dot_rznew",
                        0
                    ]
                }
            },
            "frt_interface": "#include <sstream>\n#include <stdexcept>\n#include <frt.h>\n\n\n\n #include <ap_int.h>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cassert>\n\n\n #include \"ap_utils.h\"\n\n#include <tapa.h>\n\n\n\n #include <ap_int.h>\n\n#include <tapa.h>\nconstexpr int NUM_CH_SPARSE = 16;\nconstexpr int X_PARTITION_FACTOR = 4; // BRAMs = 512 / 16 / 2 = 16 -> factor = 16 / (64 / 16)\nconstexpr int WINDOW_SIZE = X_PARTITION_FACTOR * 1024;\nconstexpr int DEP_DIST_LOAD_STORE = 7;\nconstexpr int URAM_DEPTH = 3 * 4096;\n// ch16: 3 * 4096 * 16 * 8 = 1,572,864\nusing double_v8 = tapa::vec_t<double, 8>;\nvoid Callipepla(tapa::mmap<int> edge_list_ptr,\n                tapa::mmaps<ap_uint<512>, NUM_CH_SPARSE> edge_list_ch,\n                tapa::mmaps<double_v8, 2> vec_x,\n                tapa::mmaps<double_v8, 2> vec_p,\n                tapa::mmap<double_v8> vec_Ap,\n                tapa::mmaps<double_v8, 2> vec_r,\n                tapa::mmap<double_v8> vec_digA,\n                tapa::mmap<double> vec_res,\n                const int NUM_ITE, const int NUM_A_LEN, const int M,\n                const int rp_time,\n                const double th_termination\n                );\n\nconstexpr int FIFO_DEPTH = 2;\nconstexpr int FIFO_DEPTH_M6 = 50;\nconst int NUM_CH_SPARSE_div_8 = NUM_CH_SPARSE / 8;\nconst int NUM_CH_SPARSE_mult_8 = NUM_CH_SPARSE * 8;\nconst int WINDOW_SIZE_div_8 = WINDOW_SIZE / 8;\nstruct MultXVec {\n    tapa::vec_t<ap_uint<18>, 8> row;\n    double_v8 axv;\n};\nstruct InstRdWr {\n    bool rd;\n    bool wr;\n    //bool require_response;\n    int base_addr;\n    int len;\n};\nstruct InstVCtrl {\n    bool rd;\n    bool wr;\n    int base_addr;\n    int len;\n    ap_uint<3> q_rd_idx;\n    //ap_uint<3> q_wr_idx;\n};\nstruct InstCmp {\n    int len;\n    double alpha;\n    ap_uint<3> q_idx;\n};\nstruct ResTerm {\n    double res;\n    bool term;\n};\ntemplate <typename T, typename R>\ninline void async_read(tapa::async_mmap<T> & A,\n                       tapa::ostream<T> & fifo_A,\n                       const R i_end_addr,\n                       R & i_req,\n                       R & i_resp) {\n#pragma HLS inline\n    if ((i_req < i_end_addr) &\n        !A.read_addr.full()) {\n        A.read_addr.try_write(i_req);\n        ++i_req;\n    }\n    if (!fifo_A.full() & !A.read_data.empty()) {\n        T tmp;\n        A.read_data.try_read(tmp);\n        fifo_A.try_write(tmp);\n        ++i_resp;\n    }\n}\ntemplate <typename T, typename R>\ninline void async_write(tapa::async_mmap<T> & Y_out,\n                        tapa::istream<T> & fifo_Y,\n                        const R num_ite_Y,\n                        R & i_req,\n                        R & i_resp\n                        ) {\n#pragma HLS inline\n    if ((i_req < num_ite_Y) &\n        !fifo_Y.empty() &\n        !Y_out.write_addr.full() &\n        !Y_out.write_data.full() ) {\n        Y_out.write_addr.try_write(i_req);\n        T tmpv;\n        fifo_Y.try_read(tmpv);\n        Y_out.write_data.try_write(tmpv);\n        ++i_req;\n    }\n    uint8_t n_resp;\n    if (Y_out.write_resp.try_read(n_resp)) {\n        i_resp += R(n_resp) + 1;\n    }\n}\nvoid rdwr_vec(uint64_t  vec_p,\n              tapa::istream<InstRdWr> & q_inst,\n              tapa::istream<double_v8> & q_din,\n              tapa::ostream<double_v8> & q_dout,\n              tapa::ostream<bool> & q_response\n              ) ;\ntemplate <typename data_t>\ninline void q2q(tapa::istream<data_t> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty() & !qout.full()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void clearq(tapa::istream<data_t> & qin,\n                   const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void q2q(tapa::istreams<data_t, 2> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite,\n                const int idx) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin[idx].empty() & !qout.full()) {\n            data_t tmp;\n            qin[idx].try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void qq2qq(tapa::istream<data_t> & qin_pe,\n                  tapa::ostreams<data_t, 2> & qout_mem,\n                  tapa::istreams<data_t, 2> & qin_mem,\n                  tapa::ostream<data_t> & qout_qe,\n                  const int num_ite,\n                  const int idx) {\n#pragma HLS inline\nqq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin_pe.empty() & !qout_mem[idx].full()) {\n            data_t tmp;\n            qin_pe.try_read(tmp);\n            qout_mem[idx].try_write(tmp);\n            ++i;\n        }\n        if (!qin_mem[1 - idx].empty() & !qout_qe.full()) {\n            data_t tmp;\n            qin_mem[1 - idx].try_read(tmp);\n            qout_qe.try_write(tmp);\n        }\n    }\n}\nvoid term_signal_router(tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_to_rdA,\n                        tapa::ostream<bool> & q_to_edgepointer,\n                        tapa::ostream<bool> & q_to_abiter,\n                        tapa::ostream<bool> & q_to_ctrlmem,\n                        tapa::ostream<bool> & q_to_mux\n                        ) ;\nvoid read_edge_list_ptr(const int num_ite,\n                        const int M,\n                        const int rp_time, //P_N,\n                        uint64_t  edge_list_ptr,\n                        tapa::ostream<int> & PE_inst,\n                        tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_gbc_out\n                        ) ;\nvoid read_vec(const int rp_time, //P_N\n              const int M, //K,\n              tapa::async_mmap<double_v8> & vec_X,\n              tapa::ostream<double_v8> & fifo_X\n              ) {\n    //const int rp_time = (P_N == 0)? 1 : P_N;\n    const int num_ite_X = (M + 7) >> 3;\nl_rp:\n    for(int rp = 0; rp < rp_time; rp++) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n    rd_X:\n        for(int i_req = 0, i_resp = 0; i_resp < num_ite_X;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n            async_read(vec_X,\n                       fifo_X,\n                       num_ite_X,\n                       i_req, i_resp);\n        }\n    }\n}\nvoid read_A(const int rp_time, //P_N,\n            const int A_len,\n            uint64_t  A,\n            tapa::ostream<ap_uint<512>> & fifo_A,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid PEG_Xvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<ap_uint<512>> & fifo_A,\n              tapa::istream<double_v8> & fifo_X_in,\n              tapa::ostream<int> & fifo_inst_out,\n              tapa::ostream<double_v8> & fifo_X_out,\n              // to PEG_Yvec\n              tapa::ostream<int> & fifo_inst_out_to_Yvec,\n              tapa::ostream<MultXVec> & fifo_aXvec,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out,\n              tapa::ostream<bool> & q_gbc_out_Y\n              ) ;\nvoid PEG_Yvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<MultXVec> & fifo_aXvec,\n              tapa::ostream<double> & fifo_Y_out,\n              tapa::istream<bool> & q_gbc\n              ) ;\nvoid Arbiter_Y(const int rp_time, //P_N,\n               const int M,\n               tapa::istreams<double, NUM_CH_SPARSE_div_8> & fifo_in, // 2 = 16 / 8\n               tapa::ostream<double> & fifo_out,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\nvoid Merger_Y(tapa::istreams<double, 8> & fifo_in,\n              tapa::ostreams<double_v8, 2> & fifo_out) ;\ntemplate <typename data_t>\ninline void bh(tapa::istream<data_t> & q) {\n#pragma HLS inline\n    for (;;) {\n#pragma HLS pipeline II=1\n        data_t tmp; q.try_read(tmp);\n    }\n}\nvoid black_hole_int(tapa::istream<int> & fifo_in) ;\nvoid black_hole_double_v8(tapa::istream<double_v8> & fifo_in) ;\nvoid black_hole_bool(tapa::istream<bool> & fifo_in) ;\nvoid ctrl_P(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time, //P_N\n            const int M, //K,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_spmv,\n            tapa::ostream<double_v8> & q_dotp,\n            //tapa::ostream<double_v8> & q_updtx,\n            tapa::ostream<double_v8> & q_updtp,\n            tapa::istream<double_v8> & q_updated,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_AP(tapa::istream<double_v8> & qm_din,\n             tapa::ostream<double_v8> & qm_dout,\n             const int rp_time,\n             const int M,\n             tapa::ostream<InstRdWr> & q_inst,\n             tapa::ostream<double_v8> & q_updr,\n             tapa::istream<double_v8> & q_pe,\n             tapa::istream<bool> & q_res,\n             tapa::istream<bool> & q_gbc,\n             tapa::ostream<bool> & q_gbc_out\n             ) ;\nvoid ctrl_X(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_oldx,\n            tapa::istream<double_v8> & q_newx,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_R(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & qr_to_pe,\n            tapa::istream<double_v8> & qr_from_pe,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid read_digA(uint64_t  vec_mem,\n               const int rp_time, //P_N\n               const int M, //K,\n               tapa::ostream<double_v8> & q_dout,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n/*  computation modules  */\n//M2: alpha = rzold / (p' * Ap)\nvoid dot_alpha(const int rp_time,\n               const int M,\n               //const unsigned long rz0,\n               tapa::istream<double> & qrz,\n               tapa::istream<double_v8> & q1,\n               tapa::istream<double_v8> & q2,\n               tapa::ostreams<double, 2> & q3,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M end: res = r' * r\nvoid dot_res(const int rp_time,\n             const int M,\n             const double th_termination,\n             tapa::istream<double_v8> & q1,\n             tapa::ostream<ResTerm> & q2,\n             tapa::ostream<bool> & q_termination\n             ) ;\n//M6: rznew = r' * z\nvoid dot_rznew(const int rp_time,\n               const int M,\n               tapa::istream<double_v8> & qr,\n               tapa::istream<double_v8> & qz,\n               tapa::ostream<double_v8> & qr_out,\n               tapa::ostreams<double, 2> & qrz,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M3: x = x + alpha * p\nvoid updt_x(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qx,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M7: p = z + (rznew/rzold) * p\nvoid updt_p(const int rp_time,\n            const int M,\n            //const unsigned long rz0,\n            tapa::istream<double> & qrznew,\n            tapa::istream<double_v8> & qz,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qp2m3,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M4: r = r - alpha * Ap\nvoid updt_r(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qr,\n            tapa::istream<double_v8> & qap,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M5: z = diagA \\ r\nvoid left_div(const int rp_time,\n              const int M,\n              tapa::istream<double_v8> & qr,\n              tapa::istream<double_v8> & qdiagA,\n              tapa::ostreams<double_v8, 2> & qz,\n              tapa::ostream<double_v8> & qr_m6,\n              tapa::ostream<double_v8> & qrmem,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out\n              ) ;\nvoid wr_r(const int rp_time,\n          uint64_t  vec_r,\n          tapa::istream<ResTerm> & q_din\n          ) ;\nvoid duplicator(tapa::istream<double_v8> & q_in,\n                tapa::ostream<double_v8> & q_out1,\n                tapa::ostream<double_v8> & q_out2\n                ) ;\nvoid vecp_mux(const int rp_time,\n              const int M,\n              tapa::istream<bool> & q_gbc,\n              tapa::istream<double_v8> & q_in1,\n              tapa::istream<double_v8> & q_in2,\n              tapa::ostream<double_v8> & q_out\n              ) ;\nvoid Callipepla(tapa::mmap<int> edge_list_ptr,\n                tapa::mmaps<ap_uint<512>, NUM_CH_SPARSE> edge_list_ch,\n                tapa::mmaps<double_v8, 2> vec_x,\n                tapa::mmaps<double_v8, 2> vec_p,\n                tapa::mmap<double_v8> vec_Ap,\n                tapa::mmaps<double_v8, 2> vec_r,\n                tapa::mmap<double_v8> vec_digA,\n                tapa::mmap<double> vec_res,\n                const int NUM_ITE,\n                const int NUM_A_LEN,\n                const int M,\n                const int rp_time,\n                const double th_termination\n                ) {\n#define TAPAB_APP \"TAPAB_Callipepla\"\n#define TAPAB \"TAPAB\"\n  const char* _tapa_bitstream = nullptr;\n  if ((_tapa_bitstream = getenv(TAPAB_APP)) ||\n      (_tapa_bitstream = getenv(TAPAB))) {\n    fpga::Instance _tapa_instance(_tapa_bitstream);\n    int _tapa_arg_index = 0;\n    for (const auto& _tapa_arg_info : _tapa_instance.GetArgsInfo()) {\n      if (false) {\n      } else if (_tapa_arg_info.name == \"edge_list_ptr\") {\n        auto _tapa_arg = fpga::ReadWrite(edge_list_ptr.get(), edge_list_ptr.size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"edge_list_ch_0\") {\n        auto _tapa_arg = fpga::ReadWrite(edge_list_ch[0].get(), edge_list_ch[0].size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"edge_list_ch_1\") {\n        auto _tapa_arg = fpga::ReadWrite(edge_list_ch[1].get(), edge_list_ch[1].size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"edge_list_ch_2\") {\n        auto _tapa_arg = fpga::ReadWrite(edge_list_ch[2].get(), edge_list_ch[2].size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"edge_list_ch_3\") {\n        auto _tapa_arg = fpga::ReadWrite(edge_list_ch[3].get(), edge_list_ch[3].size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"edge_list_ch_4\") {\n        auto _tapa_arg = fpga::ReadWrite(edge_list_ch[4].get(), edge_list_ch[4].size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"edge_list_ch_5\") {\n        auto _tapa_arg = fpga::ReadWrite(edge_list_ch[5].get(), edge_list_ch[5].size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"edge_list_ch_6\") {\n        auto _tapa_arg = fpga::ReadWrite(edge_list_ch[6].get(), edge_list_ch[6].size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"edge_list_ch_7\") {\n        auto _tapa_arg = fpga::ReadWrite(edge_list_ch[7].get(), edge_list_ch[7].size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"edge_list_ch_8\") {\n        auto _tapa_arg = fpga::ReadWrite(edge_list_ch[8].get(), edge_list_ch[8].size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"edge_list_ch_9\") {\n        auto _tapa_arg = fpga::ReadWrite(edge_list_ch[9].get(), edge_list_ch[9].size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"edge_list_ch_10\") {\n        auto _tapa_arg = fpga::ReadWrite(edge_list_ch[10].get(), edge_list_ch[10].size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"edge_list_ch_11\") {\n        auto _tapa_arg = fpga::ReadWrite(edge_list_ch[11].get(), edge_list_ch[11].size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"edge_list_ch_12\") {\n        auto _tapa_arg = fpga::ReadWrite(edge_list_ch[12].get(), edge_list_ch[12].size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"edge_list_ch_13\") {\n        auto _tapa_arg = fpga::ReadWrite(edge_list_ch[13].get(), edge_list_ch[13].size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"edge_list_ch_14\") {\n        auto _tapa_arg = fpga::ReadWrite(edge_list_ch[14].get(), edge_list_ch[14].size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"edge_list_ch_15\") {\n        auto _tapa_arg = fpga::ReadWrite(edge_list_ch[15].get(), edge_list_ch[15].size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"vec_x_0\") {\n        auto _tapa_arg = fpga::ReadWrite(vec_x[0].get(), vec_x[0].size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"vec_x_1\") {\n        auto _tapa_arg = fpga::ReadWrite(vec_x[1].get(), vec_x[1].size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"vec_p_0\") {\n        auto _tapa_arg = fpga::ReadWrite(vec_p[0].get(), vec_p[0].size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"vec_p_1\") {\n        auto _tapa_arg = fpga::ReadWrite(vec_p[1].get(), vec_p[1].size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"vec_Ap\") {\n        auto _tapa_arg = fpga::ReadWrite(vec_Ap.get(), vec_Ap.size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"vec_r_0\") {\n        auto _tapa_arg = fpga::ReadWrite(vec_r[0].get(), vec_r[0].size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"vec_r_1\") {\n        auto _tapa_arg = fpga::ReadWrite(vec_r[1].get(), vec_r[1].size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"vec_digA\") {\n        auto _tapa_arg = fpga::ReadWrite(vec_digA.get(), vec_digA.size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"vec_res\") {\n        auto _tapa_arg = fpga::ReadWrite(vec_res.get(), vec_res.size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"NUM_ITE\") {\n        _tapa_instance.SetArg(_tapa_arg_index, NUM_ITE);\n      } else if (_tapa_arg_info.name == \"NUM_A_LEN\") {\n        _tapa_instance.SetArg(_tapa_arg_index, NUM_A_LEN);\n      } else if (_tapa_arg_info.name == \"M\") {\n        _tapa_instance.SetArg(_tapa_arg_index, M);\n      } else if (_tapa_arg_info.name == \"rp_time\") {\n        _tapa_instance.SetArg(_tapa_arg_index, rp_time);\n      } else if (_tapa_arg_info.name == \"th_termination\") {\n        _tapa_instance.SetArg(_tapa_arg_index, th_termination);\n      } else {\n        std::stringstream ss;\n        ss << \"unknown argument: \" << _tapa_arg_info;\n        throw std::runtime_error(ss.str());\n      }\n      ++_tapa_arg_index;\n    }\n    _tapa_instance.WriteToDevice();\n    _tapa_instance.Exec();\n    _tapa_instance.ReadFromDevice();\n    _tapa_instance.Finish();\n  } else {\n    throw std::runtime_error(\"no bitstream found; please set `\" TAPAB_APP\n                             \"` or `\" TAPAB \"`\");\n  }\n}\n",
            "level": "upper",
            "ports": [
                {
                    "cat": "mmap",
                    "name": "edge_list_ptr",
                    "type": "int*",
                    "width": 32
                },
                {
                    "cat": "mmap",
                    "name": "edge_list_ch[0]",
                    "type": "ap_uint<512>*",
                    "width": 512
                },
                {
                    "cat": "mmap",
                    "name": "edge_list_ch[1]",
                    "type": "ap_uint<512>*",
                    "width": 512
                },
                {
                    "cat": "mmap",
                    "name": "edge_list_ch[2]",
                    "type": "ap_uint<512>*",
                    "width": 512
                },
                {
                    "cat": "mmap",
                    "name": "edge_list_ch[3]",
                    "type": "ap_uint<512>*",
                    "width": 512
                },
                {
                    "cat": "mmap",
                    "name": "edge_list_ch[4]",
                    "type": "ap_uint<512>*",
                    "width": 512
                },
                {
                    "cat": "mmap",
                    "name": "edge_list_ch[5]",
                    "type": "ap_uint<512>*",
                    "width": 512
                },
                {
                    "cat": "mmap",
                    "name": "edge_list_ch[6]",
                    "type": "ap_uint<512>*",
                    "width": 512
                },
                {
                    "cat": "mmap",
                    "name": "edge_list_ch[7]",
                    "type": "ap_uint<512>*",
                    "width": 512
                },
                {
                    "cat": "mmap",
                    "name": "edge_list_ch[8]",
                    "type": "ap_uint<512>*",
                    "width": 512
                },
                {
                    "cat": "mmap",
                    "name": "edge_list_ch[9]",
                    "type": "ap_uint<512>*",
                    "width": 512
                },
                {
                    "cat": "mmap",
                    "name": "edge_list_ch[10]",
                    "type": "ap_uint<512>*",
                    "width": 512
                },
                {
                    "cat": "mmap",
                    "name": "edge_list_ch[11]",
                    "type": "ap_uint<512>*",
                    "width": 512
                },
                {
                    "cat": "mmap",
                    "name": "edge_list_ch[12]",
                    "type": "ap_uint<512>*",
                    "width": 512
                },
                {
                    "cat": "mmap",
                    "name": "edge_list_ch[13]",
                    "type": "ap_uint<512>*",
                    "width": 512
                },
                {
                    "cat": "mmap",
                    "name": "edge_list_ch[14]",
                    "type": "ap_uint<512>*",
                    "width": 512
                },
                {
                    "cat": "mmap",
                    "name": "edge_list_ch[15]",
                    "type": "ap_uint<512>*",
                    "width": 512
                },
                {
                    "cat": "mmap",
                    "name": "vec_x[0]",
                    "type": "double_v8*",
                    "width": 512
                },
                {
                    "cat": "mmap",
                    "name": "vec_x[1]",
                    "type": "double_v8*",
                    "width": 512
                },
                {
                    "cat": "mmap",
                    "name": "vec_p[0]",
                    "type": "double_v8*",
                    "width": 512
                },
                {
                    "cat": "mmap",
                    "name": "vec_p[1]",
                    "type": "double_v8*",
                    "width": 512
                },
                {
                    "cat": "mmap",
                    "name": "vec_Ap",
                    "type": "double_v8*",
                    "width": 512
                },
                {
                    "cat": "mmap",
                    "name": "vec_r[0]",
                    "type": "double_v8*",
                    "width": 512
                },
                {
                    "cat": "mmap",
                    "name": "vec_r[1]",
                    "type": "double_v8*",
                    "width": 512
                },
                {
                    "cat": "mmap",
                    "name": "vec_digA",
                    "type": "double_v8*",
                    "width": 512
                },
                {
                    "cat": "mmap",
                    "name": "vec_res",
                    "type": "double*",
                    "width": 64
                },
                {
                    "cat": "scalar",
                    "name": "NUM_ITE",
                    "type": "const int",
                    "width": 32
                },
                {
                    "cat": "scalar",
                    "name": "NUM_A_LEN",
                    "type": "const int",
                    "width": 32
                },
                {
                    "cat": "scalar",
                    "name": "M",
                    "type": "const int",
                    "width": 32
                },
                {
                    "cat": "scalar",
                    "name": "rp_time",
                    "type": "const int",
                    "width": 32
                },
                {
                    "cat": "scalar",
                    "name": "th_termination",
                    "type": "const double",
                    "width": 64
                }
            ],
            "target": "hls",
            "tasks": {
                "Arbiter_Y": [
                    {
                        "args": {
                            "M": {
                                "arg": "M",
                                "cat": "scalar"
                            },
                            "fifo_in[0]": {
                                "arg": "fifo_Y_pe_Callipepla[0]",
                                "cat": "istream"
                            },
                            "fifo_in[1]": {
                                "arg": "fifo_Y_pe_Callipepla[1]",
                                "cat": "istream"
                            },
                            "fifo_out": {
                                "arg": "fifo_Y_pe_abd_Callipepla[0]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_aby_Callipepla[0]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_aby_Callipepla[1]",
                                "cat": "ostream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "M": {
                                "arg": "M",
                                "cat": "scalar"
                            },
                            "fifo_in[0]": {
                                "arg": "fifo_Y_pe_Callipepla[2]",
                                "cat": "istream"
                            },
                            "fifo_in[1]": {
                                "arg": "fifo_Y_pe_Callipepla[3]",
                                "cat": "istream"
                            },
                            "fifo_out": {
                                "arg": "fifo_Y_pe_abd_Callipepla[1]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_aby_Callipepla[1]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_aby_Callipepla[2]",
                                "cat": "ostream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "M": {
                                "arg": "M",
                                "cat": "scalar"
                            },
                            "fifo_in[0]": {
                                "arg": "fifo_Y_pe_Callipepla[4]",
                                "cat": "istream"
                            },
                            "fifo_in[1]": {
                                "arg": "fifo_Y_pe_Callipepla[5]",
                                "cat": "istream"
                            },
                            "fifo_out": {
                                "arg": "fifo_Y_pe_abd_Callipepla[2]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_aby_Callipepla[2]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_aby_Callipepla[3]",
                                "cat": "ostream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "M": {
                                "arg": "M",
                                "cat": "scalar"
                            },
                            "fifo_in[0]": {
                                "arg": "fifo_Y_pe_Callipepla[6]",
                                "cat": "istream"
                            },
                            "fifo_in[1]": {
                                "arg": "fifo_Y_pe_Callipepla[7]",
                                "cat": "istream"
                            },
                            "fifo_out": {
                                "arg": "fifo_Y_pe_abd_Callipepla[3]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_aby_Callipepla[3]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_aby_Callipepla[4]",
                                "cat": "ostream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "M": {
                                "arg": "M",
                                "cat": "scalar"
                            },
                            "fifo_in[0]": {
                                "arg": "fifo_Y_pe_Callipepla[8]",
                                "cat": "istream"
                            },
                            "fifo_in[1]": {
                                "arg": "fifo_Y_pe_Callipepla[9]",
                                "cat": "istream"
                            },
                            "fifo_out": {
                                "arg": "fifo_Y_pe_abd_Callipepla[4]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_aby_Callipepla[4]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_aby_Callipepla[5]",
                                "cat": "ostream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "M": {
                                "arg": "M",
                                "cat": "scalar"
                            },
                            "fifo_in[0]": {
                                "arg": "fifo_Y_pe_Callipepla[10]",
                                "cat": "istream"
                            },
                            "fifo_in[1]": {
                                "arg": "fifo_Y_pe_Callipepla[11]",
                                "cat": "istream"
                            },
                            "fifo_out": {
                                "arg": "fifo_Y_pe_abd_Callipepla[5]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_aby_Callipepla[5]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_aby_Callipepla[6]",
                                "cat": "ostream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "M": {
                                "arg": "M",
                                "cat": "scalar"
                            },
                            "fifo_in[0]": {
                                "arg": "fifo_Y_pe_Callipepla[12]",
                                "cat": "istream"
                            },
                            "fifo_in[1]": {
                                "arg": "fifo_Y_pe_Callipepla[13]",
                                "cat": "istream"
                            },
                            "fifo_out": {
                                "arg": "fifo_Y_pe_abd_Callipepla[6]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_aby_Callipepla[6]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_aby_Callipepla[7]",
                                "cat": "ostream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "M": {
                                "arg": "M",
                                "cat": "scalar"
                            },
                            "fifo_in[0]": {
                                "arg": "fifo_Y_pe_Callipepla[14]",
                                "cat": "istream"
                            },
                            "fifo_in[1]": {
                                "arg": "fifo_Y_pe_Callipepla[15]",
                                "cat": "istream"
                            },
                            "fifo_out": {
                                "arg": "fifo_Y_pe_abd_Callipepla[7]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_aby_Callipepla[7]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_aby_Callipepla[8]",
                                "cat": "ostream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    }
                ],
                "Merger_Y": [
                    {
                        "args": {
                            "fifo_in[0]": {
                                "arg": "fifo_Y_pe_abd_Callipepla[0]",
                                "cat": "istream"
                            },
                            "fifo_in[1]": {
                                "arg": "fifo_Y_pe_abd_Callipepla[1]",
                                "cat": "istream"
                            },
                            "fifo_in[2]": {
                                "arg": "fifo_Y_pe_abd_Callipepla[2]",
                                "cat": "istream"
                            },
                            "fifo_in[3]": {
                                "arg": "fifo_Y_pe_abd_Callipepla[3]",
                                "cat": "istream"
                            },
                            "fifo_in[4]": {
                                "arg": "fifo_Y_pe_abd_Callipepla[4]",
                                "cat": "istream"
                            },
                            "fifo_in[5]": {
                                "arg": "fifo_Y_pe_abd_Callipepla[5]",
                                "cat": "istream"
                            },
                            "fifo_in[6]": {
                                "arg": "fifo_Y_pe_abd_Callipepla[6]",
                                "cat": "istream"
                            },
                            "fifo_in[7]": {
                                "arg": "fifo_Y_pe_abd_Callipepla[7]",
                                "cat": "istream"
                            },
                            "fifo_out[0]": {
                                "arg": "fifo_AP_M1_Callipepla[0]",
                                "cat": "ostream"
                            },
                            "fifo_out[1]": {
                                "arg": "fifo_AP_M1_Callipepla[1]",
                                "cat": "ostream"
                            }
                        },
                        "step": -1
                    }
                ],
                "PEG_Xvec": [
                    {
                        "args": {
                            "fifo_A": {
                                "arg": "fifo_A_Callipepla[0]",
                                "cat": "istream"
                            },
                            "fifo_X_in": {
                                "arg": "fifo_P_pe_Callipepla[0]",
                                "cat": "istream"
                            },
                            "fifo_X_out": {
                                "arg": "fifo_P_pe_Callipepla[1]",
                                "cat": "ostream"
                            },
                            "fifo_aXvec": {
                                "arg": "fifo_aXvec_Callipepla[0]",
                                "cat": "ostream"
                            },
                            "fifo_inst_in": {
                                "arg": "PE_inst_Callipepla[0]",
                                "cat": "istream"
                            },
                            "fifo_inst_out": {
                                "arg": "PE_inst_Callipepla[1]",
                                "cat": "ostream"
                            },
                            "fifo_inst_out_to_Yvec": {
                                "arg": "Yvec_inst_Callipepla[0]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_edgepointer_Callipepla[1]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_edgepointer_Callipepla[2]",
                                "cat": "ostream"
                            },
                            "q_gbc_out_Y": {
                                "arg": "tsignal_Y_Callipepla[0]",
                                "cat": "ostream"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "fifo_A": {
                                "arg": "fifo_A_Callipepla[1]",
                                "cat": "istream"
                            },
                            "fifo_X_in": {
                                "arg": "fifo_P_pe_Callipepla[1]",
                                "cat": "istream"
                            },
                            "fifo_X_out": {
                                "arg": "fifo_P_pe_Callipepla[2]",
                                "cat": "ostream"
                            },
                            "fifo_aXvec": {
                                "arg": "fifo_aXvec_Callipepla[1]",
                                "cat": "ostream"
                            },
                            "fifo_inst_in": {
                                "arg": "PE_inst_Callipepla[1]",
                                "cat": "istream"
                            },
                            "fifo_inst_out": {
                                "arg": "PE_inst_Callipepla[2]",
                                "cat": "ostream"
                            },
                            "fifo_inst_out_to_Yvec": {
                                "arg": "Yvec_inst_Callipepla[1]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_edgepointer_Callipepla[2]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_edgepointer_Callipepla[3]",
                                "cat": "ostream"
                            },
                            "q_gbc_out_Y": {
                                "arg": "tsignal_Y_Callipepla[1]",
                                "cat": "ostream"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "fifo_A": {
                                "arg": "fifo_A_Callipepla[2]",
                                "cat": "istream"
                            },
                            "fifo_X_in": {
                                "arg": "fifo_P_pe_Callipepla[2]",
                                "cat": "istream"
                            },
                            "fifo_X_out": {
                                "arg": "fifo_P_pe_Callipepla[3]",
                                "cat": "ostream"
                            },
                            "fifo_aXvec": {
                                "arg": "fifo_aXvec_Callipepla[2]",
                                "cat": "ostream"
                            },
                            "fifo_inst_in": {
                                "arg": "PE_inst_Callipepla[2]",
                                "cat": "istream"
                            },
                            "fifo_inst_out": {
                                "arg": "PE_inst_Callipepla[3]",
                                "cat": "ostream"
                            },
                            "fifo_inst_out_to_Yvec": {
                                "arg": "Yvec_inst_Callipepla[2]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_edgepointer_Callipepla[3]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_edgepointer_Callipepla[4]",
                                "cat": "ostream"
                            },
                            "q_gbc_out_Y": {
                                "arg": "tsignal_Y_Callipepla[2]",
                                "cat": "ostream"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "fifo_A": {
                                "arg": "fifo_A_Callipepla[3]",
                                "cat": "istream"
                            },
                            "fifo_X_in": {
                                "arg": "fifo_P_pe_Callipepla[3]",
                                "cat": "istream"
                            },
                            "fifo_X_out": {
                                "arg": "fifo_P_pe_Callipepla[4]",
                                "cat": "ostream"
                            },
                            "fifo_aXvec": {
                                "arg": "fifo_aXvec_Callipepla[3]",
                                "cat": "ostream"
                            },
                            "fifo_inst_in": {
                                "arg": "PE_inst_Callipepla[3]",
                                "cat": "istream"
                            },
                            "fifo_inst_out": {
                                "arg": "PE_inst_Callipepla[4]",
                                "cat": "ostream"
                            },
                            "fifo_inst_out_to_Yvec": {
                                "arg": "Yvec_inst_Callipepla[3]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_edgepointer_Callipepla[4]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_edgepointer_Callipepla[5]",
                                "cat": "ostream"
                            },
                            "q_gbc_out_Y": {
                                "arg": "tsignal_Y_Callipepla[3]",
                                "cat": "ostream"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "fifo_A": {
                                "arg": "fifo_A_Callipepla[4]",
                                "cat": "istream"
                            },
                            "fifo_X_in": {
                                "arg": "fifo_P_pe_Callipepla[4]",
                                "cat": "istream"
                            },
                            "fifo_X_out": {
                                "arg": "fifo_P_pe_Callipepla[5]",
                                "cat": "ostream"
                            },
                            "fifo_aXvec": {
                                "arg": "fifo_aXvec_Callipepla[4]",
                                "cat": "ostream"
                            },
                            "fifo_inst_in": {
                                "arg": "PE_inst_Callipepla[4]",
                                "cat": "istream"
                            },
                            "fifo_inst_out": {
                                "arg": "PE_inst_Callipepla[5]",
                                "cat": "ostream"
                            },
                            "fifo_inst_out_to_Yvec": {
                                "arg": "Yvec_inst_Callipepla[4]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_edgepointer_Callipepla[5]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_edgepointer_Callipepla[6]",
                                "cat": "ostream"
                            },
                            "q_gbc_out_Y": {
                                "arg": "tsignal_Y_Callipepla[4]",
                                "cat": "ostream"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "fifo_A": {
                                "arg": "fifo_A_Callipepla[5]",
                                "cat": "istream"
                            },
                            "fifo_X_in": {
                                "arg": "fifo_P_pe_Callipepla[5]",
                                "cat": "istream"
                            },
                            "fifo_X_out": {
                                "arg": "fifo_P_pe_Callipepla[6]",
                                "cat": "ostream"
                            },
                            "fifo_aXvec": {
                                "arg": "fifo_aXvec_Callipepla[5]",
                                "cat": "ostream"
                            },
                            "fifo_inst_in": {
                                "arg": "PE_inst_Callipepla[5]",
                                "cat": "istream"
                            },
                            "fifo_inst_out": {
                                "arg": "PE_inst_Callipepla[6]",
                                "cat": "ostream"
                            },
                            "fifo_inst_out_to_Yvec": {
                                "arg": "Yvec_inst_Callipepla[5]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_edgepointer_Callipepla[6]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_edgepointer_Callipepla[7]",
                                "cat": "ostream"
                            },
                            "q_gbc_out_Y": {
                                "arg": "tsignal_Y_Callipepla[5]",
                                "cat": "ostream"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "fifo_A": {
                                "arg": "fifo_A_Callipepla[6]",
                                "cat": "istream"
                            },
                            "fifo_X_in": {
                                "arg": "fifo_P_pe_Callipepla[6]",
                                "cat": "istream"
                            },
                            "fifo_X_out": {
                                "arg": "fifo_P_pe_Callipepla[7]",
                                "cat": "ostream"
                            },
                            "fifo_aXvec": {
                                "arg": "fifo_aXvec_Callipepla[6]",
                                "cat": "ostream"
                            },
                            "fifo_inst_in": {
                                "arg": "PE_inst_Callipepla[6]",
                                "cat": "istream"
                            },
                            "fifo_inst_out": {
                                "arg": "PE_inst_Callipepla[7]",
                                "cat": "ostream"
                            },
                            "fifo_inst_out_to_Yvec": {
                                "arg": "Yvec_inst_Callipepla[6]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_edgepointer_Callipepla[7]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_edgepointer_Callipepla[8]",
                                "cat": "ostream"
                            },
                            "q_gbc_out_Y": {
                                "arg": "tsignal_Y_Callipepla[6]",
                                "cat": "ostream"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "fifo_A": {
                                "arg": "fifo_A_Callipepla[7]",
                                "cat": "istream"
                            },
                            "fifo_X_in": {
                                "arg": "fifo_P_pe_Callipepla[7]",
                                "cat": "istream"
                            },
                            "fifo_X_out": {
                                "arg": "fifo_P_pe_Callipepla[8]",
                                "cat": "ostream"
                            },
                            "fifo_aXvec": {
                                "arg": "fifo_aXvec_Callipepla[7]",
                                "cat": "ostream"
                            },
                            "fifo_inst_in": {
                                "arg": "PE_inst_Callipepla[7]",
                                "cat": "istream"
                            },
                            "fifo_inst_out": {
                                "arg": "PE_inst_Callipepla[8]",
                                "cat": "ostream"
                            },
                            "fifo_inst_out_to_Yvec": {
                                "arg": "Yvec_inst_Callipepla[7]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_edgepointer_Callipepla[8]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_edgepointer_Callipepla[9]",
                                "cat": "ostream"
                            },
                            "q_gbc_out_Y": {
                                "arg": "tsignal_Y_Callipepla[7]",
                                "cat": "ostream"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "fifo_A": {
                                "arg": "fifo_A_Callipepla[8]",
                                "cat": "istream"
                            },
                            "fifo_X_in": {
                                "arg": "fifo_P_pe_Callipepla[8]",
                                "cat": "istream"
                            },
                            "fifo_X_out": {
                                "arg": "fifo_P_pe_Callipepla[9]",
                                "cat": "ostream"
                            },
                            "fifo_aXvec": {
                                "arg": "fifo_aXvec_Callipepla[8]",
                                "cat": "ostream"
                            },
                            "fifo_inst_in": {
                                "arg": "PE_inst_Callipepla[8]",
                                "cat": "istream"
                            },
                            "fifo_inst_out": {
                                "arg": "PE_inst_Callipepla[9]",
                                "cat": "ostream"
                            },
                            "fifo_inst_out_to_Yvec": {
                                "arg": "Yvec_inst_Callipepla[8]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_edgepointer_Callipepla[9]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_edgepointer_Callipepla[10]",
                                "cat": "ostream"
                            },
                            "q_gbc_out_Y": {
                                "arg": "tsignal_Y_Callipepla[8]",
                                "cat": "ostream"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "fifo_A": {
                                "arg": "fifo_A_Callipepla[9]",
                                "cat": "istream"
                            },
                            "fifo_X_in": {
                                "arg": "fifo_P_pe_Callipepla[9]",
                                "cat": "istream"
                            },
                            "fifo_X_out": {
                                "arg": "fifo_P_pe_Callipepla[10]",
                                "cat": "ostream"
                            },
                            "fifo_aXvec": {
                                "arg": "fifo_aXvec_Callipepla[9]",
                                "cat": "ostream"
                            },
                            "fifo_inst_in": {
                                "arg": "PE_inst_Callipepla[9]",
                                "cat": "istream"
                            },
                            "fifo_inst_out": {
                                "arg": "PE_inst_Callipepla[10]",
                                "cat": "ostream"
                            },
                            "fifo_inst_out_to_Yvec": {
                                "arg": "Yvec_inst_Callipepla[9]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_edgepointer_Callipepla[10]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_edgepointer_Callipepla[11]",
                                "cat": "ostream"
                            },
                            "q_gbc_out_Y": {
                                "arg": "tsignal_Y_Callipepla[9]",
                                "cat": "ostream"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "fifo_A": {
                                "arg": "fifo_A_Callipepla[10]",
                                "cat": "istream"
                            },
                            "fifo_X_in": {
                                "arg": "fifo_P_pe_Callipepla[10]",
                                "cat": "istream"
                            },
                            "fifo_X_out": {
                                "arg": "fifo_P_pe_Callipepla[11]",
                                "cat": "ostream"
                            },
                            "fifo_aXvec": {
                                "arg": "fifo_aXvec_Callipepla[10]",
                                "cat": "ostream"
                            },
                            "fifo_inst_in": {
                                "arg": "PE_inst_Callipepla[10]",
                                "cat": "istream"
                            },
                            "fifo_inst_out": {
                                "arg": "PE_inst_Callipepla[11]",
                                "cat": "ostream"
                            },
                            "fifo_inst_out_to_Yvec": {
                                "arg": "Yvec_inst_Callipepla[10]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_edgepointer_Callipepla[11]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_edgepointer_Callipepla[12]",
                                "cat": "ostream"
                            },
                            "q_gbc_out_Y": {
                                "arg": "tsignal_Y_Callipepla[10]",
                                "cat": "ostream"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "fifo_A": {
                                "arg": "fifo_A_Callipepla[11]",
                                "cat": "istream"
                            },
                            "fifo_X_in": {
                                "arg": "fifo_P_pe_Callipepla[11]",
                                "cat": "istream"
                            },
                            "fifo_X_out": {
                                "arg": "fifo_P_pe_Callipepla[12]",
                                "cat": "ostream"
                            },
                            "fifo_aXvec": {
                                "arg": "fifo_aXvec_Callipepla[11]",
                                "cat": "ostream"
                            },
                            "fifo_inst_in": {
                                "arg": "PE_inst_Callipepla[11]",
                                "cat": "istream"
                            },
                            "fifo_inst_out": {
                                "arg": "PE_inst_Callipepla[12]",
                                "cat": "ostream"
                            },
                            "fifo_inst_out_to_Yvec": {
                                "arg": "Yvec_inst_Callipepla[11]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_edgepointer_Callipepla[12]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_edgepointer_Callipepla[13]",
                                "cat": "ostream"
                            },
                            "q_gbc_out_Y": {
                                "arg": "tsignal_Y_Callipepla[11]",
                                "cat": "ostream"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "fifo_A": {
                                "arg": "fifo_A_Callipepla[12]",
                                "cat": "istream"
                            },
                            "fifo_X_in": {
                                "arg": "fifo_P_pe_Callipepla[12]",
                                "cat": "istream"
                            },
                            "fifo_X_out": {
                                "arg": "fifo_P_pe_Callipepla[13]",
                                "cat": "ostream"
                            },
                            "fifo_aXvec": {
                                "arg": "fifo_aXvec_Callipepla[12]",
                                "cat": "ostream"
                            },
                            "fifo_inst_in": {
                                "arg": "PE_inst_Callipepla[12]",
                                "cat": "istream"
                            },
                            "fifo_inst_out": {
                                "arg": "PE_inst_Callipepla[13]",
                                "cat": "ostream"
                            },
                            "fifo_inst_out_to_Yvec": {
                                "arg": "Yvec_inst_Callipepla[12]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_edgepointer_Callipepla[13]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_edgepointer_Callipepla[14]",
                                "cat": "ostream"
                            },
                            "q_gbc_out_Y": {
                                "arg": "tsignal_Y_Callipepla[12]",
                                "cat": "ostream"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "fifo_A": {
                                "arg": "fifo_A_Callipepla[13]",
                                "cat": "istream"
                            },
                            "fifo_X_in": {
                                "arg": "fifo_P_pe_Callipepla[13]",
                                "cat": "istream"
                            },
                            "fifo_X_out": {
                                "arg": "fifo_P_pe_Callipepla[14]",
                                "cat": "ostream"
                            },
                            "fifo_aXvec": {
                                "arg": "fifo_aXvec_Callipepla[13]",
                                "cat": "ostream"
                            },
                            "fifo_inst_in": {
                                "arg": "PE_inst_Callipepla[13]",
                                "cat": "istream"
                            },
                            "fifo_inst_out": {
                                "arg": "PE_inst_Callipepla[14]",
                                "cat": "ostream"
                            },
                            "fifo_inst_out_to_Yvec": {
                                "arg": "Yvec_inst_Callipepla[13]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_edgepointer_Callipepla[14]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_edgepointer_Callipepla[15]",
                                "cat": "ostream"
                            },
                            "q_gbc_out_Y": {
                                "arg": "tsignal_Y_Callipepla[13]",
                                "cat": "ostream"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "fifo_A": {
                                "arg": "fifo_A_Callipepla[14]",
                                "cat": "istream"
                            },
                            "fifo_X_in": {
                                "arg": "fifo_P_pe_Callipepla[14]",
                                "cat": "istream"
                            },
                            "fifo_X_out": {
                                "arg": "fifo_P_pe_Callipepla[15]",
                                "cat": "ostream"
                            },
                            "fifo_aXvec": {
                                "arg": "fifo_aXvec_Callipepla[14]",
                                "cat": "ostream"
                            },
                            "fifo_inst_in": {
                                "arg": "PE_inst_Callipepla[14]",
                                "cat": "istream"
                            },
                            "fifo_inst_out": {
                                "arg": "PE_inst_Callipepla[15]",
                                "cat": "ostream"
                            },
                            "fifo_inst_out_to_Yvec": {
                                "arg": "Yvec_inst_Callipepla[14]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_edgepointer_Callipepla[15]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_edgepointer_Callipepla[16]",
                                "cat": "ostream"
                            },
                            "q_gbc_out_Y": {
                                "arg": "tsignal_Y_Callipepla[14]",
                                "cat": "ostream"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "fifo_A": {
                                "arg": "fifo_A_Callipepla[15]",
                                "cat": "istream"
                            },
                            "fifo_X_in": {
                                "arg": "fifo_P_pe_Callipepla[15]",
                                "cat": "istream"
                            },
                            "fifo_X_out": {
                                "arg": "fifo_P_pe_Callipepla[16]",
                                "cat": "ostream"
                            },
                            "fifo_aXvec": {
                                "arg": "fifo_aXvec_Callipepla[15]",
                                "cat": "ostream"
                            },
                            "fifo_inst_in": {
                                "arg": "PE_inst_Callipepla[15]",
                                "cat": "istream"
                            },
                            "fifo_inst_out": {
                                "arg": "PE_inst_Callipepla[16]",
                                "cat": "ostream"
                            },
                            "fifo_inst_out_to_Yvec": {
                                "arg": "Yvec_inst_Callipepla[15]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_edgepointer_Callipepla[16]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_edgepointer_Callipepla[17]",
                                "cat": "ostream"
                            },
                            "q_gbc_out_Y": {
                                "arg": "tsignal_Y_Callipepla[15]",
                                "cat": "ostream"
                            }
                        },
                        "step": 0
                    }
                ],
                "PEG_Yvec": [
                    {
                        "args": {
                            "fifo_Y_out": {
                                "arg": "fifo_Y_pe_Callipepla[0]",
                                "cat": "ostream"
                            },
                            "fifo_aXvec": {
                                "arg": "fifo_aXvec_Callipepla[0]",
                                "cat": "istream"
                            },
                            "fifo_inst_in": {
                                "arg": "Yvec_inst_Callipepla[0]",
                                "cat": "istream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_Y_Callipepla[0]",
                                "cat": "istream"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "fifo_Y_out": {
                                "arg": "fifo_Y_pe_Callipepla[1]",
                                "cat": "ostream"
                            },
                            "fifo_aXvec": {
                                "arg": "fifo_aXvec_Callipepla[1]",
                                "cat": "istream"
                            },
                            "fifo_inst_in": {
                                "arg": "Yvec_inst_Callipepla[1]",
                                "cat": "istream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_Y_Callipepla[1]",
                                "cat": "istream"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "fifo_Y_out": {
                                "arg": "fifo_Y_pe_Callipepla[2]",
                                "cat": "ostream"
                            },
                            "fifo_aXvec": {
                                "arg": "fifo_aXvec_Callipepla[2]",
                                "cat": "istream"
                            },
                            "fifo_inst_in": {
                                "arg": "Yvec_inst_Callipepla[2]",
                                "cat": "istream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_Y_Callipepla[2]",
                                "cat": "istream"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "fifo_Y_out": {
                                "arg": "fifo_Y_pe_Callipepla[3]",
                                "cat": "ostream"
                            },
                            "fifo_aXvec": {
                                "arg": "fifo_aXvec_Callipepla[3]",
                                "cat": "istream"
                            },
                            "fifo_inst_in": {
                                "arg": "Yvec_inst_Callipepla[3]",
                                "cat": "istream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_Y_Callipepla[3]",
                                "cat": "istream"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "fifo_Y_out": {
                                "arg": "fifo_Y_pe_Callipepla[4]",
                                "cat": "ostream"
                            },
                            "fifo_aXvec": {
                                "arg": "fifo_aXvec_Callipepla[4]",
                                "cat": "istream"
                            },
                            "fifo_inst_in": {
                                "arg": "Yvec_inst_Callipepla[4]",
                                "cat": "istream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_Y_Callipepla[4]",
                                "cat": "istream"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "fifo_Y_out": {
                                "arg": "fifo_Y_pe_Callipepla[5]",
                                "cat": "ostream"
                            },
                            "fifo_aXvec": {
                                "arg": "fifo_aXvec_Callipepla[5]",
                                "cat": "istream"
                            },
                            "fifo_inst_in": {
                                "arg": "Yvec_inst_Callipepla[5]",
                                "cat": "istream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_Y_Callipepla[5]",
                                "cat": "istream"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "fifo_Y_out": {
                                "arg": "fifo_Y_pe_Callipepla[6]",
                                "cat": "ostream"
                            },
                            "fifo_aXvec": {
                                "arg": "fifo_aXvec_Callipepla[6]",
                                "cat": "istream"
                            },
                            "fifo_inst_in": {
                                "arg": "Yvec_inst_Callipepla[6]",
                                "cat": "istream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_Y_Callipepla[6]",
                                "cat": "istream"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "fifo_Y_out": {
                                "arg": "fifo_Y_pe_Callipepla[7]",
                                "cat": "ostream"
                            },
                            "fifo_aXvec": {
                                "arg": "fifo_aXvec_Callipepla[7]",
                                "cat": "istream"
                            },
                            "fifo_inst_in": {
                                "arg": "Yvec_inst_Callipepla[7]",
                                "cat": "istream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_Y_Callipepla[7]",
                                "cat": "istream"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "fifo_Y_out": {
                                "arg": "fifo_Y_pe_Callipepla[8]",
                                "cat": "ostream"
                            },
                            "fifo_aXvec": {
                                "arg": "fifo_aXvec_Callipepla[8]",
                                "cat": "istream"
                            },
                            "fifo_inst_in": {
                                "arg": "Yvec_inst_Callipepla[8]",
                                "cat": "istream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_Y_Callipepla[8]",
                                "cat": "istream"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "fifo_Y_out": {
                                "arg": "fifo_Y_pe_Callipepla[9]",
                                "cat": "ostream"
                            },
                            "fifo_aXvec": {
                                "arg": "fifo_aXvec_Callipepla[9]",
                                "cat": "istream"
                            },
                            "fifo_inst_in": {
                                "arg": "Yvec_inst_Callipepla[9]",
                                "cat": "istream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_Y_Callipepla[9]",
                                "cat": "istream"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "fifo_Y_out": {
                                "arg": "fifo_Y_pe_Callipepla[10]",
                                "cat": "ostream"
                            },
                            "fifo_aXvec": {
                                "arg": "fifo_aXvec_Callipepla[10]",
                                "cat": "istream"
                            },
                            "fifo_inst_in": {
                                "arg": "Yvec_inst_Callipepla[10]",
                                "cat": "istream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_Y_Callipepla[10]",
                                "cat": "istream"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "fifo_Y_out": {
                                "arg": "fifo_Y_pe_Callipepla[11]",
                                "cat": "ostream"
                            },
                            "fifo_aXvec": {
                                "arg": "fifo_aXvec_Callipepla[11]",
                                "cat": "istream"
                            },
                            "fifo_inst_in": {
                                "arg": "Yvec_inst_Callipepla[11]",
                                "cat": "istream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_Y_Callipepla[11]",
                                "cat": "istream"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "fifo_Y_out": {
                                "arg": "fifo_Y_pe_Callipepla[12]",
                                "cat": "ostream"
                            },
                            "fifo_aXvec": {
                                "arg": "fifo_aXvec_Callipepla[12]",
                                "cat": "istream"
                            },
                            "fifo_inst_in": {
                                "arg": "Yvec_inst_Callipepla[12]",
                                "cat": "istream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_Y_Callipepla[12]",
                                "cat": "istream"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "fifo_Y_out": {
                                "arg": "fifo_Y_pe_Callipepla[13]",
                                "cat": "ostream"
                            },
                            "fifo_aXvec": {
                                "arg": "fifo_aXvec_Callipepla[13]",
                                "cat": "istream"
                            },
                            "fifo_inst_in": {
                                "arg": "Yvec_inst_Callipepla[13]",
                                "cat": "istream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_Y_Callipepla[13]",
                                "cat": "istream"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "fifo_Y_out": {
                                "arg": "fifo_Y_pe_Callipepla[14]",
                                "cat": "ostream"
                            },
                            "fifo_aXvec": {
                                "arg": "fifo_aXvec_Callipepla[14]",
                                "cat": "istream"
                            },
                            "fifo_inst_in": {
                                "arg": "Yvec_inst_Callipepla[14]",
                                "cat": "istream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_Y_Callipepla[14]",
                                "cat": "istream"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "fifo_Y_out": {
                                "arg": "fifo_Y_pe_Callipepla[15]",
                                "cat": "ostream"
                            },
                            "fifo_aXvec": {
                                "arg": "fifo_aXvec_Callipepla[15]",
                                "cat": "istream"
                            },
                            "fifo_inst_in": {
                                "arg": "Yvec_inst_Callipepla[15]",
                                "cat": "istream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_Y_Callipepla[15]",
                                "cat": "istream"
                            }
                        },
                        "step": 0
                    }
                ],
                "black_hole_bool": [
                    {
                        "args": {
                            "fifo_in": {
                                "arg": "tsignal_rdA_Callipepla[16]",
                                "cat": "istream"
                            }
                        },
                        "step": -1
                    },
                    {
                        "args": {
                            "fifo_in": {
                                "arg": "tsignal_edgepointer_Callipepla[17]",
                                "cat": "istream"
                            }
                        },
                        "step": -1
                    }
                ],
                "black_hole_double_v8": [
                    {
                        "args": {
                            "fifo_in": {
                                "arg": "fifo_P_pe_Callipepla[16]",
                                "cat": "istream"
                            }
                        },
                        "step": -1
                    }
                ],
                "black_hole_int": [
                    {
                        "args": {
                            "fifo_in": {
                                "arg": "PE_inst_Callipepla[16]",
                                "cat": "istream"
                            }
                        },
                        "step": -1
                    }
                ],
                "ctrl_AP": [
                    {
                        "args": {
                            "M": {
                                "arg": "M",
                                "cat": "scalar"
                            },
                            "q_gbc": {
                                "arg": "tsignal_ctrlAP_Callipepla",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_ctrldigA_Callipepla",
                                "cat": "ostream"
                            },
                            "q_inst": {
                                "arg": "fifo_mi_AP_Callipepla",
                                "cat": "ostream"
                            },
                            "q_pe": {
                                "arg": "fifo_AP_M1_Callipepla[0]",
                                "cat": "istream"
                            },
                            "q_res": {
                                "arg": "fifo_resp_AP_Callipepla",
                                "cat": "istream"
                            },
                            "q_updr": {
                                "arg": "fifo_AP_Callipepla",
                                "cat": "ostream"
                            },
                            "qm_din": {
                                "arg": "fifo_din_AP_Callipepla",
                                "cat": "istream"
                            },
                            "qm_dout": {
                                "arg": "fifo_dout_AP_Callipepla",
                                "cat": "ostream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    }
                ],
                "ctrl_P": [
                    {
                        "args": {
                            "M": {
                                "arg": "M",
                                "cat": "scalar"
                            },
                            "q_dotp": {
                                "arg": "fifo_P_dot_Callipepla",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_ctrlP_Callipepla",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_ctrlAP_Callipepla",
                                "cat": "ostream"
                            },
                            "q_inst[0]": {
                                "arg": "fifo_mi_P_Callipepla[0]",
                                "cat": "ostream"
                            },
                            "q_inst[1]": {
                                "arg": "fifo_mi_P_Callipepla[1]",
                                "cat": "ostream"
                            },
                            "q_res[0]": {
                                "arg": "fifo_resp_P_Callipepla[0]",
                                "cat": "istream"
                            },
                            "q_res[1]": {
                                "arg": "fifo_resp_P_Callipepla[1]",
                                "cat": "istream"
                            },
                            "q_spmv": {
                                "arg": "fifo_P_from_mem_Callipepla",
                                "cat": "ostream"
                            },
                            "q_updated": {
                                "arg": "fifo_P_updated_Callipepla",
                                "cat": "istream"
                            },
                            "q_updtp": {
                                "arg": "fifo_P_updtp_Callipepla",
                                "cat": "ostream"
                            },
                            "qm_din[0]": {
                                "arg": "fifo_din_P_Callipepla[0]",
                                "cat": "istream"
                            },
                            "qm_din[1]": {
                                "arg": "fifo_din_P_Callipepla[1]",
                                "cat": "istream"
                            },
                            "qm_dout[0]": {
                                "arg": "fifo_dout_P_Callipepla[0]",
                                "cat": "ostream"
                            },
                            "qm_dout[1]": {
                                "arg": "fifo_dout_P_Callipepla[1]",
                                "cat": "ostream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    }
                ],
                "ctrl_R": [
                    {
                        "args": {
                            "M": {
                                "arg": "M",
                                "cat": "scalar"
                            },
                            "q_gbc": {
                                "arg": "tsignal_ctrlR_Callipepla",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_ctrlX_Callipepla",
                                "cat": "ostream"
                            },
                            "q_inst[0]": {
                                "arg": "fifo_mi_R_Callipepla[0]",
                                "cat": "ostream"
                            },
                            "q_inst[1]": {
                                "arg": "fifo_mi_R_Callipepla[1]",
                                "cat": "ostream"
                            },
                            "q_res[0]": {
                                "arg": "fifo_resp_R_Callipepla[0]",
                                "cat": "istream"
                            },
                            "q_res[1]": {
                                "arg": "fifo_resp_R_Callipepla[1]",
                                "cat": "istream"
                            },
                            "qm_din[0]": {
                                "arg": "fifo_din_R_Callipepla[0]",
                                "cat": "istream"
                            },
                            "qm_din[1]": {
                                "arg": "fifo_din_R_Callipepla[1]",
                                "cat": "istream"
                            },
                            "qm_dout[0]": {
                                "arg": "fifo_dout_R_Callipepla[0]",
                                "cat": "ostream"
                            },
                            "qm_dout[1]": {
                                "arg": "fifo_dout_R_Callipepla[1]",
                                "cat": "ostream"
                            },
                            "qr_from_pe": {
                                "arg": "fifo_R_tomem_Callipepla",
                                "cat": "istream"
                            },
                            "qr_to_pe": {
                                "arg": "fifo_R_Callipepla",
                                "cat": "ostream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    }
                ],
                "ctrl_X": [
                    {
                        "args": {
                            "M": {
                                "arg": "M",
                                "cat": "scalar"
                            },
                            "q_gbc": {
                                "arg": "tsignal_ctrlX_Callipepla",
                                "cat": "istream"
                            },
                            "q_inst[0]": {
                                "arg": "fifo_mi_X_Callipepla[0]",
                                "cat": "ostream"
                            },
                            "q_inst[1]": {
                                "arg": "fifo_mi_X_Callipepla[1]",
                                "cat": "ostream"
                            },
                            "q_newx": {
                                "arg": "fifo_X_updated_Callipepla",
                                "cat": "istream"
                            },
                            "q_oldx": {
                                "arg": "fifo_X_Callipepla",
                                "cat": "ostream"
                            },
                            "q_res[0]": {
                                "arg": "fifo_resp_X_Callipepla[0]",
                                "cat": "istream"
                            },
                            "q_res[1]": {
                                "arg": "fifo_resp_X_Callipepla[1]",
                                "cat": "istream"
                            },
                            "qm_din[0]": {
                                "arg": "fifo_din_X_Callipepla[0]",
                                "cat": "istream"
                            },
                            "qm_din[1]": {
                                "arg": "fifo_din_X_Callipepla[1]",
                                "cat": "istream"
                            },
                            "qm_dout[0]": {
                                "arg": "fifo_dout_X_Callipepla[0]",
                                "cat": "ostream"
                            },
                            "qm_dout[1]": {
                                "arg": "fifo_dout_X_Callipepla[1]",
                                "cat": "ostream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    }
                ],
                "dot_alpha": [
                    {
                        "args": {
                            "M": {
                                "arg": "M",
                                "cat": "scalar"
                            },
                            "q1": {
                                "arg": "fifo_P_dot_Callipepla",
                                "cat": "istream"
                            },
                            "q2": {
                                "arg": "fifo_AP_M1_Callipepla[1]",
                                "cat": "istream"
                            },
                            "q3[0]": {
                                "arg": "fifo_alpha_Callipepla[0]",
                                "cat": "ostream"
                            },
                            "q3[1]": {
                                "arg": "fifo_alpha_Callipepla[1]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_aby_Callipepla[8]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_toM4_Callipepla",
                                "cat": "ostream"
                            },
                            "qrz": {
                                "arg": "fifo_rz_Callipepla[0]",
                                "cat": "istream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    }
                ],
                "dot_res": [
                    {
                        "args": {
                            "M": {
                                "arg": "M",
                                "cat": "scalar"
                            },
                            "q1": {
                                "arg": "fifo_R_updtd_rr_Callipepla",
                                "cat": "istream"
                            },
                            "q2": {
                                "arg": "fifo_RR_Callipepla",
                                "cat": "ostream"
                            },
                            "q_termination": {
                                "arg": "tsignal_res_Callipepla",
                                "cat": "ostream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            },
                            "th_termination": {
                                "arg": "th_termination",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    }
                ],
                "dot_rznew": [
                    {
                        "args": {
                            "M": {
                                "arg": "M",
                                "cat": "scalar"
                            },
                            "q_gbc": {
                                "arg": "tsignal_toM6_Callipepla",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_toM7_Callipepla",
                                "cat": "ostream"
                            },
                            "qr": {
                                "arg": "fifo_R_updtd_m6_Callipepla",
                                "cat": "istream"
                            },
                            "qr_out": {
                                "arg": "fifo_R_updtd_rr_Callipepla",
                                "cat": "ostream"
                            },
                            "qrz[0]": {
                                "arg": "fifo_rz_Callipepla[0]",
                                "cat": "ostream"
                            },
                            "qrz[1]": {
                                "arg": "fifo_rz_Callipepla[1]",
                                "cat": "ostream"
                            },
                            "qz": {
                                "arg": "fifo_Z_Callipepla[0]",
                                "cat": "istream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    }
                ],
                "duplicator": [
                    {
                        "args": {
                            "q_in": {
                                "arg": "fifo_P_to_dup_Callipepla",
                                "cat": "istream"
                            },
                            "q_out1": {
                                "arg": "fifo_P_updated_Callipepla",
                                "cat": "ostream"
                            },
                            "q_out2": {
                                "arg": "fifo_P_to_mux_Callipepla",
                                "cat": "ostream"
                            }
                        },
                        "step": -1
                    }
                ],
                "left_div": [
                    {
                        "args": {
                            "M": {
                                "arg": "M",
                                "cat": "scalar"
                            },
                            "q_gbc": {
                                "arg": "tsignal_toM5_Callipepla",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_toM6_Callipepla",
                                "cat": "ostream"
                            },
                            "qdiagA": {
                                "arg": "fifo_dA_Callipepla",
                                "cat": "istream"
                            },
                            "qr": {
                                "arg": "fifo_R_updtd_m5_Callipepla",
                                "cat": "istream"
                            },
                            "qr_m6": {
                                "arg": "fifo_R_updtd_m6_Callipepla",
                                "cat": "ostream"
                            },
                            "qrmem": {
                                "arg": "fifo_R_tomem_Callipepla",
                                "cat": "ostream"
                            },
                            "qz[0]": {
                                "arg": "fifo_Z_Callipepla[0]",
                                "cat": "ostream"
                            },
                            "qz[1]": {
                                "arg": "fifo_Z_Callipepla[1]",
                                "cat": "ostream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    }
                ],
                "rdwr_vec": [
                    {
                        "args": {
                            "q_din": {
                                "arg": "fifo_dout_P_Callipepla[0]",
                                "cat": "istream"
                            },
                            "q_dout": {
                                "arg": "fifo_din_P_Callipepla[0]",
                                "cat": "ostream"
                            },
                            "q_inst": {
                                "arg": "fifo_mi_P_Callipepla[0]",
                                "cat": "istream"
                            },
                            "q_response": {
                                "arg": "fifo_resp_P_Callipepla[0]",
                                "cat": "ostream"
                            },
                            "vec_p": {
                                "arg": "vec_p[0]",
                                "cat": "async_mmap"
                            }
                        },
                        "step": -1
                    },
                    {
                        "args": {
                            "q_din": {
                                "arg": "fifo_dout_P_Callipepla[1]",
                                "cat": "istream"
                            },
                            "q_dout": {
                                "arg": "fifo_din_P_Callipepla[1]",
                                "cat": "ostream"
                            },
                            "q_inst": {
                                "arg": "fifo_mi_P_Callipepla[1]",
                                "cat": "istream"
                            },
                            "q_response": {
                                "arg": "fifo_resp_P_Callipepla[1]",
                                "cat": "ostream"
                            },
                            "vec_p": {
                                "arg": "vec_p[1]",
                                "cat": "async_mmap"
                            }
                        },
                        "step": -1
                    },
                    {
                        "args": {
                            "q_din": {
                                "arg": "fifo_dout_R_Callipepla[0]",
                                "cat": "istream"
                            },
                            "q_dout": {
                                "arg": "fifo_din_R_Callipepla[0]",
                                "cat": "ostream"
                            },
                            "q_inst": {
                                "arg": "fifo_mi_R_Callipepla[0]",
                                "cat": "istream"
                            },
                            "q_response": {
                                "arg": "fifo_resp_R_Callipepla[0]",
                                "cat": "ostream"
                            },
                            "vec_p": {
                                "arg": "vec_r[0]",
                                "cat": "async_mmap"
                            }
                        },
                        "step": -1
                    },
                    {
                        "args": {
                            "q_din": {
                                "arg": "fifo_dout_R_Callipepla[1]",
                                "cat": "istream"
                            },
                            "q_dout": {
                                "arg": "fifo_din_R_Callipepla[1]",
                                "cat": "ostream"
                            },
                            "q_inst": {
                                "arg": "fifo_mi_R_Callipepla[1]",
                                "cat": "istream"
                            },
                            "q_response": {
                                "arg": "fifo_resp_R_Callipepla[1]",
                                "cat": "ostream"
                            },
                            "vec_p": {
                                "arg": "vec_r[1]",
                                "cat": "async_mmap"
                            }
                        },
                        "step": -1
                    },
                    {
                        "args": {
                            "q_din": {
                                "arg": "fifo_dout_X_Callipepla[0]",
                                "cat": "istream"
                            },
                            "q_dout": {
                                "arg": "fifo_din_X_Callipepla[0]",
                                "cat": "ostream"
                            },
                            "q_inst": {
                                "arg": "fifo_mi_X_Callipepla[0]",
                                "cat": "istream"
                            },
                            "q_response": {
                                "arg": "fifo_resp_X_Callipepla[0]",
                                "cat": "ostream"
                            },
                            "vec_p": {
                                "arg": "vec_x[0]",
                                "cat": "async_mmap"
                            }
                        },
                        "step": -1
                    },
                    {
                        "args": {
                            "q_din": {
                                "arg": "fifo_dout_X_Callipepla[1]",
                                "cat": "istream"
                            },
                            "q_dout": {
                                "arg": "fifo_din_X_Callipepla[1]",
                                "cat": "ostream"
                            },
                            "q_inst": {
                                "arg": "fifo_mi_X_Callipepla[1]",
                                "cat": "istream"
                            },
                            "q_response": {
                                "arg": "fifo_resp_X_Callipepla[1]",
                                "cat": "ostream"
                            },
                            "vec_p": {
                                "arg": "vec_x[1]",
                                "cat": "async_mmap"
                            }
                        },
                        "step": -1
                    },
                    {
                        "args": {
                            "q_din": {
                                "arg": "fifo_dout_AP_Callipepla",
                                "cat": "istream"
                            },
                            "q_dout": {
                                "arg": "fifo_din_AP_Callipepla",
                                "cat": "ostream"
                            },
                            "q_inst": {
                                "arg": "fifo_mi_AP_Callipepla",
                                "cat": "istream"
                            },
                            "q_response": {
                                "arg": "fifo_resp_AP_Callipepla",
                                "cat": "ostream"
                            },
                            "vec_p": {
                                "arg": "vec_Ap",
                                "cat": "async_mmap"
                            }
                        },
                        "step": -1
                    }
                ],
                "read_A": [
                    {
                        "args": {
                            "A": {
                                "arg": "edge_list_ch[0]",
                                "cat": "async_mmap"
                            },
                            "A_len": {
                                "arg": "NUM_A_LEN",
                                "cat": "scalar"
                            },
                            "fifo_A": {
                                "arg": "fifo_A_Callipepla[0]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_rdA_Callipepla[0]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_rdA_Callipepla[1]",
                                "cat": "ostream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "A": {
                                "arg": "edge_list_ch[1]",
                                "cat": "async_mmap"
                            },
                            "A_len": {
                                "arg": "NUM_A_LEN",
                                "cat": "scalar"
                            },
                            "fifo_A": {
                                "arg": "fifo_A_Callipepla[1]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_rdA_Callipepla[1]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_rdA_Callipepla[2]",
                                "cat": "ostream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "A": {
                                "arg": "edge_list_ch[2]",
                                "cat": "async_mmap"
                            },
                            "A_len": {
                                "arg": "NUM_A_LEN",
                                "cat": "scalar"
                            },
                            "fifo_A": {
                                "arg": "fifo_A_Callipepla[2]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_rdA_Callipepla[2]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_rdA_Callipepla[3]",
                                "cat": "ostream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "A": {
                                "arg": "edge_list_ch[3]",
                                "cat": "async_mmap"
                            },
                            "A_len": {
                                "arg": "NUM_A_LEN",
                                "cat": "scalar"
                            },
                            "fifo_A": {
                                "arg": "fifo_A_Callipepla[3]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_rdA_Callipepla[3]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_rdA_Callipepla[4]",
                                "cat": "ostream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "A": {
                                "arg": "edge_list_ch[4]",
                                "cat": "async_mmap"
                            },
                            "A_len": {
                                "arg": "NUM_A_LEN",
                                "cat": "scalar"
                            },
                            "fifo_A": {
                                "arg": "fifo_A_Callipepla[4]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_rdA_Callipepla[4]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_rdA_Callipepla[5]",
                                "cat": "ostream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "A": {
                                "arg": "edge_list_ch[5]",
                                "cat": "async_mmap"
                            },
                            "A_len": {
                                "arg": "NUM_A_LEN",
                                "cat": "scalar"
                            },
                            "fifo_A": {
                                "arg": "fifo_A_Callipepla[5]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_rdA_Callipepla[5]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_rdA_Callipepla[6]",
                                "cat": "ostream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "A": {
                                "arg": "edge_list_ch[6]",
                                "cat": "async_mmap"
                            },
                            "A_len": {
                                "arg": "NUM_A_LEN",
                                "cat": "scalar"
                            },
                            "fifo_A": {
                                "arg": "fifo_A_Callipepla[6]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_rdA_Callipepla[6]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_rdA_Callipepla[7]",
                                "cat": "ostream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "A": {
                                "arg": "edge_list_ch[7]",
                                "cat": "async_mmap"
                            },
                            "A_len": {
                                "arg": "NUM_A_LEN",
                                "cat": "scalar"
                            },
                            "fifo_A": {
                                "arg": "fifo_A_Callipepla[7]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_rdA_Callipepla[7]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_rdA_Callipepla[8]",
                                "cat": "ostream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "A": {
                                "arg": "edge_list_ch[8]",
                                "cat": "async_mmap"
                            },
                            "A_len": {
                                "arg": "NUM_A_LEN",
                                "cat": "scalar"
                            },
                            "fifo_A": {
                                "arg": "fifo_A_Callipepla[8]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_rdA_Callipepla[8]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_rdA_Callipepla[9]",
                                "cat": "ostream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "A": {
                                "arg": "edge_list_ch[9]",
                                "cat": "async_mmap"
                            },
                            "A_len": {
                                "arg": "NUM_A_LEN",
                                "cat": "scalar"
                            },
                            "fifo_A": {
                                "arg": "fifo_A_Callipepla[9]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_rdA_Callipepla[9]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_rdA_Callipepla[10]",
                                "cat": "ostream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "A": {
                                "arg": "edge_list_ch[10]",
                                "cat": "async_mmap"
                            },
                            "A_len": {
                                "arg": "NUM_A_LEN",
                                "cat": "scalar"
                            },
                            "fifo_A": {
                                "arg": "fifo_A_Callipepla[10]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_rdA_Callipepla[10]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_rdA_Callipepla[11]",
                                "cat": "ostream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "A": {
                                "arg": "edge_list_ch[11]",
                                "cat": "async_mmap"
                            },
                            "A_len": {
                                "arg": "NUM_A_LEN",
                                "cat": "scalar"
                            },
                            "fifo_A": {
                                "arg": "fifo_A_Callipepla[11]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_rdA_Callipepla[11]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_rdA_Callipepla[12]",
                                "cat": "ostream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "A": {
                                "arg": "edge_list_ch[12]",
                                "cat": "async_mmap"
                            },
                            "A_len": {
                                "arg": "NUM_A_LEN",
                                "cat": "scalar"
                            },
                            "fifo_A": {
                                "arg": "fifo_A_Callipepla[12]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_rdA_Callipepla[12]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_rdA_Callipepla[13]",
                                "cat": "ostream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "A": {
                                "arg": "edge_list_ch[13]",
                                "cat": "async_mmap"
                            },
                            "A_len": {
                                "arg": "NUM_A_LEN",
                                "cat": "scalar"
                            },
                            "fifo_A": {
                                "arg": "fifo_A_Callipepla[13]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_rdA_Callipepla[13]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_rdA_Callipepla[14]",
                                "cat": "ostream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "A": {
                                "arg": "edge_list_ch[14]",
                                "cat": "async_mmap"
                            },
                            "A_len": {
                                "arg": "NUM_A_LEN",
                                "cat": "scalar"
                            },
                            "fifo_A": {
                                "arg": "fifo_A_Callipepla[14]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_rdA_Callipepla[14]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_rdA_Callipepla[15]",
                                "cat": "ostream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    },
                    {
                        "args": {
                            "A": {
                                "arg": "edge_list_ch[15]",
                                "cat": "async_mmap"
                            },
                            "A_len": {
                                "arg": "NUM_A_LEN",
                                "cat": "scalar"
                            },
                            "fifo_A": {
                                "arg": "fifo_A_Callipepla[15]",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_rdA_Callipepla[15]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_rdA_Callipepla[16]",
                                "cat": "ostream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    }
                ],
                "read_digA": [
                    {
                        "args": {
                            "M": {
                                "arg": "M",
                                "cat": "scalar"
                            },
                            "q_dout": {
                                "arg": "fifo_dA_Callipepla",
                                "cat": "ostream"
                            },
                            "q_gbc": {
                                "arg": "tsignal_ctrldigA_Callipepla",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_ctrlR_Callipepla",
                                "cat": "ostream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            },
                            "vec_mem": {
                                "arg": "vec_digA",
                                "cat": "async_mmap"
                            }
                        },
                        "step": 0
                    }
                ],
                "read_edge_list_ptr": [
                    {
                        "args": {
                            "M": {
                                "arg": "M",
                                "cat": "scalar"
                            },
                            "PE_inst": {
                                "arg": "PE_inst_Callipepla[0]",
                                "cat": "ostream"
                            },
                            "edge_list_ptr": {
                                "arg": "edge_list_ptr",
                                "cat": "async_mmap"
                            },
                            "num_ite": {
                                "arg": "NUM_ITE",
                                "cat": "scalar"
                            },
                            "q_gbc": {
                                "arg": "tsignal_edgepointer_Callipepla[0]",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_edgepointer_Callipepla[1]",
                                "cat": "ostream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    }
                ],
                "term_signal_router": [
                    {
                        "args": {
                            "q_gbc": {
                                "arg": "tsignal_res_Callipepla",
                                "cat": "istream"
                            },
                            "q_to_abiter": {
                                "arg": "tsignal_aby_Callipepla[0]",
                                "cat": "ostream"
                            },
                            "q_to_ctrlmem": {
                                "arg": "tsignal_ctrlP_Callipepla",
                                "cat": "ostream"
                            },
                            "q_to_edgepointer": {
                                "arg": "tsignal_edgepointer_Callipepla[0]",
                                "cat": "ostream"
                            },
                            "q_to_mux": {
                                "arg": "tsignal_mux_Callipepla",
                                "cat": "ostream"
                            },
                            "q_to_rdA": {
                                "arg": "tsignal_rdA_Callipepla[0]",
                                "cat": "ostream"
                            }
                        },
                        "step": -1
                    }
                ],
                "updt_p": [
                    {
                        "args": {
                            "M": {
                                "arg": "M",
                                "cat": "scalar"
                            },
                            "q_gbc": {
                                "arg": "tsignal_toM7_Callipepla",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_toM3_Callipepla",
                                "cat": "ostream"
                            },
                            "qout": {
                                "arg": "fifo_P_to_dup_Callipepla",
                                "cat": "ostream"
                            },
                            "qp": {
                                "arg": "fifo_P_updtp_Callipepla",
                                "cat": "istream"
                            },
                            "qp2m3": {
                                "arg": "fifo_P_updtx_Callipepla",
                                "cat": "ostream"
                            },
                            "qrznew": {
                                "arg": "fifo_rz_Callipepla[1]",
                                "cat": "istream"
                            },
                            "qz": {
                                "arg": "fifo_Z_Callipepla[1]",
                                "cat": "istream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    }
                ],
                "updt_r": [
                    {
                        "args": {
                            "M": {
                                "arg": "M",
                                "cat": "scalar"
                            },
                            "q_gbc": {
                                "arg": "tsignal_toM4_Callipepla",
                                "cat": "istream"
                            },
                            "q_gbc_out": {
                                "arg": "tsignal_toM5_Callipepla",
                                "cat": "ostream"
                            },
                            "qalpha": {
                                "arg": "fifo_alpha_Callipepla[1]",
                                "cat": "istream"
                            },
                            "qap": {
                                "arg": "fifo_AP_Callipepla",
                                "cat": "istream"
                            },
                            "qout": {
                                "arg": "fifo_R_updtd_m5_Callipepla",
                                "cat": "ostream"
                            },
                            "qr": {
                                "arg": "fifo_R_Callipepla",
                                "cat": "istream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    }
                ],
                "updt_x": [
                    {
                        "args": {
                            "M": {
                                "arg": "M",
                                "cat": "scalar"
                            },
                            "q_gbc": {
                                "arg": "tsignal_toM3_Callipepla",
                                "cat": "istream"
                            },
                            "qalpha": {
                                "arg": "fifo_alpha_Callipepla[0]",
                                "cat": "istream"
                            },
                            "qout": {
                                "arg": "fifo_X_updated_Callipepla",
                                "cat": "ostream"
                            },
                            "qp": {
                                "arg": "fifo_P_updtx_Callipepla",
                                "cat": "istream"
                            },
                            "qx": {
                                "arg": "fifo_X_Callipepla",
                                "cat": "istream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    }
                ],
                "vecp_mux": [
                    {
                        "args": {
                            "M": {
                                "arg": "M",
                                "cat": "scalar"
                            },
                            "q_gbc": {
                                "arg": "tsignal_mux_Callipepla",
                                "cat": "istream"
                            },
                            "q_in1": {
                                "arg": "fifo_P_from_mem_Callipepla",
                                "cat": "istream"
                            },
                            "q_in2": {
                                "arg": "fifo_P_to_mux_Callipepla",
                                "cat": "istream"
                            },
                            "q_out": {
                                "arg": "fifo_P_pe_Callipepla[0]",
                                "cat": "ostream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            }
                        },
                        "step": 0
                    }
                ],
                "wr_r": [
                    {
                        "args": {
                            "q_din": {
                                "arg": "fifo_RR_Callipepla",
                                "cat": "istream"
                            },
                            "rp_time": {
                                "arg": "rp_time",
                                "cat": "scalar"
                            },
                            "vec_r": {
                                "arg": "vec_res",
                                "cat": "async_mmap"
                            }
                        },
                        "step": 0
                    }
                ]
            },
            "vendor": "xilinx"
        },
        "Merger_Y": {
            "code": "\n\n #include <ap_int.h>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cassert>\n\n\n #include \"ap_utils.h\"\n\n#include <tapa.h>\n\n\n\n #include <ap_int.h>\n\n#include <tapa.h>\nconstexpr int NUM_CH_SPARSE = 16;\nconstexpr int X_PARTITION_FACTOR = 4; // BRAMs = 512 / 16 / 2 = 16 -> factor = 16 / (64 / 16)\nconstexpr int WINDOW_SIZE = X_PARTITION_FACTOR * 1024;\nconstexpr int DEP_DIST_LOAD_STORE = 7;\nconstexpr int URAM_DEPTH = 3 * 4096;\n// ch16: 3 * 4096 * 16 * 8 = 1,572,864\nusing double_v8 = tapa::vec_t<double, 8>;\nvoid Callipepla(tapa::mmap<int> edge_list_ptr,\n                tapa::mmaps<ap_uint<512>, NUM_CH_SPARSE> edge_list_ch,\n                tapa::mmaps<double_v8, 2> vec_x,\n                tapa::mmaps<double_v8, 2> vec_p,\n                tapa::mmap<double_v8> vec_Ap,\n                tapa::mmaps<double_v8, 2> vec_r,\n                tapa::mmap<double_v8> vec_digA,\n                tapa::mmap<double> vec_res,\n                const int NUM_ITE, const int NUM_A_LEN, const int M,\n                const int rp_time,\n                const double th_termination\n                );\n\nconstexpr int FIFO_DEPTH = 2;\nconstexpr int FIFO_DEPTH_M6 = 50;\nconst int NUM_CH_SPARSE_div_8 = NUM_CH_SPARSE / 8;\nconst int NUM_CH_SPARSE_mult_8 = NUM_CH_SPARSE * 8;\nconst int WINDOW_SIZE_div_8 = WINDOW_SIZE / 8;\nstruct MultXVec {\n    tapa::vec_t<ap_uint<18>, 8> row;\n    double_v8 axv;\n};\nstruct InstRdWr {\n    bool rd;\n    bool wr;\n    //bool require_response;\n    int base_addr;\n    int len;\n};\nstruct InstVCtrl {\n    bool rd;\n    bool wr;\n    int base_addr;\n    int len;\n    ap_uint<3> q_rd_idx;\n    //ap_uint<3> q_wr_idx;\n};\nstruct InstCmp {\n    int len;\n    double alpha;\n    ap_uint<3> q_idx;\n};\nstruct ResTerm {\n    double res;\n    bool term;\n};\ntemplate <typename T, typename R>\ninline void async_read(tapa::async_mmap<T> & A,\n                       tapa::ostream<T> & fifo_A,\n                       const R i_end_addr,\n                       R & i_req,\n                       R & i_resp) {\n#pragma HLS inline\n    if ((i_req < i_end_addr) &\n        !A.read_addr.full()) {\n        A.read_addr.try_write(i_req);\n        ++i_req;\n    }\n    if (!fifo_A.full() & !A.read_data.empty()) {\n        T tmp;\n        A.read_data.try_read(tmp);\n        fifo_A.try_write(tmp);\n        ++i_resp;\n    }\n}\ntemplate <typename T, typename R>\ninline void async_write(tapa::async_mmap<T> & Y_out,\n                        tapa::istream<T> & fifo_Y,\n                        const R num_ite_Y,\n                        R & i_req,\n                        R & i_resp\n                        ) {\n#pragma HLS inline\n    if ((i_req < num_ite_Y) &\n        !fifo_Y.empty() &\n        !Y_out.write_addr.full() &\n        !Y_out.write_data.full() ) {\n        Y_out.write_addr.try_write(i_req);\n        T tmpv;\n        fifo_Y.try_read(tmpv);\n        Y_out.write_data.try_write(tmpv);\n        ++i_req;\n    }\n    uint8_t n_resp;\n    if (Y_out.write_resp.try_read(n_resp)) {\n        i_resp += R(n_resp) + 1;\n    }\n}\nvoid rdwr_vec(uint64_t  vec_p,\n              tapa::istream<InstRdWr> & q_inst,\n              tapa::istream<double_v8> & q_din,\n              tapa::ostream<double_v8> & q_dout,\n              tapa::ostream<bool> & q_response\n              ) ;\ntemplate <typename data_t>\ninline void q2q(tapa::istream<data_t> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty() & !qout.full()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void clearq(tapa::istream<data_t> & qin,\n                   const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void q2q(tapa::istreams<data_t, 2> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite,\n                const int idx) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin[idx].empty() & !qout.full()) {\n            data_t tmp;\n            qin[idx].try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void qq2qq(tapa::istream<data_t> & qin_pe,\n                  tapa::ostreams<data_t, 2> & qout_mem,\n                  tapa::istreams<data_t, 2> & qin_mem,\n                  tapa::ostream<data_t> & qout_qe,\n                  const int num_ite,\n                  const int idx) {\n#pragma HLS inline\nqq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin_pe.empty() & !qout_mem[idx].full()) {\n            data_t tmp;\n            qin_pe.try_read(tmp);\n            qout_mem[idx].try_write(tmp);\n            ++i;\n        }\n        if (!qin_mem[1 - idx].empty() & !qout_qe.full()) {\n            data_t tmp;\n            qin_mem[1 - idx].try_read(tmp);\n            qout_qe.try_write(tmp);\n        }\n    }\n}\nvoid term_signal_router(tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_to_rdA,\n                        tapa::ostream<bool> & q_to_edgepointer,\n                        tapa::ostream<bool> & q_to_abiter,\n                        tapa::ostream<bool> & q_to_ctrlmem,\n                        tapa::ostream<bool> & q_to_mux\n                        ) ;\nvoid read_edge_list_ptr(const int num_ite,\n                        const int M,\n                        const int rp_time, //P_N,\n                        uint64_t  edge_list_ptr,\n                        tapa::ostream<int> & PE_inst,\n                        tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_gbc_out\n                        ) ;\nvoid read_vec(const int rp_time, //P_N\n              const int M, //K,\n              tapa::async_mmap<double_v8> & vec_X,\n              tapa::ostream<double_v8> & fifo_X\n              ) {\n    //const int rp_time = (P_N == 0)? 1 : P_N;\n    const int num_ite_X = (M + 7) >> 3;\nl_rp:\n    for(int rp = 0; rp < rp_time; rp++) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n    rd_X:\n        for(int i_req = 0, i_resp = 0; i_resp < num_ite_X;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n            async_read(vec_X,\n                       fifo_X,\n                       num_ite_X,\n                       i_req, i_resp);\n        }\n    }\n}\nvoid read_A(const int rp_time, //P_N,\n            const int A_len,\n            uint64_t  A,\n            tapa::ostream<ap_uint<512>> & fifo_A,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid PEG_Xvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<ap_uint<512>> & fifo_A,\n              tapa::istream<double_v8> & fifo_X_in,\n              tapa::ostream<int> & fifo_inst_out,\n              tapa::ostream<double_v8> & fifo_X_out,\n              // to PEG_Yvec\n              tapa::ostream<int> & fifo_inst_out_to_Yvec,\n              tapa::ostream<MultXVec> & fifo_aXvec,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out,\n              tapa::ostream<bool> & q_gbc_out_Y\n              ) ;\nvoid PEG_Yvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<MultXVec> & fifo_aXvec,\n              tapa::ostream<double> & fifo_Y_out,\n              tapa::istream<bool> & q_gbc\n              ) ;\nvoid Arbiter_Y(const int rp_time, //P_N,\n               const int M,\n               tapa::istreams<double, NUM_CH_SPARSE_div_8> & fifo_in, // 2 = 16 / 8\n               tapa::ostream<double> & fifo_out,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\nvoid Merger_Y(tapa::istreams<double, 8> & fifo_in,\n              tapa::ostreams<double_v8, 2> & fifo_out) {\n#pragma HLS disaggregate variable = fifo_in\n#pragma HLS array_partition variable = fifo_in complete\n#pragma HLS interface ap_fifo port = fifo_in[0]._\n#pragma HLS aggregate variable = fifo_in[0]._ bit\n#pragma HLS interface ap_fifo port = fifo_in[0]._peek\n#pragma HLS aggregate variable = fifo_in[0]._peek bit\nvoid(fifo_in[0]._.empty());\nvoid(fifo_in[0]._peek.empty());\n#pragma HLS interface ap_fifo port = fifo_in[1]._\n#pragma HLS aggregate variable = fifo_in[1]._ bit\n#pragma HLS interface ap_fifo port = fifo_in[1]._peek\n#pragma HLS aggregate variable = fifo_in[1]._peek bit\nvoid(fifo_in[1]._.empty());\nvoid(fifo_in[1]._peek.empty());\n#pragma HLS interface ap_fifo port = fifo_in[2]._\n#pragma HLS aggregate variable = fifo_in[2]._ bit\n#pragma HLS interface ap_fifo port = fifo_in[2]._peek\n#pragma HLS aggregate variable = fifo_in[2]._peek bit\nvoid(fifo_in[2]._.empty());\nvoid(fifo_in[2]._peek.empty());\n#pragma HLS interface ap_fifo port = fifo_in[3]._\n#pragma HLS aggregate variable = fifo_in[3]._ bit\n#pragma HLS interface ap_fifo port = fifo_in[3]._peek\n#pragma HLS aggregate variable = fifo_in[3]._peek bit\nvoid(fifo_in[3]._.empty());\nvoid(fifo_in[3]._peek.empty());\n#pragma HLS interface ap_fifo port = fifo_in[4]._\n#pragma HLS aggregate variable = fifo_in[4]._ bit\n#pragma HLS interface ap_fifo port = fifo_in[4]._peek\n#pragma HLS aggregate variable = fifo_in[4]._peek bit\nvoid(fifo_in[4]._.empty());\nvoid(fifo_in[4]._peek.empty());\n#pragma HLS interface ap_fifo port = fifo_in[5]._\n#pragma HLS aggregate variable = fifo_in[5]._ bit\n#pragma HLS interface ap_fifo port = fifo_in[5]._peek\n#pragma HLS aggregate variable = fifo_in[5]._peek bit\nvoid(fifo_in[5]._.empty());\nvoid(fifo_in[5]._peek.empty());\n#pragma HLS interface ap_fifo port = fifo_in[6]._\n#pragma HLS aggregate variable = fifo_in[6]._ bit\n#pragma HLS interface ap_fifo port = fifo_in[6]._peek\n#pragma HLS aggregate variable = fifo_in[6]._peek bit\nvoid(fifo_in[6]._.empty());\nvoid(fifo_in[6]._peek.empty());\n#pragma HLS interface ap_fifo port = fifo_in[7]._\n#pragma HLS aggregate variable = fifo_in[7]._ bit\n#pragma HLS interface ap_fifo port = fifo_in[7]._peek\n#pragma HLS aggregate variable = fifo_in[7]._peek bit\nvoid(fifo_in[7]._.empty());\nvoid(fifo_in[7]._peek.empty());\n\n#pragma HLS disaggregate variable = fifo_out\n#pragma HLS array_partition variable = fifo_out complete\n#pragma HLS interface ap_fifo port = fifo_out[0]._\n#pragma HLS aggregate variable = fifo_out[0]._ bit\nvoid(fifo_out[0]._.full());\n#pragma HLS interface ap_fifo port = fifo_out[1]._\n#pragma HLS aggregate variable = fifo_out[1]._ bit\nvoid(fifo_out[1]._.full());\n\n    for (;;) {\n#pragma HLS pipeline II=1\n        bool flag_nop = fifo_out[0].full() | fifo_out[1].full();\n        for (int i = 0; i < 8; ++i) {\n            flag_nop |= fifo_in[i].empty();\n        }\n        if (!flag_nop) {\n            double_v8 tmpv;\n#pragma HLS aggregate variable=tmpv\n            for (int i = 0; i < 8; ++i) {\n                double tmp; fifo_in[i].try_read(tmp);\n                tmpv[i] = tmp;\n            }\n            fifo_out[0].try_write(tmpv);\n            fifo_out[1].try_write(tmpv);\n        }\n    }\n}\ntemplate <typename data_t>\ninline void bh(tapa::istream<data_t> & q) {\n#pragma HLS inline\n    for (;;) {\n#pragma HLS pipeline II=1\n        data_t tmp; q.try_read(tmp);\n    }\n}\nvoid black_hole_int(tapa::istream<int> & fifo_in) ;\nvoid black_hole_double_v8(tapa::istream<double_v8> & fifo_in) ;\nvoid black_hole_bool(tapa::istream<bool> & fifo_in) ;\nvoid ctrl_P(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time, //P_N\n            const int M, //K,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_spmv,\n            tapa::ostream<double_v8> & q_dotp,\n            //tapa::ostream<double_v8> & q_updtx,\n            tapa::ostream<double_v8> & q_updtp,\n            tapa::istream<double_v8> & q_updated,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_AP(tapa::istream<double_v8> & qm_din,\n             tapa::ostream<double_v8> & qm_dout,\n             const int rp_time,\n             const int M,\n             tapa::ostream<InstRdWr> & q_inst,\n             tapa::ostream<double_v8> & q_updr,\n             tapa::istream<double_v8> & q_pe,\n             tapa::istream<bool> & q_res,\n             tapa::istream<bool> & q_gbc,\n             tapa::ostream<bool> & q_gbc_out\n             ) ;\nvoid ctrl_X(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_oldx,\n            tapa::istream<double_v8> & q_newx,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_R(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & qr_to_pe,\n            tapa::istream<double_v8> & qr_from_pe,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid read_digA(uint64_t  vec_mem,\n               const int rp_time, //P_N\n               const int M, //K,\n               tapa::ostream<double_v8> & q_dout,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n/*  computation modules  */\n//M2: alpha = rzold / (p' * Ap)\nvoid dot_alpha(const int rp_time,\n               const int M,\n               //const unsigned long rz0,\n               tapa::istream<double> & qrz,\n               tapa::istream<double_v8> & q1,\n               tapa::istream<double_v8> & q2,\n               tapa::ostreams<double, 2> & q3,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M end: res = r' * r\nvoid dot_res(const int rp_time,\n             const int M,\n             const double th_termination,\n             tapa::istream<double_v8> & q1,\n             tapa::ostream<ResTerm> & q2,\n             tapa::ostream<bool> & q_termination\n             ) ;\n//M6: rznew = r' * z\nvoid dot_rznew(const int rp_time,\n               const int M,\n               tapa::istream<double_v8> & qr,\n               tapa::istream<double_v8> & qz,\n               tapa::ostream<double_v8> & qr_out,\n               tapa::ostreams<double, 2> & qrz,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M3: x = x + alpha * p\nvoid updt_x(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qx,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M7: p = z + (rznew/rzold) * p\nvoid updt_p(const int rp_time,\n            const int M,\n            //const unsigned long rz0,\n            tapa::istream<double> & qrznew,\n            tapa::istream<double_v8> & qz,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qp2m3,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M4: r = r - alpha * Ap\nvoid updt_r(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qr,\n            tapa::istream<double_v8> & qap,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M5: z = diagA \\ r\nvoid left_div(const int rp_time,\n              const int M,\n              tapa::istream<double_v8> & qr,\n              tapa::istream<double_v8> & qdiagA,\n              tapa::ostreams<double_v8, 2> & qz,\n              tapa::ostream<double_v8> & qr_m6,\n              tapa::ostream<double_v8> & qrmem,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out\n              ) ;\nvoid wr_r(const int rp_time,\n          uint64_t  vec_r,\n          tapa::istream<ResTerm> & q_din\n          ) ;\nvoid duplicator(tapa::istream<double_v8> & q_in,\n                tapa::ostream<double_v8> & q_out1,\n                tapa::ostream<double_v8> & q_out2\n                ) ;\nvoid vecp_mux(const int rp_time,\n              const int M,\n              tapa::istream<bool> & q_gbc,\n              tapa::istream<double_v8> & q_in1,\n              tapa::istream<double_v8> & q_in2,\n              tapa::ostream<double_v8> & q_out\n              ) ;\nvoid Callipepla(uint64_t  edge_list_ptr,\n                uint64_t edge_list_ch_0, uint64_t edge_list_ch_1, uint64_t edge_list_ch_2, uint64_t edge_list_ch_3, uint64_t edge_list_ch_4, uint64_t edge_list_ch_5, uint64_t edge_list_ch_6, uint64_t edge_list_ch_7, uint64_t edge_list_ch_8, uint64_t edge_list_ch_9, uint64_t edge_list_ch_10, uint64_t edge_list_ch_11, uint64_t edge_list_ch_12, uint64_t edge_list_ch_13, uint64_t edge_list_ch_14, uint64_t edge_list_ch_15,\n                uint64_t vec_x_0, uint64_t vec_x_1,\n                uint64_t vec_p_0, uint64_t vec_p_1,\n                uint64_t  vec_Ap,\n                uint64_t vec_r_0, uint64_t vec_r_1,\n                uint64_t  vec_digA,\n                uint64_t  vec_res,\n                const int NUM_ITE,\n                const int NUM_A_LEN,\n                const int M,\n                const int rp_time,\n                const double th_termination\n                ) ;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "PEG_Xvec": {
            "code": "\n\n #include <ap_int.h>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cassert>\n\n\n #include \"ap_utils.h\"\n\n#include <tapa.h>\n\n\n\n #include <ap_int.h>\n\n#include <tapa.h>\nconstexpr int NUM_CH_SPARSE = 16;\nconstexpr int X_PARTITION_FACTOR = 4; // BRAMs = 512 / 16 / 2 = 16 -> factor = 16 / (64 / 16)\nconstexpr int WINDOW_SIZE = X_PARTITION_FACTOR * 1024;\nconstexpr int DEP_DIST_LOAD_STORE = 7;\nconstexpr int URAM_DEPTH = 3 * 4096;\n// ch16: 3 * 4096 * 16 * 8 = 1,572,864\nusing double_v8 = tapa::vec_t<double, 8>;\nvoid Callipepla(tapa::mmap<int> edge_list_ptr,\n                tapa::mmaps<ap_uint<512>, NUM_CH_SPARSE> edge_list_ch,\n                tapa::mmaps<double_v8, 2> vec_x,\n                tapa::mmaps<double_v8, 2> vec_p,\n                tapa::mmap<double_v8> vec_Ap,\n                tapa::mmaps<double_v8, 2> vec_r,\n                tapa::mmap<double_v8> vec_digA,\n                tapa::mmap<double> vec_res,\n                const int NUM_ITE, const int NUM_A_LEN, const int M,\n                const int rp_time,\n                const double th_termination\n                );\n\nconstexpr int FIFO_DEPTH = 2;\nconstexpr int FIFO_DEPTH_M6 = 50;\nconst int NUM_CH_SPARSE_div_8 = NUM_CH_SPARSE / 8;\nconst int NUM_CH_SPARSE_mult_8 = NUM_CH_SPARSE * 8;\nconst int WINDOW_SIZE_div_8 = WINDOW_SIZE / 8;\nstruct MultXVec {\n    tapa::vec_t<ap_uint<18>, 8> row;\n    double_v8 axv;\n};\nstruct InstRdWr {\n    bool rd;\n    bool wr;\n    //bool require_response;\n    int base_addr;\n    int len;\n};\nstruct InstVCtrl {\n    bool rd;\n    bool wr;\n    int base_addr;\n    int len;\n    ap_uint<3> q_rd_idx;\n    //ap_uint<3> q_wr_idx;\n};\nstruct InstCmp {\n    int len;\n    double alpha;\n    ap_uint<3> q_idx;\n};\nstruct ResTerm {\n    double res;\n    bool term;\n};\ntemplate <typename T, typename R>\ninline void async_read(tapa::async_mmap<T> & A,\n                       tapa::ostream<T> & fifo_A,\n                       const R i_end_addr,\n                       R & i_req,\n                       R & i_resp) {\n#pragma HLS inline\n    if ((i_req < i_end_addr) &\n        !A.read_addr.full()) {\n        A.read_addr.try_write(i_req);\n        ++i_req;\n    }\n    if (!fifo_A.full() & !A.read_data.empty()) {\n        T tmp;\n        A.read_data.try_read(tmp);\n        fifo_A.try_write(tmp);\n        ++i_resp;\n    }\n}\ntemplate <typename T, typename R>\ninline void async_write(tapa::async_mmap<T> & Y_out,\n                        tapa::istream<T> & fifo_Y,\n                        const R num_ite_Y,\n                        R & i_req,\n                        R & i_resp\n                        ) {\n#pragma HLS inline\n    if ((i_req < num_ite_Y) &\n        !fifo_Y.empty() &\n        !Y_out.write_addr.full() &\n        !Y_out.write_data.full() ) {\n        Y_out.write_addr.try_write(i_req);\n        T tmpv;\n        fifo_Y.try_read(tmpv);\n        Y_out.write_data.try_write(tmpv);\n        ++i_req;\n    }\n    uint8_t n_resp;\n    if (Y_out.write_resp.try_read(n_resp)) {\n        i_resp += R(n_resp) + 1;\n    }\n}\nvoid rdwr_vec(uint64_t  vec_p,\n              tapa::istream<InstRdWr> & q_inst,\n              tapa::istream<double_v8> & q_din,\n              tapa::ostream<double_v8> & q_dout,\n              tapa::ostream<bool> & q_response\n              ) ;\ntemplate <typename data_t>\ninline void q2q(tapa::istream<data_t> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty() & !qout.full()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void clearq(tapa::istream<data_t> & qin,\n                   const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void q2q(tapa::istreams<data_t, 2> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite,\n                const int idx) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin[idx].empty() & !qout.full()) {\n            data_t tmp;\n            qin[idx].try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void qq2qq(tapa::istream<data_t> & qin_pe,\n                  tapa::ostreams<data_t, 2> & qout_mem,\n                  tapa::istreams<data_t, 2> & qin_mem,\n                  tapa::ostream<data_t> & qout_qe,\n                  const int num_ite,\n                  const int idx) {\n#pragma HLS inline\nqq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin_pe.empty() & !qout_mem[idx].full()) {\n            data_t tmp;\n            qin_pe.try_read(tmp);\n            qout_mem[idx].try_write(tmp);\n            ++i;\n        }\n        if (!qin_mem[1 - idx].empty() & !qout_qe.full()) {\n            data_t tmp;\n            qin_mem[1 - idx].try_read(tmp);\n            qout_qe.try_write(tmp);\n        }\n    }\n}\nvoid term_signal_router(tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_to_rdA,\n                        tapa::ostream<bool> & q_to_edgepointer,\n                        tapa::ostream<bool> & q_to_abiter,\n                        tapa::ostream<bool> & q_to_ctrlmem,\n                        tapa::ostream<bool> & q_to_mux\n                        ) ;\nvoid read_edge_list_ptr(const int num_ite,\n                        const int M,\n                        const int rp_time, //P_N,\n                        uint64_t  edge_list_ptr,\n                        tapa::ostream<int> & PE_inst,\n                        tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_gbc_out\n                        ) ;\nvoid read_vec(const int rp_time, //P_N\n              const int M, //K,\n              tapa::async_mmap<double_v8> & vec_X,\n              tapa::ostream<double_v8> & fifo_X\n              ) {\n    //const int rp_time = (P_N == 0)? 1 : P_N;\n    const int num_ite_X = (M + 7) >> 3;\nl_rp:\n    for(int rp = 0; rp < rp_time; rp++) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n    rd_X:\n        for(int i_req = 0, i_resp = 0; i_resp < num_ite_X;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n            async_read(vec_X,\n                       fifo_X,\n                       num_ite_X,\n                       i_req, i_resp);\n        }\n    }\n}\nvoid read_A(const int rp_time, //P_N,\n            const int A_len,\n            uint64_t  A,\n            tapa::ostream<ap_uint<512>> & fifo_A,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid PEG_Xvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<ap_uint<512>> & fifo_A,\n              tapa::istream<double_v8> & fifo_X_in,\n              tapa::ostream<int> & fifo_inst_out,\n              tapa::ostream<double_v8> & fifo_X_out,\n              // to PEG_Yvec\n              tapa::ostream<int> & fifo_inst_out_to_Yvec,\n              tapa::ostream<MultXVec> & fifo_aXvec,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out,\n              tapa::ostream<bool> & q_gbc_out_Y\n              ) {\n#pragma HLS disaggregate variable = fifo_inst_in\n#pragma HLS interface ap_fifo port = fifo_inst_in._\n#pragma HLS aggregate variable = fifo_inst_in._ bit\n#pragma HLS interface ap_fifo port = fifo_inst_in._peek\n#pragma HLS aggregate variable = fifo_inst_in._peek bit\nvoid(fifo_inst_in._.empty());\nvoid(fifo_inst_in._peek.empty());\n\n#pragma HLS disaggregate variable = fifo_A\n#pragma HLS interface ap_fifo port = fifo_A._\n#pragma HLS aggregate variable = fifo_A._ bit\n#pragma HLS interface ap_fifo port = fifo_A._peek\n#pragma HLS aggregate variable = fifo_A._peek bit\nvoid(fifo_A._.empty());\nvoid(fifo_A._peek.empty());\n\n#pragma HLS disaggregate variable = fifo_X_in\n#pragma HLS interface ap_fifo port = fifo_X_in._\n#pragma HLS aggregate variable = fifo_X_in._ bit\n#pragma HLS interface ap_fifo port = fifo_X_in._peek\n#pragma HLS aggregate variable = fifo_X_in._peek bit\nvoid(fifo_X_in._.empty());\nvoid(fifo_X_in._peek.empty());\n\n#pragma HLS disaggregate variable = fifo_inst_out\n#pragma HLS interface ap_fifo port = fifo_inst_out._\n#pragma HLS aggregate variable = fifo_inst_out._ bit\nvoid(fifo_inst_out._.full());\n\n#pragma HLS disaggregate variable = fifo_X_out\n#pragma HLS interface ap_fifo port = fifo_X_out._\n#pragma HLS aggregate variable = fifo_X_out._ bit\nvoid(fifo_X_out._.full());\n\n#pragma HLS disaggregate variable = fifo_inst_out_to_Yvec\n#pragma HLS interface ap_fifo port = fifo_inst_out_to_Yvec._\n#pragma HLS aggregate variable = fifo_inst_out_to_Yvec._ bit\nvoid(fifo_inst_out_to_Yvec._.full());\n\n#pragma HLS disaggregate variable = fifo_aXvec\n#pragma HLS interface ap_fifo port = fifo_aXvec._\n#pragma HLS aggregate variable = fifo_aXvec._ bit\nvoid(fifo_aXvec._.full());\n\n#pragma HLS disaggregate variable = q_gbc\n#pragma HLS interface ap_fifo port = q_gbc._\n#pragma HLS aggregate variable = q_gbc._ bit\n#pragma HLS interface ap_fifo port = q_gbc._peek\n#pragma HLS aggregate variable = q_gbc._peek bit\nvoid(q_gbc._.empty());\nvoid(q_gbc._peek.empty());\n\n#pragma HLS disaggregate variable = q_gbc_out\n#pragma HLS interface ap_fifo port = q_gbc_out._\n#pragma HLS aggregate variable = q_gbc_out._ bit\nvoid(q_gbc_out._.full());\n\n#pragma HLS disaggregate variable = q_gbc_out_Y\n#pragma HLS interface ap_fifo port = q_gbc_out_Y._\n#pragma HLS aggregate variable = q_gbc_out_Y._ bit\nvoid(q_gbc_out_Y._.full());\n\n    const int NUM_ITE = fifo_inst_in.read();\n    const int M = fifo_inst_in.read();\n    const int rp_time = fifo_inst_in.read();\n    //const int K = fifo_inst_in.read();\n    fifo_inst_out.write(NUM_ITE);\n    fifo_inst_out.write(M);\n    fifo_inst_out.write(rp_time);\n    //fifo_inst_out.write(K);\n    fifo_inst_out_to_Yvec.write(NUM_ITE);\n    fifo_inst_out_to_Yvec.write(M);\n    fifo_inst_out_to_Yvec.write(rp_time);\n    bool term_flag = false;\nl_rp:\n    for(int rp = -1; !term_flag & (rp < rp_time); rp++) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n        double local_X[4][WINDOW_SIZE];\n#pragma HLS bind_storage variable=local_X latency=1\n#pragma HLS array_partition variable=local_X complete dim=1\n#pragma HLS array_partition variable=local_X cyclic factor=X_PARTITION_FACTOR dim=2\n        auto start_32 = fifo_inst_in.read();\n        fifo_inst_out.write(start_32);\n        fifo_inst_out_to_Yvec.write(start_32);\n    main:\n        for (int i = 0; i < NUM_ITE; ++i) {\n#pragma HLS loop_tripcount min=1 max=49\n            // fill onchip X\n        read_X:\n            for (int j = 0; (j < WINDOW_SIZE_div_8) & (j < ((M + 7) >> 3) - i * WINDOW_SIZE_div_8); ) {\n#pragma HLS loop_tripcount min=1 max=512\n#pragma HLS pipeline II = 1\n                if (!fifo_X_in.empty() & !fifo_X_out.full()) {\n                    double_v8 x; fifo_X_in.try_read(x);\n                    fifo_X_out.try_write(x);\n                    for (int kk = 0; kk < 8; ++kk) { //512 / 64 = 8\n                        for (int l = 0; l < 4; ++l) {\n                            local_X[l][(j << 3) + kk] = x[kk]; // 8 -> << 3\n                        }\n                    }\n                    ++j;\n                }\n            }\n            // computation\n            const auto end_32 = fifo_inst_in.read();\n            fifo_inst_out.write(end_32);\n            fifo_inst_out_to_Yvec.write(end_32);\n        computation:\n            for (int j = start_32; j < end_32; ) {\n#pragma HLS loop_tripcount min=1 max=200\n#pragma HLS pipeline II=1\n                if (!fifo_A.empty()) {\n                    ap_uint<512> a_pes; fifo_A.try_read(a_pes);\n                    MultXVec raxv;\n                    for (int p = 0; p < 8; ++p) {\n                        ap_uint<64> a = a_pes(63 + p * 64, p * 64);\n                        ap_uint<14> a_col = a(63, 50);\n                        ap_uint<18> a_row = a(49, 32);\n                        ap_uint<32> a_val = a(31, 0);\n                        raxv.row[p] = a_row;\n                        if (a_row[17] == 0) {\n                            float a_val_f32 = tapa::bit_cast<float>(a_val);\n                            double a_val_f64 = (double) a_val_f32;\n                            raxv.axv[p] = a_val_f64 * local_X[p/2][a_col];\n                        }\n                    }\n                    fifo_aXvec.write(raxv);\n                    ++j;\n                }\n            }\n            start_32 = end_32;\n        }\n        ap_wait();\n        term_flag = q_gbc.read();\n        q_gbc_out.write(term_flag);\n        q_gbc_out_Y.write(term_flag);\n    }\n    //cout << \"##### exit PEG_Xvec\\n\";\n}\nvoid PEG_Yvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<MultXVec> & fifo_aXvec,\n              tapa::ostream<double> & fifo_Y_out,\n              tapa::istream<bool> & q_gbc\n              ) ;\nvoid Arbiter_Y(const int rp_time, //P_N,\n               const int M,\n               tapa::istreams<double, NUM_CH_SPARSE_div_8> & fifo_in, // 2 = 16 / 8\n               tapa::ostream<double> & fifo_out,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\nvoid Merger_Y(tapa::istreams<double, 8> & fifo_in,\n              tapa::ostreams<double_v8, 2> & fifo_out) ;\ntemplate <typename data_t>\ninline void bh(tapa::istream<data_t> & q) {\n#pragma HLS inline\n    for (;;) {\n#pragma HLS pipeline II=1\n        data_t tmp; q.try_read(tmp);\n    }\n}\nvoid black_hole_int(tapa::istream<int> & fifo_in) ;\nvoid black_hole_double_v8(tapa::istream<double_v8> & fifo_in) ;\nvoid black_hole_bool(tapa::istream<bool> & fifo_in) ;\nvoid ctrl_P(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time, //P_N\n            const int M, //K,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_spmv,\n            tapa::ostream<double_v8> & q_dotp,\n            //tapa::ostream<double_v8> & q_updtx,\n            tapa::ostream<double_v8> & q_updtp,\n            tapa::istream<double_v8> & q_updated,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_AP(tapa::istream<double_v8> & qm_din,\n             tapa::ostream<double_v8> & qm_dout,\n             const int rp_time,\n             const int M,\n             tapa::ostream<InstRdWr> & q_inst,\n             tapa::ostream<double_v8> & q_updr,\n             tapa::istream<double_v8> & q_pe,\n             tapa::istream<bool> & q_res,\n             tapa::istream<bool> & q_gbc,\n             tapa::ostream<bool> & q_gbc_out\n             ) ;\nvoid ctrl_X(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_oldx,\n            tapa::istream<double_v8> & q_newx,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_R(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & qr_to_pe,\n            tapa::istream<double_v8> & qr_from_pe,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid read_digA(uint64_t  vec_mem,\n               const int rp_time, //P_N\n               const int M, //K,\n               tapa::ostream<double_v8> & q_dout,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n/*  computation modules  */\n//M2: alpha = rzold / (p' * Ap)\nvoid dot_alpha(const int rp_time,\n               const int M,\n               //const unsigned long rz0,\n               tapa::istream<double> & qrz,\n               tapa::istream<double_v8> & q1,\n               tapa::istream<double_v8> & q2,\n               tapa::ostreams<double, 2> & q3,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M end: res = r' * r\nvoid dot_res(const int rp_time,\n             const int M,\n             const double th_termination,\n             tapa::istream<double_v8> & q1,\n             tapa::ostream<ResTerm> & q2,\n             tapa::ostream<bool> & q_termination\n             ) ;\n//M6: rznew = r' * z\nvoid dot_rznew(const int rp_time,\n               const int M,\n               tapa::istream<double_v8> & qr,\n               tapa::istream<double_v8> & qz,\n               tapa::ostream<double_v8> & qr_out,\n               tapa::ostreams<double, 2> & qrz,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M3: x = x + alpha * p\nvoid updt_x(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qx,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M7: p = z + (rznew/rzold) * p\nvoid updt_p(const int rp_time,\n            const int M,\n            //const unsigned long rz0,\n            tapa::istream<double> & qrznew,\n            tapa::istream<double_v8> & qz,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qp2m3,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M4: r = r - alpha * Ap\nvoid updt_r(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qr,\n            tapa::istream<double_v8> & qap,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M5: z = diagA \\ r\nvoid left_div(const int rp_time,\n              const int M,\n              tapa::istream<double_v8> & qr,\n              tapa::istream<double_v8> & qdiagA,\n              tapa::ostreams<double_v8, 2> & qz,\n              tapa::ostream<double_v8> & qr_m6,\n              tapa::ostream<double_v8> & qrmem,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out\n              ) ;\nvoid wr_r(const int rp_time,\n          uint64_t  vec_r,\n          tapa::istream<ResTerm> & q_din\n          ) ;\nvoid duplicator(tapa::istream<double_v8> & q_in,\n                tapa::ostream<double_v8> & q_out1,\n                tapa::ostream<double_v8> & q_out2\n                ) ;\nvoid vecp_mux(const int rp_time,\n              const int M,\n              tapa::istream<bool> & q_gbc,\n              tapa::istream<double_v8> & q_in1,\n              tapa::istream<double_v8> & q_in2,\n              tapa::ostream<double_v8> & q_out\n              ) ;\nvoid Callipepla(uint64_t  edge_list_ptr,\n                uint64_t edge_list_ch_0, uint64_t edge_list_ch_1, uint64_t edge_list_ch_2, uint64_t edge_list_ch_3, uint64_t edge_list_ch_4, uint64_t edge_list_ch_5, uint64_t edge_list_ch_6, uint64_t edge_list_ch_7, uint64_t edge_list_ch_8, uint64_t edge_list_ch_9, uint64_t edge_list_ch_10, uint64_t edge_list_ch_11, uint64_t edge_list_ch_12, uint64_t edge_list_ch_13, uint64_t edge_list_ch_14, uint64_t edge_list_ch_15,\n                uint64_t vec_x_0, uint64_t vec_x_1,\n                uint64_t vec_p_0, uint64_t vec_p_1,\n                uint64_t  vec_Ap,\n                uint64_t vec_r_0, uint64_t vec_r_1,\n                uint64_t  vec_digA,\n                uint64_t  vec_res,\n                const int NUM_ITE,\n                const int NUM_A_LEN,\n                const int M,\n                const int rp_time,\n                const double th_termination\n                ) ;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "PEG_Yvec": {
            "code": "\n\n #include <ap_int.h>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cassert>\n\n\n #include \"ap_utils.h\"\n\n#include <tapa.h>\n\n\n\n #include <ap_int.h>\n\n#include <tapa.h>\nconstexpr int NUM_CH_SPARSE = 16;\nconstexpr int X_PARTITION_FACTOR = 4; // BRAMs = 512 / 16 / 2 = 16 -> factor = 16 / (64 / 16)\nconstexpr int WINDOW_SIZE = X_PARTITION_FACTOR * 1024;\nconstexpr int DEP_DIST_LOAD_STORE = 7;\nconstexpr int URAM_DEPTH = 3 * 4096;\n// ch16: 3 * 4096 * 16 * 8 = 1,572,864\nusing double_v8 = tapa::vec_t<double, 8>;\nvoid Callipepla(tapa::mmap<int> edge_list_ptr,\n                tapa::mmaps<ap_uint<512>, NUM_CH_SPARSE> edge_list_ch,\n                tapa::mmaps<double_v8, 2> vec_x,\n                tapa::mmaps<double_v8, 2> vec_p,\n                tapa::mmap<double_v8> vec_Ap,\n                tapa::mmaps<double_v8, 2> vec_r,\n                tapa::mmap<double_v8> vec_digA,\n                tapa::mmap<double> vec_res,\n                const int NUM_ITE, const int NUM_A_LEN, const int M,\n                const int rp_time,\n                const double th_termination\n                );\n\nconstexpr int FIFO_DEPTH = 2;\nconstexpr int FIFO_DEPTH_M6 = 50;\nconst int NUM_CH_SPARSE_div_8 = NUM_CH_SPARSE / 8;\nconst int NUM_CH_SPARSE_mult_8 = NUM_CH_SPARSE * 8;\nconst int WINDOW_SIZE_div_8 = WINDOW_SIZE / 8;\nstruct MultXVec {\n    tapa::vec_t<ap_uint<18>, 8> row;\n    double_v8 axv;\n};\nstruct InstRdWr {\n    bool rd;\n    bool wr;\n    //bool require_response;\n    int base_addr;\n    int len;\n};\nstruct InstVCtrl {\n    bool rd;\n    bool wr;\n    int base_addr;\n    int len;\n    ap_uint<3> q_rd_idx;\n    //ap_uint<3> q_wr_idx;\n};\nstruct InstCmp {\n    int len;\n    double alpha;\n    ap_uint<3> q_idx;\n};\nstruct ResTerm {\n    double res;\n    bool term;\n};\ntemplate <typename T, typename R>\ninline void async_read(tapa::async_mmap<T> & A,\n                       tapa::ostream<T> & fifo_A,\n                       const R i_end_addr,\n                       R & i_req,\n                       R & i_resp) {\n#pragma HLS inline\n    if ((i_req < i_end_addr) &\n        !A.read_addr.full()) {\n        A.read_addr.try_write(i_req);\n        ++i_req;\n    }\n    if (!fifo_A.full() & !A.read_data.empty()) {\n        T tmp;\n        A.read_data.try_read(tmp);\n        fifo_A.try_write(tmp);\n        ++i_resp;\n    }\n}\ntemplate <typename T, typename R>\ninline void async_write(tapa::async_mmap<T> & Y_out,\n                        tapa::istream<T> & fifo_Y,\n                        const R num_ite_Y,\n                        R & i_req,\n                        R & i_resp\n                        ) {\n#pragma HLS inline\n    if ((i_req < num_ite_Y) &\n        !fifo_Y.empty() &\n        !Y_out.write_addr.full() &\n        !Y_out.write_data.full() ) {\n        Y_out.write_addr.try_write(i_req);\n        T tmpv;\n        fifo_Y.try_read(tmpv);\n        Y_out.write_data.try_write(tmpv);\n        ++i_req;\n    }\n    uint8_t n_resp;\n    if (Y_out.write_resp.try_read(n_resp)) {\n        i_resp += R(n_resp) + 1;\n    }\n}\nvoid rdwr_vec(uint64_t  vec_p,\n              tapa::istream<InstRdWr> & q_inst,\n              tapa::istream<double_v8> & q_din,\n              tapa::ostream<double_v8> & q_dout,\n              tapa::ostream<bool> & q_response\n              ) ;\ntemplate <typename data_t>\ninline void q2q(tapa::istream<data_t> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty() & !qout.full()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void clearq(tapa::istream<data_t> & qin,\n                   const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void q2q(tapa::istreams<data_t, 2> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite,\n                const int idx) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin[idx].empty() & !qout.full()) {\n            data_t tmp;\n            qin[idx].try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void qq2qq(tapa::istream<data_t> & qin_pe,\n                  tapa::ostreams<data_t, 2> & qout_mem,\n                  tapa::istreams<data_t, 2> & qin_mem,\n                  tapa::ostream<data_t> & qout_qe,\n                  const int num_ite,\n                  const int idx) {\n#pragma HLS inline\nqq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin_pe.empty() & !qout_mem[idx].full()) {\n            data_t tmp;\n            qin_pe.try_read(tmp);\n            qout_mem[idx].try_write(tmp);\n            ++i;\n        }\n        if (!qin_mem[1 - idx].empty() & !qout_qe.full()) {\n            data_t tmp;\n            qin_mem[1 - idx].try_read(tmp);\n            qout_qe.try_write(tmp);\n        }\n    }\n}\nvoid term_signal_router(tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_to_rdA,\n                        tapa::ostream<bool> & q_to_edgepointer,\n                        tapa::ostream<bool> & q_to_abiter,\n                        tapa::ostream<bool> & q_to_ctrlmem,\n                        tapa::ostream<bool> & q_to_mux\n                        ) ;\nvoid read_edge_list_ptr(const int num_ite,\n                        const int M,\n                        const int rp_time, //P_N,\n                        uint64_t  edge_list_ptr,\n                        tapa::ostream<int> & PE_inst,\n                        tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_gbc_out\n                        ) ;\nvoid read_vec(const int rp_time, //P_N\n              const int M, //K,\n              tapa::async_mmap<double_v8> & vec_X,\n              tapa::ostream<double_v8> & fifo_X\n              ) {\n    //const int rp_time = (P_N == 0)? 1 : P_N;\n    const int num_ite_X = (M + 7) >> 3;\nl_rp:\n    for(int rp = 0; rp < rp_time; rp++) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n    rd_X:\n        for(int i_req = 0, i_resp = 0; i_resp < num_ite_X;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n            async_read(vec_X,\n                       fifo_X,\n                       num_ite_X,\n                       i_req, i_resp);\n        }\n    }\n}\nvoid read_A(const int rp_time, //P_N,\n            const int A_len,\n            uint64_t  A,\n            tapa::ostream<ap_uint<512>> & fifo_A,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid PEG_Xvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<ap_uint<512>> & fifo_A,\n              tapa::istream<double_v8> & fifo_X_in,\n              tapa::ostream<int> & fifo_inst_out,\n              tapa::ostream<double_v8> & fifo_X_out,\n              // to PEG_Yvec\n              tapa::ostream<int> & fifo_inst_out_to_Yvec,\n              tapa::ostream<MultXVec> & fifo_aXvec,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out,\n              tapa::ostream<bool> & q_gbc_out_Y\n              ) ;\nvoid PEG_Yvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<MultXVec> & fifo_aXvec,\n              tapa::ostream<double> & fifo_Y_out,\n              tapa::istream<bool> & q_gbc\n              ) {\n#pragma HLS disaggregate variable = fifo_inst_in\n#pragma HLS interface ap_fifo port = fifo_inst_in._\n#pragma HLS aggregate variable = fifo_inst_in._ bit\n#pragma HLS interface ap_fifo port = fifo_inst_in._peek\n#pragma HLS aggregate variable = fifo_inst_in._peek bit\nvoid(fifo_inst_in._.empty());\nvoid(fifo_inst_in._peek.empty());\n\n#pragma HLS disaggregate variable = fifo_aXvec\n#pragma HLS interface ap_fifo port = fifo_aXvec._\n#pragma HLS aggregate variable = fifo_aXvec._ bit\n#pragma HLS interface ap_fifo port = fifo_aXvec._peek\n#pragma HLS aggregate variable = fifo_aXvec._peek bit\nvoid(fifo_aXvec._.empty());\nvoid(fifo_aXvec._peek.empty());\n\n#pragma HLS disaggregate variable = fifo_Y_out\n#pragma HLS interface ap_fifo port = fifo_Y_out._\n#pragma HLS aggregate variable = fifo_Y_out._ bit\nvoid(fifo_Y_out._.full());\n\n#pragma HLS disaggregate variable = q_gbc\n#pragma HLS interface ap_fifo port = q_gbc._\n#pragma HLS aggregate variable = q_gbc._ bit\n#pragma HLS interface ap_fifo port = q_gbc._peek\n#pragma HLS aggregate variable = q_gbc._peek bit\nvoid(q_gbc._.empty());\nvoid(q_gbc._peek.empty());\n\n    const int NUM_ITE = fifo_inst_in.read();\n    const int M = fifo_inst_in.read();\n    const int rp_time = fifo_inst_in.read();\n    const int num_v_init = (M + NUM_CH_SPARSE_mult_8 - 1) / NUM_CH_SPARSE_mult_8;\n    const int num_v_out = (M + NUM_CH_SPARSE - 1) / NUM_CH_SPARSE;\n    bool term_flag = false;\n    double local_C[8][URAM_DEPTH];\n#pragma HLS bind_storage variable=local_C type=RAM_2P impl=URAM latency=1\n#pragma HLS array_partition complete variable=local_C dim=1\nl_rp:\n    for(int rp = -1; !term_flag & (rp < rp_time); rp++) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n        //init local C\n    init_C:\n        for (int i = 0; i < num_v_init; ++i) {\n#pragma HLS loop_tripcount min=1 max=800\n#pragma HLS pipeline II=1\n            for (int p = 0; p < 8; ++p) {\n                local_C[p][i] = 0.0;\n            }\n        }\n        auto start_32 = fifo_inst_in.read();\n    main:\n        for (int i = 0; i < NUM_ITE; ++i) {\n#pragma HLS loop_tripcount min=1 max=49\n            // computation\n            const auto end_32 = fifo_inst_in.read();\n        computation:\n            for (int j = start_32; j < end_32; ) {\n#pragma HLS loop_tripcount min=1 max=200\n#pragma HLS pipeline II=1\n#pragma HLS dependence true variable=local_C distance=DEP_DIST_LOAD_STORE\n                if (!fifo_aXvec.empty()) {\n                    MultXVec raxv; fifo_aXvec.try_read(raxv);\n                    for (int p = 0; p < 8; ++p) {\n                        auto a_row = raxv.row[p];\n                        if (a_row[17] == 0) {\n                            local_C[p][a_row] += raxv.axv[p];\n                        }\n                    }\n                    ++j;\n                }\n            }\n            start_32 = end_32;\n        }\n        //cout << \"PE = \" << pe_idx << endl;\n    write_C_outer:\n        for (int i = 0, c_idx = 0; i < num_v_out; ++i) {\n#pragma HLS loop_tripcount min=1 max=1800\n#pragma HLS pipeline II=1\n            double out_v = local_C[c_idx][i>>3];\n            fifo_Y_out.write(out_v);\n            ++c_idx;\n            if (c_idx == 8) {c_idx = 0;}\n        }\n        ap_wait();\n        term_flag = q_gbc.read();\n    }\n    //cout << \"#### exit PEG_Yvec\\n\";\n}\nvoid Arbiter_Y(const int rp_time, //P_N,\n               const int M,\n               tapa::istreams<double, NUM_CH_SPARSE_div_8> & fifo_in, // 2 = 16 / 8\n               tapa::ostream<double> & fifo_out,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\nvoid Merger_Y(tapa::istreams<double, 8> & fifo_in,\n              tapa::ostreams<double_v8, 2> & fifo_out) ;\ntemplate <typename data_t>\ninline void bh(tapa::istream<data_t> & q) {\n#pragma HLS inline\n    for (;;) {\n#pragma HLS pipeline II=1\n        data_t tmp; q.try_read(tmp);\n    }\n}\nvoid black_hole_int(tapa::istream<int> & fifo_in) ;\nvoid black_hole_double_v8(tapa::istream<double_v8> & fifo_in) ;\nvoid black_hole_bool(tapa::istream<bool> & fifo_in) ;\nvoid ctrl_P(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time, //P_N\n            const int M, //K,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_spmv,\n            tapa::ostream<double_v8> & q_dotp,\n            //tapa::ostream<double_v8> & q_updtx,\n            tapa::ostream<double_v8> & q_updtp,\n            tapa::istream<double_v8> & q_updated,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_AP(tapa::istream<double_v8> & qm_din,\n             tapa::ostream<double_v8> & qm_dout,\n             const int rp_time,\n             const int M,\n             tapa::ostream<InstRdWr> & q_inst,\n             tapa::ostream<double_v8> & q_updr,\n             tapa::istream<double_v8> & q_pe,\n             tapa::istream<bool> & q_res,\n             tapa::istream<bool> & q_gbc,\n             tapa::ostream<bool> & q_gbc_out\n             ) ;\nvoid ctrl_X(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_oldx,\n            tapa::istream<double_v8> & q_newx,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_R(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & qr_to_pe,\n            tapa::istream<double_v8> & qr_from_pe,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid read_digA(uint64_t  vec_mem,\n               const int rp_time, //P_N\n               const int M, //K,\n               tapa::ostream<double_v8> & q_dout,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n/*  computation modules  */\n//M2: alpha = rzold / (p' * Ap)\nvoid dot_alpha(const int rp_time,\n               const int M,\n               //const unsigned long rz0,\n               tapa::istream<double> & qrz,\n               tapa::istream<double_v8> & q1,\n               tapa::istream<double_v8> & q2,\n               tapa::ostreams<double, 2> & q3,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M end: res = r' * r\nvoid dot_res(const int rp_time,\n             const int M,\n             const double th_termination,\n             tapa::istream<double_v8> & q1,\n             tapa::ostream<ResTerm> & q2,\n             tapa::ostream<bool> & q_termination\n             ) ;\n//M6: rznew = r' * z\nvoid dot_rznew(const int rp_time,\n               const int M,\n               tapa::istream<double_v8> & qr,\n               tapa::istream<double_v8> & qz,\n               tapa::ostream<double_v8> & qr_out,\n               tapa::ostreams<double, 2> & qrz,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M3: x = x + alpha * p\nvoid updt_x(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qx,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M7: p = z + (rznew/rzold) * p\nvoid updt_p(const int rp_time,\n            const int M,\n            //const unsigned long rz0,\n            tapa::istream<double> & qrznew,\n            tapa::istream<double_v8> & qz,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qp2m3,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M4: r = r - alpha * Ap\nvoid updt_r(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qr,\n            tapa::istream<double_v8> & qap,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M5: z = diagA \\ r\nvoid left_div(const int rp_time,\n              const int M,\n              tapa::istream<double_v8> & qr,\n              tapa::istream<double_v8> & qdiagA,\n              tapa::ostreams<double_v8, 2> & qz,\n              tapa::ostream<double_v8> & qr_m6,\n              tapa::ostream<double_v8> & qrmem,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out\n              ) ;\nvoid wr_r(const int rp_time,\n          uint64_t  vec_r,\n          tapa::istream<ResTerm> & q_din\n          ) ;\nvoid duplicator(tapa::istream<double_v8> & q_in,\n                tapa::ostream<double_v8> & q_out1,\n                tapa::ostream<double_v8> & q_out2\n                ) ;\nvoid vecp_mux(const int rp_time,\n              const int M,\n              tapa::istream<bool> & q_gbc,\n              tapa::istream<double_v8> & q_in1,\n              tapa::istream<double_v8> & q_in2,\n              tapa::ostream<double_v8> & q_out\n              ) ;\nvoid Callipepla(uint64_t  edge_list_ptr,\n                uint64_t edge_list_ch_0, uint64_t edge_list_ch_1, uint64_t edge_list_ch_2, uint64_t edge_list_ch_3, uint64_t edge_list_ch_4, uint64_t edge_list_ch_5, uint64_t edge_list_ch_6, uint64_t edge_list_ch_7, uint64_t edge_list_ch_8, uint64_t edge_list_ch_9, uint64_t edge_list_ch_10, uint64_t edge_list_ch_11, uint64_t edge_list_ch_12, uint64_t edge_list_ch_13, uint64_t edge_list_ch_14, uint64_t edge_list_ch_15,\n                uint64_t vec_x_0, uint64_t vec_x_1,\n                uint64_t vec_p_0, uint64_t vec_p_1,\n                uint64_t  vec_Ap,\n                uint64_t vec_r_0, uint64_t vec_r_1,\n                uint64_t  vec_digA,\n                uint64_t  vec_res,\n                const int NUM_ITE,\n                const int NUM_A_LEN,\n                const int M,\n                const int rp_time,\n                const double th_termination\n                ) ;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "black_hole_bool": {
            "code": "\n\n #include <ap_int.h>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cassert>\n\n\n #include \"ap_utils.h\"\n\n#include <tapa.h>\n\n\n\n #include <ap_int.h>\n\n#include <tapa.h>\nconstexpr int NUM_CH_SPARSE = 16;\nconstexpr int X_PARTITION_FACTOR = 4; // BRAMs = 512 / 16 / 2 = 16 -> factor = 16 / (64 / 16)\nconstexpr int WINDOW_SIZE = X_PARTITION_FACTOR * 1024;\nconstexpr int DEP_DIST_LOAD_STORE = 7;\nconstexpr int URAM_DEPTH = 3 * 4096;\n// ch16: 3 * 4096 * 16 * 8 = 1,572,864\nusing double_v8 = tapa::vec_t<double, 8>;\nvoid Callipepla(tapa::mmap<int> edge_list_ptr,\n                tapa::mmaps<ap_uint<512>, NUM_CH_SPARSE> edge_list_ch,\n                tapa::mmaps<double_v8, 2> vec_x,\n                tapa::mmaps<double_v8, 2> vec_p,\n                tapa::mmap<double_v8> vec_Ap,\n                tapa::mmaps<double_v8, 2> vec_r,\n                tapa::mmap<double_v8> vec_digA,\n                tapa::mmap<double> vec_res,\n                const int NUM_ITE, const int NUM_A_LEN, const int M,\n                const int rp_time,\n                const double th_termination\n                );\n\nconstexpr int FIFO_DEPTH = 2;\nconstexpr int FIFO_DEPTH_M6 = 50;\nconst int NUM_CH_SPARSE_div_8 = NUM_CH_SPARSE / 8;\nconst int NUM_CH_SPARSE_mult_8 = NUM_CH_SPARSE * 8;\nconst int WINDOW_SIZE_div_8 = WINDOW_SIZE / 8;\nstruct MultXVec {\n    tapa::vec_t<ap_uint<18>, 8> row;\n    double_v8 axv;\n};\nstruct InstRdWr {\n    bool rd;\n    bool wr;\n    //bool require_response;\n    int base_addr;\n    int len;\n};\nstruct InstVCtrl {\n    bool rd;\n    bool wr;\n    int base_addr;\n    int len;\n    ap_uint<3> q_rd_idx;\n    //ap_uint<3> q_wr_idx;\n};\nstruct InstCmp {\n    int len;\n    double alpha;\n    ap_uint<3> q_idx;\n};\nstruct ResTerm {\n    double res;\n    bool term;\n};\ntemplate <typename T, typename R>\ninline void async_read(tapa::async_mmap<T> & A,\n                       tapa::ostream<T> & fifo_A,\n                       const R i_end_addr,\n                       R & i_req,\n                       R & i_resp) {\n#pragma HLS inline\n    if ((i_req < i_end_addr) &\n        !A.read_addr.full()) {\n        A.read_addr.try_write(i_req);\n        ++i_req;\n    }\n    if (!fifo_A.full() & !A.read_data.empty()) {\n        T tmp;\n        A.read_data.try_read(tmp);\n        fifo_A.try_write(tmp);\n        ++i_resp;\n    }\n}\ntemplate <typename T, typename R>\ninline void async_write(tapa::async_mmap<T> & Y_out,\n                        tapa::istream<T> & fifo_Y,\n                        const R num_ite_Y,\n                        R & i_req,\n                        R & i_resp\n                        ) {\n#pragma HLS inline\n    if ((i_req < num_ite_Y) &\n        !fifo_Y.empty() &\n        !Y_out.write_addr.full() &\n        !Y_out.write_data.full() ) {\n        Y_out.write_addr.try_write(i_req);\n        T tmpv;\n        fifo_Y.try_read(tmpv);\n        Y_out.write_data.try_write(tmpv);\n        ++i_req;\n    }\n    uint8_t n_resp;\n    if (Y_out.write_resp.try_read(n_resp)) {\n        i_resp += R(n_resp) + 1;\n    }\n}\nvoid rdwr_vec(uint64_t  vec_p,\n              tapa::istream<InstRdWr> & q_inst,\n              tapa::istream<double_v8> & q_din,\n              tapa::ostream<double_v8> & q_dout,\n              tapa::ostream<bool> & q_response\n              ) ;\ntemplate <typename data_t>\ninline void q2q(tapa::istream<data_t> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty() & !qout.full()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void clearq(tapa::istream<data_t> & qin,\n                   const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void q2q(tapa::istreams<data_t, 2> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite,\n                const int idx) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin[idx].empty() & !qout.full()) {\n            data_t tmp;\n            qin[idx].try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void qq2qq(tapa::istream<data_t> & qin_pe,\n                  tapa::ostreams<data_t, 2> & qout_mem,\n                  tapa::istreams<data_t, 2> & qin_mem,\n                  tapa::ostream<data_t> & qout_qe,\n                  const int num_ite,\n                  const int idx) {\n#pragma HLS inline\nqq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin_pe.empty() & !qout_mem[idx].full()) {\n            data_t tmp;\n            qin_pe.try_read(tmp);\n            qout_mem[idx].try_write(tmp);\n            ++i;\n        }\n        if (!qin_mem[1 - idx].empty() & !qout_qe.full()) {\n            data_t tmp;\n            qin_mem[1 - idx].try_read(tmp);\n            qout_qe.try_write(tmp);\n        }\n    }\n}\nvoid term_signal_router(tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_to_rdA,\n                        tapa::ostream<bool> & q_to_edgepointer,\n                        tapa::ostream<bool> & q_to_abiter,\n                        tapa::ostream<bool> & q_to_ctrlmem,\n                        tapa::ostream<bool> & q_to_mux\n                        ) ;\nvoid read_edge_list_ptr(const int num_ite,\n                        const int M,\n                        const int rp_time, //P_N,\n                        uint64_t  edge_list_ptr,\n                        tapa::ostream<int> & PE_inst,\n                        tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_gbc_out\n                        ) ;\nvoid read_vec(const int rp_time, //P_N\n              const int M, //K,\n              tapa::async_mmap<double_v8> & vec_X,\n              tapa::ostream<double_v8> & fifo_X\n              ) {\n    //const int rp_time = (P_N == 0)? 1 : P_N;\n    const int num_ite_X = (M + 7) >> 3;\nl_rp:\n    for(int rp = 0; rp < rp_time; rp++) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n    rd_X:\n        for(int i_req = 0, i_resp = 0; i_resp < num_ite_X;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n            async_read(vec_X,\n                       fifo_X,\n                       num_ite_X,\n                       i_req, i_resp);\n        }\n    }\n}\nvoid read_A(const int rp_time, //P_N,\n            const int A_len,\n            uint64_t  A,\n            tapa::ostream<ap_uint<512>> & fifo_A,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid PEG_Xvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<ap_uint<512>> & fifo_A,\n              tapa::istream<double_v8> & fifo_X_in,\n              tapa::ostream<int> & fifo_inst_out,\n              tapa::ostream<double_v8> & fifo_X_out,\n              // to PEG_Yvec\n              tapa::ostream<int> & fifo_inst_out_to_Yvec,\n              tapa::ostream<MultXVec> & fifo_aXvec,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out,\n              tapa::ostream<bool> & q_gbc_out_Y\n              ) ;\nvoid PEG_Yvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<MultXVec> & fifo_aXvec,\n              tapa::ostream<double> & fifo_Y_out,\n              tapa::istream<bool> & q_gbc\n              ) ;\nvoid Arbiter_Y(const int rp_time, //P_N,\n               const int M,\n               tapa::istreams<double, NUM_CH_SPARSE_div_8> & fifo_in, // 2 = 16 / 8\n               tapa::ostream<double> & fifo_out,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\nvoid Merger_Y(tapa::istreams<double, 8> & fifo_in,\n              tapa::ostreams<double_v8, 2> & fifo_out) ;\ntemplate <typename data_t>\ninline void bh(tapa::istream<data_t> & q) {\n#pragma HLS inline\n    for (;;) {\n#pragma HLS pipeline II=1\n        data_t tmp; q.try_read(tmp);\n    }\n}\nvoid black_hole_int(tapa::istream<int> & fifo_in) ;\nvoid black_hole_double_v8(tapa::istream<double_v8> & fifo_in) ;\nvoid black_hole_bool(tapa::istream<bool> & fifo_in) {\n#pragma HLS disaggregate variable = fifo_in\n#pragma HLS interface ap_fifo port = fifo_in._\n#pragma HLS aggregate variable = fifo_in._ bit\n#pragma HLS interface ap_fifo port = fifo_in._peek\n#pragma HLS aggregate variable = fifo_in._peek bit\nvoid(fifo_in._.empty());\nvoid(fifo_in._peek.empty());\n\n    bh(fifo_in);\n}\nvoid ctrl_P(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time, //P_N\n            const int M, //K,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_spmv,\n            tapa::ostream<double_v8> & q_dotp,\n            //tapa::ostream<double_v8> & q_updtx,\n            tapa::ostream<double_v8> & q_updtp,\n            tapa::istream<double_v8> & q_updated,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_AP(tapa::istream<double_v8> & qm_din,\n             tapa::ostream<double_v8> & qm_dout,\n             const int rp_time,\n             const int M,\n             tapa::ostream<InstRdWr> & q_inst,\n             tapa::ostream<double_v8> & q_updr,\n             tapa::istream<double_v8> & q_pe,\n             tapa::istream<bool> & q_res,\n             tapa::istream<bool> & q_gbc,\n             tapa::ostream<bool> & q_gbc_out\n             ) ;\nvoid ctrl_X(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_oldx,\n            tapa::istream<double_v8> & q_newx,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_R(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & qr_to_pe,\n            tapa::istream<double_v8> & qr_from_pe,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid read_digA(uint64_t  vec_mem,\n               const int rp_time, //P_N\n               const int M, //K,\n               tapa::ostream<double_v8> & q_dout,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n/*  computation modules  */\n//M2: alpha = rzold / (p' * Ap)\nvoid dot_alpha(const int rp_time,\n               const int M,\n               //const unsigned long rz0,\n               tapa::istream<double> & qrz,\n               tapa::istream<double_v8> & q1,\n               tapa::istream<double_v8> & q2,\n               tapa::ostreams<double, 2> & q3,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M end: res = r' * r\nvoid dot_res(const int rp_time,\n             const int M,\n             const double th_termination,\n             tapa::istream<double_v8> & q1,\n             tapa::ostream<ResTerm> & q2,\n             tapa::ostream<bool> & q_termination\n             ) ;\n//M6: rznew = r' * z\nvoid dot_rznew(const int rp_time,\n               const int M,\n               tapa::istream<double_v8> & qr,\n               tapa::istream<double_v8> & qz,\n               tapa::ostream<double_v8> & qr_out,\n               tapa::ostreams<double, 2> & qrz,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M3: x = x + alpha * p\nvoid updt_x(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qx,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M7: p = z + (rznew/rzold) * p\nvoid updt_p(const int rp_time,\n            const int M,\n            //const unsigned long rz0,\n            tapa::istream<double> & qrznew,\n            tapa::istream<double_v8> & qz,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qp2m3,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M4: r = r - alpha * Ap\nvoid updt_r(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qr,\n            tapa::istream<double_v8> & qap,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M5: z = diagA \\ r\nvoid left_div(const int rp_time,\n              const int M,\n              tapa::istream<double_v8> & qr,\n              tapa::istream<double_v8> & qdiagA,\n              tapa::ostreams<double_v8, 2> & qz,\n              tapa::ostream<double_v8> & qr_m6,\n              tapa::ostream<double_v8> & qrmem,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out\n              ) ;\nvoid wr_r(const int rp_time,\n          uint64_t  vec_r,\n          tapa::istream<ResTerm> & q_din\n          ) ;\nvoid duplicator(tapa::istream<double_v8> & q_in,\n                tapa::ostream<double_v8> & q_out1,\n                tapa::ostream<double_v8> & q_out2\n                ) ;\nvoid vecp_mux(const int rp_time,\n              const int M,\n              tapa::istream<bool> & q_gbc,\n              tapa::istream<double_v8> & q_in1,\n              tapa::istream<double_v8> & q_in2,\n              tapa::ostream<double_v8> & q_out\n              ) ;\nvoid Callipepla(uint64_t  edge_list_ptr,\n                uint64_t edge_list_ch_0, uint64_t edge_list_ch_1, uint64_t edge_list_ch_2, uint64_t edge_list_ch_3, uint64_t edge_list_ch_4, uint64_t edge_list_ch_5, uint64_t edge_list_ch_6, uint64_t edge_list_ch_7, uint64_t edge_list_ch_8, uint64_t edge_list_ch_9, uint64_t edge_list_ch_10, uint64_t edge_list_ch_11, uint64_t edge_list_ch_12, uint64_t edge_list_ch_13, uint64_t edge_list_ch_14, uint64_t edge_list_ch_15,\n                uint64_t vec_x_0, uint64_t vec_x_1,\n                uint64_t vec_p_0, uint64_t vec_p_1,\n                uint64_t  vec_Ap,\n                uint64_t vec_r_0, uint64_t vec_r_1,\n                uint64_t  vec_digA,\n                uint64_t  vec_res,\n                const int NUM_ITE,\n                const int NUM_A_LEN,\n                const int M,\n                const int rp_time,\n                const double th_termination\n                ) ;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "black_hole_double_v8": {
            "code": "\n\n #include <ap_int.h>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cassert>\n\n\n #include \"ap_utils.h\"\n\n#include <tapa.h>\n\n\n\n #include <ap_int.h>\n\n#include <tapa.h>\nconstexpr int NUM_CH_SPARSE = 16;\nconstexpr int X_PARTITION_FACTOR = 4; // BRAMs = 512 / 16 / 2 = 16 -> factor = 16 / (64 / 16)\nconstexpr int WINDOW_SIZE = X_PARTITION_FACTOR * 1024;\nconstexpr int DEP_DIST_LOAD_STORE = 7;\nconstexpr int URAM_DEPTH = 3 * 4096;\n// ch16: 3 * 4096 * 16 * 8 = 1,572,864\nusing double_v8 = tapa::vec_t<double, 8>;\nvoid Callipepla(tapa::mmap<int> edge_list_ptr,\n                tapa::mmaps<ap_uint<512>, NUM_CH_SPARSE> edge_list_ch,\n                tapa::mmaps<double_v8, 2> vec_x,\n                tapa::mmaps<double_v8, 2> vec_p,\n                tapa::mmap<double_v8> vec_Ap,\n                tapa::mmaps<double_v8, 2> vec_r,\n                tapa::mmap<double_v8> vec_digA,\n                tapa::mmap<double> vec_res,\n                const int NUM_ITE, const int NUM_A_LEN, const int M,\n                const int rp_time,\n                const double th_termination\n                );\n\nconstexpr int FIFO_DEPTH = 2;\nconstexpr int FIFO_DEPTH_M6 = 50;\nconst int NUM_CH_SPARSE_div_8 = NUM_CH_SPARSE / 8;\nconst int NUM_CH_SPARSE_mult_8 = NUM_CH_SPARSE * 8;\nconst int WINDOW_SIZE_div_8 = WINDOW_SIZE / 8;\nstruct MultXVec {\n    tapa::vec_t<ap_uint<18>, 8> row;\n    double_v8 axv;\n};\nstruct InstRdWr {\n    bool rd;\n    bool wr;\n    //bool require_response;\n    int base_addr;\n    int len;\n};\nstruct InstVCtrl {\n    bool rd;\n    bool wr;\n    int base_addr;\n    int len;\n    ap_uint<3> q_rd_idx;\n    //ap_uint<3> q_wr_idx;\n};\nstruct InstCmp {\n    int len;\n    double alpha;\n    ap_uint<3> q_idx;\n};\nstruct ResTerm {\n    double res;\n    bool term;\n};\ntemplate <typename T, typename R>\ninline void async_read(tapa::async_mmap<T> & A,\n                       tapa::ostream<T> & fifo_A,\n                       const R i_end_addr,\n                       R & i_req,\n                       R & i_resp) {\n#pragma HLS inline\n    if ((i_req < i_end_addr) &\n        !A.read_addr.full()) {\n        A.read_addr.try_write(i_req);\n        ++i_req;\n    }\n    if (!fifo_A.full() & !A.read_data.empty()) {\n        T tmp;\n        A.read_data.try_read(tmp);\n        fifo_A.try_write(tmp);\n        ++i_resp;\n    }\n}\ntemplate <typename T, typename R>\ninline void async_write(tapa::async_mmap<T> & Y_out,\n                        tapa::istream<T> & fifo_Y,\n                        const R num_ite_Y,\n                        R & i_req,\n                        R & i_resp\n                        ) {\n#pragma HLS inline\n    if ((i_req < num_ite_Y) &\n        !fifo_Y.empty() &\n        !Y_out.write_addr.full() &\n        !Y_out.write_data.full() ) {\n        Y_out.write_addr.try_write(i_req);\n        T tmpv;\n        fifo_Y.try_read(tmpv);\n        Y_out.write_data.try_write(tmpv);\n        ++i_req;\n    }\n    uint8_t n_resp;\n    if (Y_out.write_resp.try_read(n_resp)) {\n        i_resp += R(n_resp) + 1;\n    }\n}\nvoid rdwr_vec(uint64_t  vec_p,\n              tapa::istream<InstRdWr> & q_inst,\n              tapa::istream<double_v8> & q_din,\n              tapa::ostream<double_v8> & q_dout,\n              tapa::ostream<bool> & q_response\n              ) ;\ntemplate <typename data_t>\ninline void q2q(tapa::istream<data_t> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty() & !qout.full()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void clearq(tapa::istream<data_t> & qin,\n                   const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void q2q(tapa::istreams<data_t, 2> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite,\n                const int idx) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin[idx].empty() & !qout.full()) {\n            data_t tmp;\n            qin[idx].try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void qq2qq(tapa::istream<data_t> & qin_pe,\n                  tapa::ostreams<data_t, 2> & qout_mem,\n                  tapa::istreams<data_t, 2> & qin_mem,\n                  tapa::ostream<data_t> & qout_qe,\n                  const int num_ite,\n                  const int idx) {\n#pragma HLS inline\nqq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin_pe.empty() & !qout_mem[idx].full()) {\n            data_t tmp;\n            qin_pe.try_read(tmp);\n            qout_mem[idx].try_write(tmp);\n            ++i;\n        }\n        if (!qin_mem[1 - idx].empty() & !qout_qe.full()) {\n            data_t tmp;\n            qin_mem[1 - idx].try_read(tmp);\n            qout_qe.try_write(tmp);\n        }\n    }\n}\nvoid term_signal_router(tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_to_rdA,\n                        tapa::ostream<bool> & q_to_edgepointer,\n                        tapa::ostream<bool> & q_to_abiter,\n                        tapa::ostream<bool> & q_to_ctrlmem,\n                        tapa::ostream<bool> & q_to_mux\n                        ) ;\nvoid read_edge_list_ptr(const int num_ite,\n                        const int M,\n                        const int rp_time, //P_N,\n                        uint64_t  edge_list_ptr,\n                        tapa::ostream<int> & PE_inst,\n                        tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_gbc_out\n                        ) ;\nvoid read_vec(const int rp_time, //P_N\n              const int M, //K,\n              tapa::async_mmap<double_v8> & vec_X,\n              tapa::ostream<double_v8> & fifo_X\n              ) {\n    //const int rp_time = (P_N == 0)? 1 : P_N;\n    const int num_ite_X = (M + 7) >> 3;\nl_rp:\n    for(int rp = 0; rp < rp_time; rp++) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n    rd_X:\n        for(int i_req = 0, i_resp = 0; i_resp < num_ite_X;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n            async_read(vec_X,\n                       fifo_X,\n                       num_ite_X,\n                       i_req, i_resp);\n        }\n    }\n}\nvoid read_A(const int rp_time, //P_N,\n            const int A_len,\n            uint64_t  A,\n            tapa::ostream<ap_uint<512>> & fifo_A,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid PEG_Xvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<ap_uint<512>> & fifo_A,\n              tapa::istream<double_v8> & fifo_X_in,\n              tapa::ostream<int> & fifo_inst_out,\n              tapa::ostream<double_v8> & fifo_X_out,\n              // to PEG_Yvec\n              tapa::ostream<int> & fifo_inst_out_to_Yvec,\n              tapa::ostream<MultXVec> & fifo_aXvec,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out,\n              tapa::ostream<bool> & q_gbc_out_Y\n              ) ;\nvoid PEG_Yvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<MultXVec> & fifo_aXvec,\n              tapa::ostream<double> & fifo_Y_out,\n              tapa::istream<bool> & q_gbc\n              ) ;\nvoid Arbiter_Y(const int rp_time, //P_N,\n               const int M,\n               tapa::istreams<double, NUM_CH_SPARSE_div_8> & fifo_in, // 2 = 16 / 8\n               tapa::ostream<double> & fifo_out,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\nvoid Merger_Y(tapa::istreams<double, 8> & fifo_in,\n              tapa::ostreams<double_v8, 2> & fifo_out) ;\ntemplate <typename data_t>\ninline void bh(tapa::istream<data_t> & q) {\n#pragma HLS inline\n    for (;;) {\n#pragma HLS pipeline II=1\n        data_t tmp; q.try_read(tmp);\n    }\n}\nvoid black_hole_int(tapa::istream<int> & fifo_in) ;\nvoid black_hole_double_v8(tapa::istream<double_v8> & fifo_in) {\n#pragma HLS disaggregate variable = fifo_in\n#pragma HLS interface ap_fifo port = fifo_in._\n#pragma HLS aggregate variable = fifo_in._ bit\n#pragma HLS interface ap_fifo port = fifo_in._peek\n#pragma HLS aggregate variable = fifo_in._peek bit\nvoid(fifo_in._.empty());\nvoid(fifo_in._peek.empty());\n\n    bh(fifo_in);\n}\nvoid black_hole_bool(tapa::istream<bool> & fifo_in) ;\nvoid ctrl_P(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time, //P_N\n            const int M, //K,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_spmv,\n            tapa::ostream<double_v8> & q_dotp,\n            //tapa::ostream<double_v8> & q_updtx,\n            tapa::ostream<double_v8> & q_updtp,\n            tapa::istream<double_v8> & q_updated,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_AP(tapa::istream<double_v8> & qm_din,\n             tapa::ostream<double_v8> & qm_dout,\n             const int rp_time,\n             const int M,\n             tapa::ostream<InstRdWr> & q_inst,\n             tapa::ostream<double_v8> & q_updr,\n             tapa::istream<double_v8> & q_pe,\n             tapa::istream<bool> & q_res,\n             tapa::istream<bool> & q_gbc,\n             tapa::ostream<bool> & q_gbc_out\n             ) ;\nvoid ctrl_X(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_oldx,\n            tapa::istream<double_v8> & q_newx,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_R(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & qr_to_pe,\n            tapa::istream<double_v8> & qr_from_pe,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid read_digA(uint64_t  vec_mem,\n               const int rp_time, //P_N\n               const int M, //K,\n               tapa::ostream<double_v8> & q_dout,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n/*  computation modules  */\n//M2: alpha = rzold / (p' * Ap)\nvoid dot_alpha(const int rp_time,\n               const int M,\n               //const unsigned long rz0,\n               tapa::istream<double> & qrz,\n               tapa::istream<double_v8> & q1,\n               tapa::istream<double_v8> & q2,\n               tapa::ostreams<double, 2> & q3,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M end: res = r' * r\nvoid dot_res(const int rp_time,\n             const int M,\n             const double th_termination,\n             tapa::istream<double_v8> & q1,\n             tapa::ostream<ResTerm> & q2,\n             tapa::ostream<bool> & q_termination\n             ) ;\n//M6: rznew = r' * z\nvoid dot_rznew(const int rp_time,\n               const int M,\n               tapa::istream<double_v8> & qr,\n               tapa::istream<double_v8> & qz,\n               tapa::ostream<double_v8> & qr_out,\n               tapa::ostreams<double, 2> & qrz,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M3: x = x + alpha * p\nvoid updt_x(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qx,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M7: p = z + (rznew/rzold) * p\nvoid updt_p(const int rp_time,\n            const int M,\n            //const unsigned long rz0,\n            tapa::istream<double> & qrznew,\n            tapa::istream<double_v8> & qz,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qp2m3,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M4: r = r - alpha * Ap\nvoid updt_r(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qr,\n            tapa::istream<double_v8> & qap,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M5: z = diagA \\ r\nvoid left_div(const int rp_time,\n              const int M,\n              tapa::istream<double_v8> & qr,\n              tapa::istream<double_v8> & qdiagA,\n              tapa::ostreams<double_v8, 2> & qz,\n              tapa::ostream<double_v8> & qr_m6,\n              tapa::ostream<double_v8> & qrmem,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out\n              ) ;\nvoid wr_r(const int rp_time,\n          uint64_t  vec_r,\n          tapa::istream<ResTerm> & q_din\n          ) ;\nvoid duplicator(tapa::istream<double_v8> & q_in,\n                tapa::ostream<double_v8> & q_out1,\n                tapa::ostream<double_v8> & q_out2\n                ) ;\nvoid vecp_mux(const int rp_time,\n              const int M,\n              tapa::istream<bool> & q_gbc,\n              tapa::istream<double_v8> & q_in1,\n              tapa::istream<double_v8> & q_in2,\n              tapa::ostream<double_v8> & q_out\n              ) ;\nvoid Callipepla(uint64_t  edge_list_ptr,\n                uint64_t edge_list_ch_0, uint64_t edge_list_ch_1, uint64_t edge_list_ch_2, uint64_t edge_list_ch_3, uint64_t edge_list_ch_4, uint64_t edge_list_ch_5, uint64_t edge_list_ch_6, uint64_t edge_list_ch_7, uint64_t edge_list_ch_8, uint64_t edge_list_ch_9, uint64_t edge_list_ch_10, uint64_t edge_list_ch_11, uint64_t edge_list_ch_12, uint64_t edge_list_ch_13, uint64_t edge_list_ch_14, uint64_t edge_list_ch_15,\n                uint64_t vec_x_0, uint64_t vec_x_1,\n                uint64_t vec_p_0, uint64_t vec_p_1,\n                uint64_t  vec_Ap,\n                uint64_t vec_r_0, uint64_t vec_r_1,\n                uint64_t  vec_digA,\n                uint64_t  vec_res,\n                const int NUM_ITE,\n                const int NUM_A_LEN,\n                const int M,\n                const int rp_time,\n                const double th_termination\n                ) ;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "black_hole_int": {
            "code": "\n\n #include <ap_int.h>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cassert>\n\n\n #include \"ap_utils.h\"\n\n#include <tapa.h>\n\n\n\n #include <ap_int.h>\n\n#include <tapa.h>\nconstexpr int NUM_CH_SPARSE = 16;\nconstexpr int X_PARTITION_FACTOR = 4; // BRAMs = 512 / 16 / 2 = 16 -> factor = 16 / (64 / 16)\nconstexpr int WINDOW_SIZE = X_PARTITION_FACTOR * 1024;\nconstexpr int DEP_DIST_LOAD_STORE = 7;\nconstexpr int URAM_DEPTH = 3 * 4096;\n// ch16: 3 * 4096 * 16 * 8 = 1,572,864\nusing double_v8 = tapa::vec_t<double, 8>;\nvoid Callipepla(tapa::mmap<int> edge_list_ptr,\n                tapa::mmaps<ap_uint<512>, NUM_CH_SPARSE> edge_list_ch,\n                tapa::mmaps<double_v8, 2> vec_x,\n                tapa::mmaps<double_v8, 2> vec_p,\n                tapa::mmap<double_v8> vec_Ap,\n                tapa::mmaps<double_v8, 2> vec_r,\n                tapa::mmap<double_v8> vec_digA,\n                tapa::mmap<double> vec_res,\n                const int NUM_ITE, const int NUM_A_LEN, const int M,\n                const int rp_time,\n                const double th_termination\n                );\n\nconstexpr int FIFO_DEPTH = 2;\nconstexpr int FIFO_DEPTH_M6 = 50;\nconst int NUM_CH_SPARSE_div_8 = NUM_CH_SPARSE / 8;\nconst int NUM_CH_SPARSE_mult_8 = NUM_CH_SPARSE * 8;\nconst int WINDOW_SIZE_div_8 = WINDOW_SIZE / 8;\nstruct MultXVec {\n    tapa::vec_t<ap_uint<18>, 8> row;\n    double_v8 axv;\n};\nstruct InstRdWr {\n    bool rd;\n    bool wr;\n    //bool require_response;\n    int base_addr;\n    int len;\n};\nstruct InstVCtrl {\n    bool rd;\n    bool wr;\n    int base_addr;\n    int len;\n    ap_uint<3> q_rd_idx;\n    //ap_uint<3> q_wr_idx;\n};\nstruct InstCmp {\n    int len;\n    double alpha;\n    ap_uint<3> q_idx;\n};\nstruct ResTerm {\n    double res;\n    bool term;\n};\ntemplate <typename T, typename R>\ninline void async_read(tapa::async_mmap<T> & A,\n                       tapa::ostream<T> & fifo_A,\n                       const R i_end_addr,\n                       R & i_req,\n                       R & i_resp) {\n#pragma HLS inline\n    if ((i_req < i_end_addr) &\n        !A.read_addr.full()) {\n        A.read_addr.try_write(i_req);\n        ++i_req;\n    }\n    if (!fifo_A.full() & !A.read_data.empty()) {\n        T tmp;\n        A.read_data.try_read(tmp);\n        fifo_A.try_write(tmp);\n        ++i_resp;\n    }\n}\ntemplate <typename T, typename R>\ninline void async_write(tapa::async_mmap<T> & Y_out,\n                        tapa::istream<T> & fifo_Y,\n                        const R num_ite_Y,\n                        R & i_req,\n                        R & i_resp\n                        ) {\n#pragma HLS inline\n    if ((i_req < num_ite_Y) &\n        !fifo_Y.empty() &\n        !Y_out.write_addr.full() &\n        !Y_out.write_data.full() ) {\n        Y_out.write_addr.try_write(i_req);\n        T tmpv;\n        fifo_Y.try_read(tmpv);\n        Y_out.write_data.try_write(tmpv);\n        ++i_req;\n    }\n    uint8_t n_resp;\n    if (Y_out.write_resp.try_read(n_resp)) {\n        i_resp += R(n_resp) + 1;\n    }\n}\nvoid rdwr_vec(uint64_t  vec_p,\n              tapa::istream<InstRdWr> & q_inst,\n              tapa::istream<double_v8> & q_din,\n              tapa::ostream<double_v8> & q_dout,\n              tapa::ostream<bool> & q_response\n              ) ;\ntemplate <typename data_t>\ninline void q2q(tapa::istream<data_t> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty() & !qout.full()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void clearq(tapa::istream<data_t> & qin,\n                   const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void q2q(tapa::istreams<data_t, 2> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite,\n                const int idx) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin[idx].empty() & !qout.full()) {\n            data_t tmp;\n            qin[idx].try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void qq2qq(tapa::istream<data_t> & qin_pe,\n                  tapa::ostreams<data_t, 2> & qout_mem,\n                  tapa::istreams<data_t, 2> & qin_mem,\n                  tapa::ostream<data_t> & qout_qe,\n                  const int num_ite,\n                  const int idx) {\n#pragma HLS inline\nqq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin_pe.empty() & !qout_mem[idx].full()) {\n            data_t tmp;\n            qin_pe.try_read(tmp);\n            qout_mem[idx].try_write(tmp);\n            ++i;\n        }\n        if (!qin_mem[1 - idx].empty() & !qout_qe.full()) {\n            data_t tmp;\n            qin_mem[1 - idx].try_read(tmp);\n            qout_qe.try_write(tmp);\n        }\n    }\n}\nvoid term_signal_router(tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_to_rdA,\n                        tapa::ostream<bool> & q_to_edgepointer,\n                        tapa::ostream<bool> & q_to_abiter,\n                        tapa::ostream<bool> & q_to_ctrlmem,\n                        tapa::ostream<bool> & q_to_mux\n                        ) ;\nvoid read_edge_list_ptr(const int num_ite,\n                        const int M,\n                        const int rp_time, //P_N,\n                        uint64_t  edge_list_ptr,\n                        tapa::ostream<int> & PE_inst,\n                        tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_gbc_out\n                        ) ;\nvoid read_vec(const int rp_time, //P_N\n              const int M, //K,\n              tapa::async_mmap<double_v8> & vec_X,\n              tapa::ostream<double_v8> & fifo_X\n              ) {\n    //const int rp_time = (P_N == 0)? 1 : P_N;\n    const int num_ite_X = (M + 7) >> 3;\nl_rp:\n    for(int rp = 0; rp < rp_time; rp++) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n    rd_X:\n        for(int i_req = 0, i_resp = 0; i_resp < num_ite_X;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n            async_read(vec_X,\n                       fifo_X,\n                       num_ite_X,\n                       i_req, i_resp);\n        }\n    }\n}\nvoid read_A(const int rp_time, //P_N,\n            const int A_len,\n            uint64_t  A,\n            tapa::ostream<ap_uint<512>> & fifo_A,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid PEG_Xvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<ap_uint<512>> & fifo_A,\n              tapa::istream<double_v8> & fifo_X_in,\n              tapa::ostream<int> & fifo_inst_out,\n              tapa::ostream<double_v8> & fifo_X_out,\n              // to PEG_Yvec\n              tapa::ostream<int> & fifo_inst_out_to_Yvec,\n              tapa::ostream<MultXVec> & fifo_aXvec,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out,\n              tapa::ostream<bool> & q_gbc_out_Y\n              ) ;\nvoid PEG_Yvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<MultXVec> & fifo_aXvec,\n              tapa::ostream<double> & fifo_Y_out,\n              tapa::istream<bool> & q_gbc\n              ) ;\nvoid Arbiter_Y(const int rp_time, //P_N,\n               const int M,\n               tapa::istreams<double, NUM_CH_SPARSE_div_8> & fifo_in, // 2 = 16 / 8\n               tapa::ostream<double> & fifo_out,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\nvoid Merger_Y(tapa::istreams<double, 8> & fifo_in,\n              tapa::ostreams<double_v8, 2> & fifo_out) ;\ntemplate <typename data_t>\ninline void bh(tapa::istream<data_t> & q) {\n#pragma HLS inline\n    for (;;) {\n#pragma HLS pipeline II=1\n        data_t tmp; q.try_read(tmp);\n    }\n}\nvoid black_hole_int(tapa::istream<int> & fifo_in) {\n#pragma HLS disaggregate variable = fifo_in\n#pragma HLS interface ap_fifo port = fifo_in._\n#pragma HLS aggregate variable = fifo_in._ bit\n#pragma HLS interface ap_fifo port = fifo_in._peek\n#pragma HLS aggregate variable = fifo_in._peek bit\nvoid(fifo_in._.empty());\nvoid(fifo_in._peek.empty());\n\n    bh(fifo_in);\n}\nvoid black_hole_double_v8(tapa::istream<double_v8> & fifo_in) ;\nvoid black_hole_bool(tapa::istream<bool> & fifo_in) ;\nvoid ctrl_P(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time, //P_N\n            const int M, //K,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_spmv,\n            tapa::ostream<double_v8> & q_dotp,\n            //tapa::ostream<double_v8> & q_updtx,\n            tapa::ostream<double_v8> & q_updtp,\n            tapa::istream<double_v8> & q_updated,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_AP(tapa::istream<double_v8> & qm_din,\n             tapa::ostream<double_v8> & qm_dout,\n             const int rp_time,\n             const int M,\n             tapa::ostream<InstRdWr> & q_inst,\n             tapa::ostream<double_v8> & q_updr,\n             tapa::istream<double_v8> & q_pe,\n             tapa::istream<bool> & q_res,\n             tapa::istream<bool> & q_gbc,\n             tapa::ostream<bool> & q_gbc_out\n             ) ;\nvoid ctrl_X(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_oldx,\n            tapa::istream<double_v8> & q_newx,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_R(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & qr_to_pe,\n            tapa::istream<double_v8> & qr_from_pe,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid read_digA(uint64_t  vec_mem,\n               const int rp_time, //P_N\n               const int M, //K,\n               tapa::ostream<double_v8> & q_dout,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n/*  computation modules  */\n//M2: alpha = rzold / (p' * Ap)\nvoid dot_alpha(const int rp_time,\n               const int M,\n               //const unsigned long rz0,\n               tapa::istream<double> & qrz,\n               tapa::istream<double_v8> & q1,\n               tapa::istream<double_v8> & q2,\n               tapa::ostreams<double, 2> & q3,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M end: res = r' * r\nvoid dot_res(const int rp_time,\n             const int M,\n             const double th_termination,\n             tapa::istream<double_v8> & q1,\n             tapa::ostream<ResTerm> & q2,\n             tapa::ostream<bool> & q_termination\n             ) ;\n//M6: rznew = r' * z\nvoid dot_rznew(const int rp_time,\n               const int M,\n               tapa::istream<double_v8> & qr,\n               tapa::istream<double_v8> & qz,\n               tapa::ostream<double_v8> & qr_out,\n               tapa::ostreams<double, 2> & qrz,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M3: x = x + alpha * p\nvoid updt_x(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qx,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M7: p = z + (rznew/rzold) * p\nvoid updt_p(const int rp_time,\n            const int M,\n            //const unsigned long rz0,\n            tapa::istream<double> & qrznew,\n            tapa::istream<double_v8> & qz,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qp2m3,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M4: r = r - alpha * Ap\nvoid updt_r(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qr,\n            tapa::istream<double_v8> & qap,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M5: z = diagA \\ r\nvoid left_div(const int rp_time,\n              const int M,\n              tapa::istream<double_v8> & qr,\n              tapa::istream<double_v8> & qdiagA,\n              tapa::ostreams<double_v8, 2> & qz,\n              tapa::ostream<double_v8> & qr_m6,\n              tapa::ostream<double_v8> & qrmem,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out\n              ) ;\nvoid wr_r(const int rp_time,\n          uint64_t  vec_r,\n          tapa::istream<ResTerm> & q_din\n          ) ;\nvoid duplicator(tapa::istream<double_v8> & q_in,\n                tapa::ostream<double_v8> & q_out1,\n                tapa::ostream<double_v8> & q_out2\n                ) ;\nvoid vecp_mux(const int rp_time,\n              const int M,\n              tapa::istream<bool> & q_gbc,\n              tapa::istream<double_v8> & q_in1,\n              tapa::istream<double_v8> & q_in2,\n              tapa::ostream<double_v8> & q_out\n              ) ;\nvoid Callipepla(uint64_t  edge_list_ptr,\n                uint64_t edge_list_ch_0, uint64_t edge_list_ch_1, uint64_t edge_list_ch_2, uint64_t edge_list_ch_3, uint64_t edge_list_ch_4, uint64_t edge_list_ch_5, uint64_t edge_list_ch_6, uint64_t edge_list_ch_7, uint64_t edge_list_ch_8, uint64_t edge_list_ch_9, uint64_t edge_list_ch_10, uint64_t edge_list_ch_11, uint64_t edge_list_ch_12, uint64_t edge_list_ch_13, uint64_t edge_list_ch_14, uint64_t edge_list_ch_15,\n                uint64_t vec_x_0, uint64_t vec_x_1,\n                uint64_t vec_p_0, uint64_t vec_p_1,\n                uint64_t  vec_Ap,\n                uint64_t vec_r_0, uint64_t vec_r_1,\n                uint64_t  vec_digA,\n                uint64_t  vec_res,\n                const int NUM_ITE,\n                const int NUM_A_LEN,\n                const int M,\n                const int rp_time,\n                const double th_termination\n                ) ;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "ctrl_AP": {
            "code": "\n\n #include <ap_int.h>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cassert>\n\n\n #include \"ap_utils.h\"\n\n#include <tapa.h>\n\n\n\n #include <ap_int.h>\n\n#include <tapa.h>\nconstexpr int NUM_CH_SPARSE = 16;\nconstexpr int X_PARTITION_FACTOR = 4; // BRAMs = 512 / 16 / 2 = 16 -> factor = 16 / (64 / 16)\nconstexpr int WINDOW_SIZE = X_PARTITION_FACTOR * 1024;\nconstexpr int DEP_DIST_LOAD_STORE = 7;\nconstexpr int URAM_DEPTH = 3 * 4096;\n// ch16: 3 * 4096 * 16 * 8 = 1,572,864\nusing double_v8 = tapa::vec_t<double, 8>;\nvoid Callipepla(tapa::mmap<int> edge_list_ptr,\n                tapa::mmaps<ap_uint<512>, NUM_CH_SPARSE> edge_list_ch,\n                tapa::mmaps<double_v8, 2> vec_x,\n                tapa::mmaps<double_v8, 2> vec_p,\n                tapa::mmap<double_v8> vec_Ap,\n                tapa::mmaps<double_v8, 2> vec_r,\n                tapa::mmap<double_v8> vec_digA,\n                tapa::mmap<double> vec_res,\n                const int NUM_ITE, const int NUM_A_LEN, const int M,\n                const int rp_time,\n                const double th_termination\n                );\n\nconstexpr int FIFO_DEPTH = 2;\nconstexpr int FIFO_DEPTH_M6 = 50;\nconst int NUM_CH_SPARSE_div_8 = NUM_CH_SPARSE / 8;\nconst int NUM_CH_SPARSE_mult_8 = NUM_CH_SPARSE * 8;\nconst int WINDOW_SIZE_div_8 = WINDOW_SIZE / 8;\nstruct MultXVec {\n    tapa::vec_t<ap_uint<18>, 8> row;\n    double_v8 axv;\n};\nstruct InstRdWr {\n    bool rd;\n    bool wr;\n    //bool require_response;\n    int base_addr;\n    int len;\n};\nstruct InstVCtrl {\n    bool rd;\n    bool wr;\n    int base_addr;\n    int len;\n    ap_uint<3> q_rd_idx;\n    //ap_uint<3> q_wr_idx;\n};\nstruct InstCmp {\n    int len;\n    double alpha;\n    ap_uint<3> q_idx;\n};\nstruct ResTerm {\n    double res;\n    bool term;\n};\ntemplate <typename T, typename R>\ninline void async_read(tapa::async_mmap<T> & A,\n                       tapa::ostream<T> & fifo_A,\n                       const R i_end_addr,\n                       R & i_req,\n                       R & i_resp) {\n#pragma HLS inline\n    if ((i_req < i_end_addr) &\n        !A.read_addr.full()) {\n        A.read_addr.try_write(i_req);\n        ++i_req;\n    }\n    if (!fifo_A.full() & !A.read_data.empty()) {\n        T tmp;\n        A.read_data.try_read(tmp);\n        fifo_A.try_write(tmp);\n        ++i_resp;\n    }\n}\ntemplate <typename T, typename R>\ninline void async_write(tapa::async_mmap<T> & Y_out,\n                        tapa::istream<T> & fifo_Y,\n                        const R num_ite_Y,\n                        R & i_req,\n                        R & i_resp\n                        ) {\n#pragma HLS inline\n    if ((i_req < num_ite_Y) &\n        !fifo_Y.empty() &\n        !Y_out.write_addr.full() &\n        !Y_out.write_data.full() ) {\n        Y_out.write_addr.try_write(i_req);\n        T tmpv;\n        fifo_Y.try_read(tmpv);\n        Y_out.write_data.try_write(tmpv);\n        ++i_req;\n    }\n    uint8_t n_resp;\n    if (Y_out.write_resp.try_read(n_resp)) {\n        i_resp += R(n_resp) + 1;\n    }\n}\nvoid rdwr_vec(uint64_t  vec_p,\n              tapa::istream<InstRdWr> & q_inst,\n              tapa::istream<double_v8> & q_din,\n              tapa::ostream<double_v8> & q_dout,\n              tapa::ostream<bool> & q_response\n              ) ;\ntemplate <typename data_t>\ninline void q2q(tapa::istream<data_t> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty() & !qout.full()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void clearq(tapa::istream<data_t> & qin,\n                   const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void q2q(tapa::istreams<data_t, 2> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite,\n                const int idx) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin[idx].empty() & !qout.full()) {\n            data_t tmp;\n            qin[idx].try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void qq2qq(tapa::istream<data_t> & qin_pe,\n                  tapa::ostreams<data_t, 2> & qout_mem,\n                  tapa::istreams<data_t, 2> & qin_mem,\n                  tapa::ostream<data_t> & qout_qe,\n                  const int num_ite,\n                  const int idx) {\n#pragma HLS inline\nqq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin_pe.empty() & !qout_mem[idx].full()) {\n            data_t tmp;\n            qin_pe.try_read(tmp);\n            qout_mem[idx].try_write(tmp);\n            ++i;\n        }\n        if (!qin_mem[1 - idx].empty() & !qout_qe.full()) {\n            data_t tmp;\n            qin_mem[1 - idx].try_read(tmp);\n            qout_qe.try_write(tmp);\n        }\n    }\n}\nvoid term_signal_router(tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_to_rdA,\n                        tapa::ostream<bool> & q_to_edgepointer,\n                        tapa::ostream<bool> & q_to_abiter,\n                        tapa::ostream<bool> & q_to_ctrlmem,\n                        tapa::ostream<bool> & q_to_mux\n                        ) ;\nvoid read_edge_list_ptr(const int num_ite,\n                        const int M,\n                        const int rp_time, //P_N,\n                        uint64_t  edge_list_ptr,\n                        tapa::ostream<int> & PE_inst,\n                        tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_gbc_out\n                        ) ;\nvoid read_vec(const int rp_time, //P_N\n              const int M, //K,\n              tapa::async_mmap<double_v8> & vec_X,\n              tapa::ostream<double_v8> & fifo_X\n              ) {\n    //const int rp_time = (P_N == 0)? 1 : P_N;\n    const int num_ite_X = (M + 7) >> 3;\nl_rp:\n    for(int rp = 0; rp < rp_time; rp++) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n    rd_X:\n        for(int i_req = 0, i_resp = 0; i_resp < num_ite_X;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n            async_read(vec_X,\n                       fifo_X,\n                       num_ite_X,\n                       i_req, i_resp);\n        }\n    }\n}\nvoid read_A(const int rp_time, //P_N,\n            const int A_len,\n            uint64_t  A,\n            tapa::ostream<ap_uint<512>> & fifo_A,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid PEG_Xvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<ap_uint<512>> & fifo_A,\n              tapa::istream<double_v8> & fifo_X_in,\n              tapa::ostream<int> & fifo_inst_out,\n              tapa::ostream<double_v8> & fifo_X_out,\n              // to PEG_Yvec\n              tapa::ostream<int> & fifo_inst_out_to_Yvec,\n              tapa::ostream<MultXVec> & fifo_aXvec,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out,\n              tapa::ostream<bool> & q_gbc_out_Y\n              ) ;\nvoid PEG_Yvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<MultXVec> & fifo_aXvec,\n              tapa::ostream<double> & fifo_Y_out,\n              tapa::istream<bool> & q_gbc\n              ) ;\nvoid Arbiter_Y(const int rp_time, //P_N,\n               const int M,\n               tapa::istreams<double, NUM_CH_SPARSE_div_8> & fifo_in, // 2 = 16 / 8\n               tapa::ostream<double> & fifo_out,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\nvoid Merger_Y(tapa::istreams<double, 8> & fifo_in,\n              tapa::ostreams<double_v8, 2> & fifo_out) ;\ntemplate <typename data_t>\ninline void bh(tapa::istream<data_t> & q) {\n#pragma HLS inline\n    for (;;) {\n#pragma HLS pipeline II=1\n        data_t tmp; q.try_read(tmp);\n    }\n}\nvoid black_hole_int(tapa::istream<int> & fifo_in) ;\nvoid black_hole_double_v8(tapa::istream<double_v8> & fifo_in) ;\nvoid black_hole_bool(tapa::istream<bool> & fifo_in) ;\nvoid ctrl_P(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time, //P_N\n            const int M, //K,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_spmv,\n            tapa::ostream<double_v8> & q_dotp,\n            //tapa::ostream<double_v8> & q_updtx,\n            tapa::ostream<double_v8> & q_updtp,\n            tapa::istream<double_v8> & q_updated,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_AP(tapa::istream<double_v8> & qm_din,\n             tapa::ostream<double_v8> & qm_dout,\n             const int rp_time,\n             const int M,\n             tapa::ostream<InstRdWr> & q_inst,\n             tapa::ostream<double_v8> & q_updr,\n             tapa::istream<double_v8> & q_pe,\n             tapa::istream<bool> & q_res,\n             tapa::istream<bool> & q_gbc,\n             tapa::ostream<bool> & q_gbc_out\n             ) {\n#pragma HLS disaggregate variable = qm_din\n#pragma HLS interface ap_fifo port = qm_din._\n#pragma HLS aggregate variable = qm_din._ bit\n#pragma HLS interface ap_fifo port = qm_din._peek\n#pragma HLS aggregate variable = qm_din._peek bit\nvoid(qm_din._.empty());\nvoid(qm_din._peek.empty());\n\n#pragma HLS disaggregate variable = qm_dout\n#pragma HLS interface ap_fifo port = qm_dout._\n#pragma HLS aggregate variable = qm_dout._ bit\nvoid(qm_dout._.full());\n\n\n\n#pragma HLS disaggregate variable = q_inst\n#pragma HLS interface ap_fifo port = q_inst._\n#pragma HLS aggregate variable = q_inst._ bit\nvoid(q_inst._.full());\n\n#pragma HLS disaggregate variable = q_updr\n#pragma HLS interface ap_fifo port = q_updr._\n#pragma HLS aggregate variable = q_updr._ bit\nvoid(q_updr._.full());\n\n#pragma HLS disaggregate variable = q_pe\n#pragma HLS interface ap_fifo port = q_pe._\n#pragma HLS aggregate variable = q_pe._ bit\n#pragma HLS interface ap_fifo port = q_pe._peek\n#pragma HLS aggregate variable = q_pe._peek bit\nvoid(q_pe._.empty());\nvoid(q_pe._peek.empty());\n\n#pragma HLS disaggregate variable = q_res\n#pragma HLS interface ap_fifo port = q_res._\n#pragma HLS aggregate variable = q_res._ bit\n#pragma HLS interface ap_fifo port = q_res._peek\n#pragma HLS aggregate variable = q_res._peek bit\nvoid(q_res._.empty());\nvoid(q_res._peek.empty());\n\n#pragma HLS disaggregate variable = q_gbc\n#pragma HLS interface ap_fifo port = q_gbc._\n#pragma HLS aggregate variable = q_gbc._ bit\n#pragma HLS interface ap_fifo port = q_gbc._peek\n#pragma HLS aggregate variable = q_gbc._peek bit\nvoid(q_gbc._.empty());\nvoid(q_gbc._peek.empty());\n\n#pragma HLS disaggregate variable = q_gbc_out\n#pragma HLS interface ap_fifo port = q_gbc_out._\n#pragma HLS aggregate variable = q_gbc_out._ bit\nvoid(q_gbc_out._.full());\n\n    // InstVCtrl vinst1 = {false, true, 0, (M + 7) >> 3, q_dout};\n    // InstVCtrl vinst2 x 2 = {true, false, 0, (M + 7) >> 3, q_updr};\n    const int num_ite_M = (M + 7) >> 3;\n    bool term_flag = false;\nl_rp:\n    for(int rp = -1, ch = 0; !term_flag & (rp < rp_time); rp++) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n        InstRdWr ist;\n        // 0 -- wr: q_pe -> q_dout\n        ist.rd = false;\n        ist.wr = true;\n        ist.base_addr = 0;\n        ist.len = num_ite_M;\n        q_inst.write(ist);\n        ap_wait();\n        q2q(q_pe,\n            qm_dout,\n            ist.len);\n        ap_wait();\n        q_res.read();\n        ap_wait();\n        // 1 -- rd: q_din -> q_updr\n        ist.rd = true;\n        ist.wr = false;\n        //ist.base_addr = 0;\n        //ist.len = num_ite;\n        for (int l = 0; l < 2; ++l) {\n#pragma HLS loop_flatten off\n            q_inst.write(ist);\n            ap_wait();\n            q2q(qm_din,\n                q_updr,\n                ist.len);\n        }\n        ap_wait();\n        term_flag = q_gbc.read();\n        q_gbc_out.write(term_flag);\n    }\n    //cout << \"## exit ctrl_AP\\n\";\n}\nvoid ctrl_X(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_oldx,\n            tapa::istream<double_v8> & q_newx,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_R(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & qr_to_pe,\n            tapa::istream<double_v8> & qr_from_pe,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid read_digA(uint64_t  vec_mem,\n               const int rp_time, //P_N\n               const int M, //K,\n               tapa::ostream<double_v8> & q_dout,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n/*  computation modules  */\n//M2: alpha = rzold / (p' * Ap)\nvoid dot_alpha(const int rp_time,\n               const int M,\n               //const unsigned long rz0,\n               tapa::istream<double> & qrz,\n               tapa::istream<double_v8> & q1,\n               tapa::istream<double_v8> & q2,\n               tapa::ostreams<double, 2> & q3,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M end: res = r' * r\nvoid dot_res(const int rp_time,\n             const int M,\n             const double th_termination,\n             tapa::istream<double_v8> & q1,\n             tapa::ostream<ResTerm> & q2,\n             tapa::ostream<bool> & q_termination\n             ) ;\n//M6: rznew = r' * z\nvoid dot_rznew(const int rp_time,\n               const int M,\n               tapa::istream<double_v8> & qr,\n               tapa::istream<double_v8> & qz,\n               tapa::ostream<double_v8> & qr_out,\n               tapa::ostreams<double, 2> & qrz,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M3: x = x + alpha * p\nvoid updt_x(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qx,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M7: p = z + (rznew/rzold) * p\nvoid updt_p(const int rp_time,\n            const int M,\n            //const unsigned long rz0,\n            tapa::istream<double> & qrznew,\n            tapa::istream<double_v8> & qz,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qp2m3,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M4: r = r - alpha * Ap\nvoid updt_r(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qr,\n            tapa::istream<double_v8> & qap,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M5: z = diagA \\ r\nvoid left_div(const int rp_time,\n              const int M,\n              tapa::istream<double_v8> & qr,\n              tapa::istream<double_v8> & qdiagA,\n              tapa::ostreams<double_v8, 2> & qz,\n              tapa::ostream<double_v8> & qr_m6,\n              tapa::ostream<double_v8> & qrmem,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out\n              ) ;\nvoid wr_r(const int rp_time,\n          uint64_t  vec_r,\n          tapa::istream<ResTerm> & q_din\n          ) ;\nvoid duplicator(tapa::istream<double_v8> & q_in,\n                tapa::ostream<double_v8> & q_out1,\n                tapa::ostream<double_v8> & q_out2\n                ) ;\nvoid vecp_mux(const int rp_time,\n              const int M,\n              tapa::istream<bool> & q_gbc,\n              tapa::istream<double_v8> & q_in1,\n              tapa::istream<double_v8> & q_in2,\n              tapa::ostream<double_v8> & q_out\n              ) ;\nvoid Callipepla(uint64_t  edge_list_ptr,\n                uint64_t edge_list_ch_0, uint64_t edge_list_ch_1, uint64_t edge_list_ch_2, uint64_t edge_list_ch_3, uint64_t edge_list_ch_4, uint64_t edge_list_ch_5, uint64_t edge_list_ch_6, uint64_t edge_list_ch_7, uint64_t edge_list_ch_8, uint64_t edge_list_ch_9, uint64_t edge_list_ch_10, uint64_t edge_list_ch_11, uint64_t edge_list_ch_12, uint64_t edge_list_ch_13, uint64_t edge_list_ch_14, uint64_t edge_list_ch_15,\n                uint64_t vec_x_0, uint64_t vec_x_1,\n                uint64_t vec_p_0, uint64_t vec_p_1,\n                uint64_t  vec_Ap,\n                uint64_t vec_r_0, uint64_t vec_r_1,\n                uint64_t  vec_digA,\n                uint64_t  vec_res,\n                const int NUM_ITE,\n                const int NUM_A_LEN,\n                const int M,\n                const int rp_time,\n                const double th_termination\n                ) ;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "ctrl_P": {
            "code": "\n\n #include <ap_int.h>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cassert>\n\n\n #include \"ap_utils.h\"\n\n#include <tapa.h>\n\n\n\n #include <ap_int.h>\n\n#include <tapa.h>\nconstexpr int NUM_CH_SPARSE = 16;\nconstexpr int X_PARTITION_FACTOR = 4; // BRAMs = 512 / 16 / 2 = 16 -> factor = 16 / (64 / 16)\nconstexpr int WINDOW_SIZE = X_PARTITION_FACTOR * 1024;\nconstexpr int DEP_DIST_LOAD_STORE = 7;\nconstexpr int URAM_DEPTH = 3 * 4096;\n// ch16: 3 * 4096 * 16 * 8 = 1,572,864\nusing double_v8 = tapa::vec_t<double, 8>;\nvoid Callipepla(tapa::mmap<int> edge_list_ptr,\n                tapa::mmaps<ap_uint<512>, NUM_CH_SPARSE> edge_list_ch,\n                tapa::mmaps<double_v8, 2> vec_x,\n                tapa::mmaps<double_v8, 2> vec_p,\n                tapa::mmap<double_v8> vec_Ap,\n                tapa::mmaps<double_v8, 2> vec_r,\n                tapa::mmap<double_v8> vec_digA,\n                tapa::mmap<double> vec_res,\n                const int NUM_ITE, const int NUM_A_LEN, const int M,\n                const int rp_time,\n                const double th_termination\n                );\n\nconstexpr int FIFO_DEPTH = 2;\nconstexpr int FIFO_DEPTH_M6 = 50;\nconst int NUM_CH_SPARSE_div_8 = NUM_CH_SPARSE / 8;\nconst int NUM_CH_SPARSE_mult_8 = NUM_CH_SPARSE * 8;\nconst int WINDOW_SIZE_div_8 = WINDOW_SIZE / 8;\nstruct MultXVec {\n    tapa::vec_t<ap_uint<18>, 8> row;\n    double_v8 axv;\n};\nstruct InstRdWr {\n    bool rd;\n    bool wr;\n    //bool require_response;\n    int base_addr;\n    int len;\n};\nstruct InstVCtrl {\n    bool rd;\n    bool wr;\n    int base_addr;\n    int len;\n    ap_uint<3> q_rd_idx;\n    //ap_uint<3> q_wr_idx;\n};\nstruct InstCmp {\n    int len;\n    double alpha;\n    ap_uint<3> q_idx;\n};\nstruct ResTerm {\n    double res;\n    bool term;\n};\ntemplate <typename T, typename R>\ninline void async_read(tapa::async_mmap<T> & A,\n                       tapa::ostream<T> & fifo_A,\n                       const R i_end_addr,\n                       R & i_req,\n                       R & i_resp) {\n#pragma HLS inline\n    if ((i_req < i_end_addr) &\n        !A.read_addr.full()) {\n        A.read_addr.try_write(i_req);\n        ++i_req;\n    }\n    if (!fifo_A.full() & !A.read_data.empty()) {\n        T tmp;\n        A.read_data.try_read(tmp);\n        fifo_A.try_write(tmp);\n        ++i_resp;\n    }\n}\ntemplate <typename T, typename R>\ninline void async_write(tapa::async_mmap<T> & Y_out,\n                        tapa::istream<T> & fifo_Y,\n                        const R num_ite_Y,\n                        R & i_req,\n                        R & i_resp\n                        ) {\n#pragma HLS inline\n    if ((i_req < num_ite_Y) &\n        !fifo_Y.empty() &\n        !Y_out.write_addr.full() &\n        !Y_out.write_data.full() ) {\n        Y_out.write_addr.try_write(i_req);\n        T tmpv;\n        fifo_Y.try_read(tmpv);\n        Y_out.write_data.try_write(tmpv);\n        ++i_req;\n    }\n    uint8_t n_resp;\n    if (Y_out.write_resp.try_read(n_resp)) {\n        i_resp += R(n_resp) + 1;\n    }\n}\nvoid rdwr_vec(uint64_t  vec_p,\n              tapa::istream<InstRdWr> & q_inst,\n              tapa::istream<double_v8> & q_din,\n              tapa::ostream<double_v8> & q_dout,\n              tapa::ostream<bool> & q_response\n              ) ;\ntemplate <typename data_t>\ninline void q2q(tapa::istream<data_t> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty() & !qout.full()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void clearq(tapa::istream<data_t> & qin,\n                   const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void q2q(tapa::istreams<data_t, 2> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite,\n                const int idx) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin[idx].empty() & !qout.full()) {\n            data_t tmp;\n            qin[idx].try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void qq2qq(tapa::istream<data_t> & qin_pe,\n                  tapa::ostreams<data_t, 2> & qout_mem,\n                  tapa::istreams<data_t, 2> & qin_mem,\n                  tapa::ostream<data_t> & qout_qe,\n                  const int num_ite,\n                  const int idx) {\n#pragma HLS inline\nqq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin_pe.empty() & !qout_mem[idx].full()) {\n            data_t tmp;\n            qin_pe.try_read(tmp);\n            qout_mem[idx].try_write(tmp);\n            ++i;\n        }\n        if (!qin_mem[1 - idx].empty() & !qout_qe.full()) {\n            data_t tmp;\n            qin_mem[1 - idx].try_read(tmp);\n            qout_qe.try_write(tmp);\n        }\n    }\n}\nvoid term_signal_router(tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_to_rdA,\n                        tapa::ostream<bool> & q_to_edgepointer,\n                        tapa::ostream<bool> & q_to_abiter,\n                        tapa::ostream<bool> & q_to_ctrlmem,\n                        tapa::ostream<bool> & q_to_mux\n                        ) ;\nvoid read_edge_list_ptr(const int num_ite,\n                        const int M,\n                        const int rp_time, //P_N,\n                        uint64_t  edge_list_ptr,\n                        tapa::ostream<int> & PE_inst,\n                        tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_gbc_out\n                        ) ;\nvoid read_vec(const int rp_time, //P_N\n              const int M, //K,\n              tapa::async_mmap<double_v8> & vec_X,\n              tapa::ostream<double_v8> & fifo_X\n              ) {\n    //const int rp_time = (P_N == 0)? 1 : P_N;\n    const int num_ite_X = (M + 7) >> 3;\nl_rp:\n    for(int rp = 0; rp < rp_time; rp++) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n    rd_X:\n        for(int i_req = 0, i_resp = 0; i_resp < num_ite_X;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n            async_read(vec_X,\n                       fifo_X,\n                       num_ite_X,\n                       i_req, i_resp);\n        }\n    }\n}\nvoid read_A(const int rp_time, //P_N,\n            const int A_len,\n            uint64_t  A,\n            tapa::ostream<ap_uint<512>> & fifo_A,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid PEG_Xvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<ap_uint<512>> & fifo_A,\n              tapa::istream<double_v8> & fifo_X_in,\n              tapa::ostream<int> & fifo_inst_out,\n              tapa::ostream<double_v8> & fifo_X_out,\n              // to PEG_Yvec\n              tapa::ostream<int> & fifo_inst_out_to_Yvec,\n              tapa::ostream<MultXVec> & fifo_aXvec,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out,\n              tapa::ostream<bool> & q_gbc_out_Y\n              ) ;\nvoid PEG_Yvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<MultXVec> & fifo_aXvec,\n              tapa::ostream<double> & fifo_Y_out,\n              tapa::istream<bool> & q_gbc\n              ) ;\nvoid Arbiter_Y(const int rp_time, //P_N,\n               const int M,\n               tapa::istreams<double, NUM_CH_SPARSE_div_8> & fifo_in, // 2 = 16 / 8\n               tapa::ostream<double> & fifo_out,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\nvoid Merger_Y(tapa::istreams<double, 8> & fifo_in,\n              tapa::ostreams<double_v8, 2> & fifo_out) ;\ntemplate <typename data_t>\ninline void bh(tapa::istream<data_t> & q) {\n#pragma HLS inline\n    for (;;) {\n#pragma HLS pipeline II=1\n        data_t tmp; q.try_read(tmp);\n    }\n}\nvoid black_hole_int(tapa::istream<int> & fifo_in) ;\nvoid black_hole_double_v8(tapa::istream<double_v8> & fifo_in) ;\nvoid black_hole_bool(tapa::istream<bool> & fifo_in) ;\nvoid ctrl_P(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time, //P_N\n            const int M, //K,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_spmv,\n            tapa::ostream<double_v8> & q_dotp,\n            //tapa::ostream<double_v8> & q_updtx,\n            tapa::ostream<double_v8> & q_updtp,\n            tapa::istream<double_v8> & q_updated,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) {\n#pragma HLS disaggregate variable = qm_din\n#pragma HLS array_partition variable = qm_din complete\n#pragma HLS interface ap_fifo port = qm_din[0]._\n#pragma HLS aggregate variable = qm_din[0]._ bit\n#pragma HLS interface ap_fifo port = qm_din[0]._peek\n#pragma HLS aggregate variable = qm_din[0]._peek bit\nvoid(qm_din[0]._.empty());\nvoid(qm_din[0]._peek.empty());\n#pragma HLS interface ap_fifo port = qm_din[1]._\n#pragma HLS aggregate variable = qm_din[1]._ bit\n#pragma HLS interface ap_fifo port = qm_din[1]._peek\n#pragma HLS aggregate variable = qm_din[1]._peek bit\nvoid(qm_din[1]._.empty());\nvoid(qm_din[1]._peek.empty());\n\n#pragma HLS disaggregate variable = qm_dout\n#pragma HLS array_partition variable = qm_dout complete\n#pragma HLS interface ap_fifo port = qm_dout[0]._\n#pragma HLS aggregate variable = qm_dout[0]._ bit\nvoid(qm_dout[0]._.full());\n#pragma HLS interface ap_fifo port = qm_dout[1]._\n#pragma HLS aggregate variable = qm_dout[1]._ bit\nvoid(qm_dout[1]._.full());\n\n\n\n#pragma HLS disaggregate variable = q_inst\n#pragma HLS array_partition variable = q_inst complete\n#pragma HLS interface ap_fifo port = q_inst[0]._\n#pragma HLS aggregate variable = q_inst[0]._ bit\nvoid(q_inst[0]._.full());\n#pragma HLS interface ap_fifo port = q_inst[1]._\n#pragma HLS aggregate variable = q_inst[1]._ bit\nvoid(q_inst[1]._.full());\n\n#pragma HLS disaggregate variable = q_spmv\n#pragma HLS interface ap_fifo port = q_spmv._\n#pragma HLS aggregate variable = q_spmv._ bit\nvoid(q_spmv._.full());\n\n#pragma HLS disaggregate variable = q_dotp\n#pragma HLS interface ap_fifo port = q_dotp._\n#pragma HLS aggregate variable = q_dotp._ bit\nvoid(q_dotp._.full());\n\n#pragma HLS disaggregate variable = q_updtp\n#pragma HLS interface ap_fifo port = q_updtp._\n#pragma HLS aggregate variable = q_updtp._ bit\nvoid(q_updtp._.full());\n\n#pragma HLS disaggregate variable = q_updated\n#pragma HLS interface ap_fifo port = q_updated._\n#pragma HLS aggregate variable = q_updated._ bit\n#pragma HLS interface ap_fifo port = q_updated._peek\n#pragma HLS aggregate variable = q_updated._peek bit\nvoid(q_updated._.empty());\nvoid(q_updated._peek.empty());\n\n#pragma HLS disaggregate variable = q_res\n#pragma HLS array_partition variable = q_res complete\n#pragma HLS interface ap_fifo port = q_res[0]._\n#pragma HLS aggregate variable = q_res[0]._ bit\n#pragma HLS interface ap_fifo port = q_res[0]._peek\n#pragma HLS aggregate variable = q_res[0]._peek bit\nvoid(q_res[0]._.empty());\nvoid(q_res[0]._peek.empty());\n#pragma HLS interface ap_fifo port = q_res[1]._\n#pragma HLS aggregate variable = q_res[1]._ bit\n#pragma HLS interface ap_fifo port = q_res[1]._peek\n#pragma HLS aggregate variable = q_res[1]._peek bit\nvoid(q_res[1]._.empty());\nvoid(q_res[1]._peek.empty());\n\n#pragma HLS disaggregate variable = q_gbc\n#pragma HLS interface ap_fifo port = q_gbc._\n#pragma HLS aggregate variable = q_gbc._ bit\n#pragma HLS interface ap_fifo port = q_gbc._peek\n#pragma HLS aggregate variable = q_gbc._peek bit\nvoid(q_gbc._.empty());\nvoid(q_gbc._peek.empty());\n\n#pragma HLS disaggregate variable = q_gbc_out\n#pragma HLS interface ap_fifo port = q_gbc_out._\n#pragma HLS aggregate variable = q_gbc_out._ bit\nvoid(q_gbc_out._.full());\n\n    // InstVCtrl vinst1 = {true, false, 0, (M + 7) >> 3, q_spmv};\n    // InstVCtrl vinst2 = {true, false, 0, (M + 7) >> 3, q_dotp};\n    // InstVCtrl vinst3 = {true, true, 0, (M + 7) >> 3, q_dotp};\n    const int num_ite_M = (M + 7) >> 3;\n    bool term_flag = false;\nl_rp:\n    for(int rp = -1, ch = 0; !term_flag & (rp < rp_time); rp++, ch = 1 - ch) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n        InstRdWr ist;\n        //0 -- rd: q_mem -> q_spmv\n        ist.rd = true;\n        ist.wr = false;\n        //ist.require_response = false;//0;\n        ist.base_addr = 0;\n        ist.len = num_ite_M;\n        if (rp == -1) {\n            q_inst[ch].write(ist);\n            ap_wait();\n            q2q(qm_din,\n                q_spmv,\n                ist.len,\n                ch);\n            ap_wait();\n        }\n        //1 -- rd: q_mem -> q_dotp\n        //ist.rdwr = false;//0;\n        //ist.base_addr = 0;\n        //ist.len = num_ite;\n        q_inst[ch].write(ist);\n        ap_wait();\n        q2q(qm_din,\n            q_dotp,\n            ist.len,\n            ch);\n        ap_wait();\n        //3 -- (1)rd: q_mem -> q_updtp, (2)wr: q_updated -> q_dout\n        //ist.rdwr = false;//0;\n        //ist.base_addr = 0;\n        //ist.len = num_ite;\n        q_inst[ch].write(ist);\n        ap_wait();\n        ist.rd = false;\n        ist.wr = true;\n        //ist.base_addr = 0;\n        //ist.len = num_ite;\n        q_inst[1 - ch].write(ist);\n        ap_wait();\n        qq2qq(q_updated,\n              qm_dout,\n              qm_din,\n              q_updtp,\n              ist.len,\n              1 - ch);\n        ap_wait();\n        q_res[1 - ch].read();\n        ap_wait();\n        term_flag = q_gbc.read();\n        q_gbc_out.write(term_flag);\n    }\n    //cout << \"## exit ctrl_P\\n\";\n}\nvoid ctrl_AP(tapa::istream<double_v8> & qm_din,\n             tapa::ostream<double_v8> & qm_dout,\n             const int rp_time,\n             const int M,\n             tapa::ostream<InstRdWr> & q_inst,\n             tapa::ostream<double_v8> & q_updr,\n             tapa::istream<double_v8> & q_pe,\n             tapa::istream<bool> & q_res,\n             tapa::istream<bool> & q_gbc,\n             tapa::ostream<bool> & q_gbc_out\n             ) ;\nvoid ctrl_X(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_oldx,\n            tapa::istream<double_v8> & q_newx,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_R(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & qr_to_pe,\n            tapa::istream<double_v8> & qr_from_pe,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid read_digA(uint64_t  vec_mem,\n               const int rp_time, //P_N\n               const int M, //K,\n               tapa::ostream<double_v8> & q_dout,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n/*  computation modules  */\n//M2: alpha = rzold / (p' * Ap)\nvoid dot_alpha(const int rp_time,\n               const int M,\n               //const unsigned long rz0,\n               tapa::istream<double> & qrz,\n               tapa::istream<double_v8> & q1,\n               tapa::istream<double_v8> & q2,\n               tapa::ostreams<double, 2> & q3,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M end: res = r' * r\nvoid dot_res(const int rp_time,\n             const int M,\n             const double th_termination,\n             tapa::istream<double_v8> & q1,\n             tapa::ostream<ResTerm> & q2,\n             tapa::ostream<bool> & q_termination\n             ) ;\n//M6: rznew = r' * z\nvoid dot_rznew(const int rp_time,\n               const int M,\n               tapa::istream<double_v8> & qr,\n               tapa::istream<double_v8> & qz,\n               tapa::ostream<double_v8> & qr_out,\n               tapa::ostreams<double, 2> & qrz,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M3: x = x + alpha * p\nvoid updt_x(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qx,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M7: p = z + (rznew/rzold) * p\nvoid updt_p(const int rp_time,\n            const int M,\n            //const unsigned long rz0,\n            tapa::istream<double> & qrznew,\n            tapa::istream<double_v8> & qz,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qp2m3,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M4: r = r - alpha * Ap\nvoid updt_r(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qr,\n            tapa::istream<double_v8> & qap,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M5: z = diagA \\ r\nvoid left_div(const int rp_time,\n              const int M,\n              tapa::istream<double_v8> & qr,\n              tapa::istream<double_v8> & qdiagA,\n              tapa::ostreams<double_v8, 2> & qz,\n              tapa::ostream<double_v8> & qr_m6,\n              tapa::ostream<double_v8> & qrmem,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out\n              ) ;\nvoid wr_r(const int rp_time,\n          uint64_t  vec_r,\n          tapa::istream<ResTerm> & q_din\n          ) ;\nvoid duplicator(tapa::istream<double_v8> & q_in,\n                tapa::ostream<double_v8> & q_out1,\n                tapa::ostream<double_v8> & q_out2\n                ) ;\nvoid vecp_mux(const int rp_time,\n              const int M,\n              tapa::istream<bool> & q_gbc,\n              tapa::istream<double_v8> & q_in1,\n              tapa::istream<double_v8> & q_in2,\n              tapa::ostream<double_v8> & q_out\n              ) ;\nvoid Callipepla(uint64_t  edge_list_ptr,\n                uint64_t edge_list_ch_0, uint64_t edge_list_ch_1, uint64_t edge_list_ch_2, uint64_t edge_list_ch_3, uint64_t edge_list_ch_4, uint64_t edge_list_ch_5, uint64_t edge_list_ch_6, uint64_t edge_list_ch_7, uint64_t edge_list_ch_8, uint64_t edge_list_ch_9, uint64_t edge_list_ch_10, uint64_t edge_list_ch_11, uint64_t edge_list_ch_12, uint64_t edge_list_ch_13, uint64_t edge_list_ch_14, uint64_t edge_list_ch_15,\n                uint64_t vec_x_0, uint64_t vec_x_1,\n                uint64_t vec_p_0, uint64_t vec_p_1,\n                uint64_t  vec_Ap,\n                uint64_t vec_r_0, uint64_t vec_r_1,\n                uint64_t  vec_digA,\n                uint64_t  vec_res,\n                const int NUM_ITE,\n                const int NUM_A_LEN,\n                const int M,\n                const int rp_time,\n                const double th_termination\n                ) ;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "ctrl_R": {
            "code": "\n\n #include <ap_int.h>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cassert>\n\n\n #include \"ap_utils.h\"\n\n#include <tapa.h>\n\n\n\n #include <ap_int.h>\n\n#include <tapa.h>\nconstexpr int NUM_CH_SPARSE = 16;\nconstexpr int X_PARTITION_FACTOR = 4; // BRAMs = 512 / 16 / 2 = 16 -> factor = 16 / (64 / 16)\nconstexpr int WINDOW_SIZE = X_PARTITION_FACTOR * 1024;\nconstexpr int DEP_DIST_LOAD_STORE = 7;\nconstexpr int URAM_DEPTH = 3 * 4096;\n// ch16: 3 * 4096 * 16 * 8 = 1,572,864\nusing double_v8 = tapa::vec_t<double, 8>;\nvoid Callipepla(tapa::mmap<int> edge_list_ptr,\n                tapa::mmaps<ap_uint<512>, NUM_CH_SPARSE> edge_list_ch,\n                tapa::mmaps<double_v8, 2> vec_x,\n                tapa::mmaps<double_v8, 2> vec_p,\n                tapa::mmap<double_v8> vec_Ap,\n                tapa::mmaps<double_v8, 2> vec_r,\n                tapa::mmap<double_v8> vec_digA,\n                tapa::mmap<double> vec_res,\n                const int NUM_ITE, const int NUM_A_LEN, const int M,\n                const int rp_time,\n                const double th_termination\n                );\n\nconstexpr int FIFO_DEPTH = 2;\nconstexpr int FIFO_DEPTH_M6 = 50;\nconst int NUM_CH_SPARSE_div_8 = NUM_CH_SPARSE / 8;\nconst int NUM_CH_SPARSE_mult_8 = NUM_CH_SPARSE * 8;\nconst int WINDOW_SIZE_div_8 = WINDOW_SIZE / 8;\nstruct MultXVec {\n    tapa::vec_t<ap_uint<18>, 8> row;\n    double_v8 axv;\n};\nstruct InstRdWr {\n    bool rd;\n    bool wr;\n    //bool require_response;\n    int base_addr;\n    int len;\n};\nstruct InstVCtrl {\n    bool rd;\n    bool wr;\n    int base_addr;\n    int len;\n    ap_uint<3> q_rd_idx;\n    //ap_uint<3> q_wr_idx;\n};\nstruct InstCmp {\n    int len;\n    double alpha;\n    ap_uint<3> q_idx;\n};\nstruct ResTerm {\n    double res;\n    bool term;\n};\ntemplate <typename T, typename R>\ninline void async_read(tapa::async_mmap<T> & A,\n                       tapa::ostream<T> & fifo_A,\n                       const R i_end_addr,\n                       R & i_req,\n                       R & i_resp) {\n#pragma HLS inline\n    if ((i_req < i_end_addr) &\n        !A.read_addr.full()) {\n        A.read_addr.try_write(i_req);\n        ++i_req;\n    }\n    if (!fifo_A.full() & !A.read_data.empty()) {\n        T tmp;\n        A.read_data.try_read(tmp);\n        fifo_A.try_write(tmp);\n        ++i_resp;\n    }\n}\ntemplate <typename T, typename R>\ninline void async_write(tapa::async_mmap<T> & Y_out,\n                        tapa::istream<T> & fifo_Y,\n                        const R num_ite_Y,\n                        R & i_req,\n                        R & i_resp\n                        ) {\n#pragma HLS inline\n    if ((i_req < num_ite_Y) &\n        !fifo_Y.empty() &\n        !Y_out.write_addr.full() &\n        !Y_out.write_data.full() ) {\n        Y_out.write_addr.try_write(i_req);\n        T tmpv;\n        fifo_Y.try_read(tmpv);\n        Y_out.write_data.try_write(tmpv);\n        ++i_req;\n    }\n    uint8_t n_resp;\n    if (Y_out.write_resp.try_read(n_resp)) {\n        i_resp += R(n_resp) + 1;\n    }\n}\nvoid rdwr_vec(uint64_t  vec_p,\n              tapa::istream<InstRdWr> & q_inst,\n              tapa::istream<double_v8> & q_din,\n              tapa::ostream<double_v8> & q_dout,\n              tapa::ostream<bool> & q_response\n              ) ;\ntemplate <typename data_t>\ninline void q2q(tapa::istream<data_t> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty() & !qout.full()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void clearq(tapa::istream<data_t> & qin,\n                   const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void q2q(tapa::istreams<data_t, 2> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite,\n                const int idx) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin[idx].empty() & !qout.full()) {\n            data_t tmp;\n            qin[idx].try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void qq2qq(tapa::istream<data_t> & qin_pe,\n                  tapa::ostreams<data_t, 2> & qout_mem,\n                  tapa::istreams<data_t, 2> & qin_mem,\n                  tapa::ostream<data_t> & qout_qe,\n                  const int num_ite,\n                  const int idx) {\n#pragma HLS inline\nqq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin_pe.empty() & !qout_mem[idx].full()) {\n            data_t tmp;\n            qin_pe.try_read(tmp);\n            qout_mem[idx].try_write(tmp);\n            ++i;\n        }\n        if (!qin_mem[1 - idx].empty() & !qout_qe.full()) {\n            data_t tmp;\n            qin_mem[1 - idx].try_read(tmp);\n            qout_qe.try_write(tmp);\n        }\n    }\n}\nvoid term_signal_router(tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_to_rdA,\n                        tapa::ostream<bool> & q_to_edgepointer,\n                        tapa::ostream<bool> & q_to_abiter,\n                        tapa::ostream<bool> & q_to_ctrlmem,\n                        tapa::ostream<bool> & q_to_mux\n                        ) ;\nvoid read_edge_list_ptr(const int num_ite,\n                        const int M,\n                        const int rp_time, //P_N,\n                        uint64_t  edge_list_ptr,\n                        tapa::ostream<int> & PE_inst,\n                        tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_gbc_out\n                        ) ;\nvoid read_vec(const int rp_time, //P_N\n              const int M, //K,\n              tapa::async_mmap<double_v8> & vec_X,\n              tapa::ostream<double_v8> & fifo_X\n              ) {\n    //const int rp_time = (P_N == 0)? 1 : P_N;\n    const int num_ite_X = (M + 7) >> 3;\nl_rp:\n    for(int rp = 0; rp < rp_time; rp++) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n    rd_X:\n        for(int i_req = 0, i_resp = 0; i_resp < num_ite_X;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n            async_read(vec_X,\n                       fifo_X,\n                       num_ite_X,\n                       i_req, i_resp);\n        }\n    }\n}\nvoid read_A(const int rp_time, //P_N,\n            const int A_len,\n            uint64_t  A,\n            tapa::ostream<ap_uint<512>> & fifo_A,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid PEG_Xvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<ap_uint<512>> & fifo_A,\n              tapa::istream<double_v8> & fifo_X_in,\n              tapa::ostream<int> & fifo_inst_out,\n              tapa::ostream<double_v8> & fifo_X_out,\n              // to PEG_Yvec\n              tapa::ostream<int> & fifo_inst_out_to_Yvec,\n              tapa::ostream<MultXVec> & fifo_aXvec,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out,\n              tapa::ostream<bool> & q_gbc_out_Y\n              ) ;\nvoid PEG_Yvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<MultXVec> & fifo_aXvec,\n              tapa::ostream<double> & fifo_Y_out,\n              tapa::istream<bool> & q_gbc\n              ) ;\nvoid Arbiter_Y(const int rp_time, //P_N,\n               const int M,\n               tapa::istreams<double, NUM_CH_SPARSE_div_8> & fifo_in, // 2 = 16 / 8\n               tapa::ostream<double> & fifo_out,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\nvoid Merger_Y(tapa::istreams<double, 8> & fifo_in,\n              tapa::ostreams<double_v8, 2> & fifo_out) ;\ntemplate <typename data_t>\ninline void bh(tapa::istream<data_t> & q) {\n#pragma HLS inline\n    for (;;) {\n#pragma HLS pipeline II=1\n        data_t tmp; q.try_read(tmp);\n    }\n}\nvoid black_hole_int(tapa::istream<int> & fifo_in) ;\nvoid black_hole_double_v8(tapa::istream<double_v8> & fifo_in) ;\nvoid black_hole_bool(tapa::istream<bool> & fifo_in) ;\nvoid ctrl_P(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time, //P_N\n            const int M, //K,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_spmv,\n            tapa::ostream<double_v8> & q_dotp,\n            //tapa::ostream<double_v8> & q_updtx,\n            tapa::ostream<double_v8> & q_updtp,\n            tapa::istream<double_v8> & q_updated,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_AP(tapa::istream<double_v8> & qm_din,\n             tapa::ostream<double_v8> & qm_dout,\n             const int rp_time,\n             const int M,\n             tapa::ostream<InstRdWr> & q_inst,\n             tapa::ostream<double_v8> & q_updr,\n             tapa::istream<double_v8> & q_pe,\n             tapa::istream<bool> & q_res,\n             tapa::istream<bool> & q_gbc,\n             tapa::ostream<bool> & q_gbc_out\n             ) ;\nvoid ctrl_X(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_oldx,\n            tapa::istream<double_v8> & q_newx,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_R(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & qr_to_pe,\n            tapa::istream<double_v8> & qr_from_pe,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) {\n#pragma HLS disaggregate variable = qm_din\n#pragma HLS array_partition variable = qm_din complete\n#pragma HLS interface ap_fifo port = qm_din[0]._\n#pragma HLS aggregate variable = qm_din[0]._ bit\n#pragma HLS interface ap_fifo port = qm_din[0]._peek\n#pragma HLS aggregate variable = qm_din[0]._peek bit\nvoid(qm_din[0]._.empty());\nvoid(qm_din[0]._peek.empty());\n#pragma HLS interface ap_fifo port = qm_din[1]._\n#pragma HLS aggregate variable = qm_din[1]._ bit\n#pragma HLS interface ap_fifo port = qm_din[1]._peek\n#pragma HLS aggregate variable = qm_din[1]._peek bit\nvoid(qm_din[1]._.empty());\nvoid(qm_din[1]._peek.empty());\n\n#pragma HLS disaggregate variable = qm_dout\n#pragma HLS array_partition variable = qm_dout complete\n#pragma HLS interface ap_fifo port = qm_dout[0]._\n#pragma HLS aggregate variable = qm_dout[0]._ bit\nvoid(qm_dout[0]._.full());\n#pragma HLS interface ap_fifo port = qm_dout[1]._\n#pragma HLS aggregate variable = qm_dout[1]._ bit\nvoid(qm_dout[1]._.full());\n\n\n\n#pragma HLS disaggregate variable = q_inst\n#pragma HLS array_partition variable = q_inst complete\n#pragma HLS interface ap_fifo port = q_inst[0]._\n#pragma HLS aggregate variable = q_inst[0]._ bit\nvoid(q_inst[0]._.full());\n#pragma HLS interface ap_fifo port = q_inst[1]._\n#pragma HLS aggregate variable = q_inst[1]._ bit\nvoid(q_inst[1]._.full());\n\n#pragma HLS disaggregate variable = qr_to_pe\n#pragma HLS interface ap_fifo port = qr_to_pe._\n#pragma HLS aggregate variable = qr_to_pe._ bit\nvoid(qr_to_pe._.full());\n\n#pragma HLS disaggregate variable = qr_from_pe\n#pragma HLS interface ap_fifo port = qr_from_pe._\n#pragma HLS aggregate variable = qr_from_pe._ bit\n#pragma HLS interface ap_fifo port = qr_from_pe._peek\n#pragma HLS aggregate variable = qr_from_pe._peek bit\nvoid(qr_from_pe._.empty());\nvoid(qr_from_pe._peek.empty());\n\n#pragma HLS disaggregate variable = q_res\n#pragma HLS array_partition variable = q_res complete\n#pragma HLS interface ap_fifo port = q_res[0]._\n#pragma HLS aggregate variable = q_res[0]._ bit\n#pragma HLS interface ap_fifo port = q_res[0]._peek\n#pragma HLS aggregate variable = q_res[0]._peek bit\nvoid(q_res[0]._.empty());\nvoid(q_res[0]._peek.empty());\n#pragma HLS interface ap_fifo port = q_res[1]._\n#pragma HLS aggregate variable = q_res[1]._ bit\n#pragma HLS interface ap_fifo port = q_res[1]._peek\n#pragma HLS aggregate variable = q_res[1]._peek bit\nvoid(q_res[1]._.empty());\nvoid(q_res[1]._peek.empty());\n\n#pragma HLS disaggregate variable = q_gbc\n#pragma HLS interface ap_fifo port = q_gbc._\n#pragma HLS aggregate variable = q_gbc._ bit\n#pragma HLS interface ap_fifo port = q_gbc._peek\n#pragma HLS aggregate variable = q_gbc._peek bit\nvoid(q_gbc._.empty());\nvoid(q_gbc._peek.empty());\n\n#pragma HLS disaggregate variable = q_gbc_out\n#pragma HLS interface ap_fifo port = q_gbc_out._\n#pragma HLS aggregate variable = q_gbc_out._ bit\nvoid(q_gbc_out._.full());\n\n    // InstVCtrl vinst1 = {true, false, 0, (M + 7) >> 3, 0};\n    // InstVCtrl vinst2 = {true, true, 0, (M + 7) >> 3, 0};\n    const int num_ite_M = (M + 7) >> 3;\n    bool term_flag = false;\nl_rp:\n    for(int rp = -1, ch = 0; !term_flag & (rp < rp_time); rp++, ch = 1 - ch) {\n#pragma HLS loop_flatten off\n        InstRdWr ist;\n        //0 -- rd: q_din -> qr_to_pe\n        ist.rd = true;\n        ist.wr = false;\n        ist.base_addr = 0;\n        ist.len = num_ite_M;\n        q_inst[ch].write(ist);\n        ap_wait();\n        q2q(qm_din,\n            qr_to_pe,\n            ist.len,\n            ch);\n        ap_wait();\n        q_inst[ch].write(ist);\n        ap_wait();\n        ist.rd = false;\n        ist.wr = true;\n        q_inst[1 - ch].write(ist);\n        ap_wait();\n        qq2qq(qr_from_pe,\n              qm_dout,\n              qm_din,\n              qr_to_pe,\n              ist.len,\n              1 - ch);\n        ap_wait();\n        q_res[1 - ch].read();\n        ap_wait();\n        term_flag = q_gbc.read();\n        q_gbc_out.write(term_flag);\n    }\n    //cout << \"## exit ctrl_R\\n\";\n}\nvoid read_digA(uint64_t  vec_mem,\n               const int rp_time, //P_N\n               const int M, //K,\n               tapa::ostream<double_v8> & q_dout,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n/*  computation modules  */\n//M2: alpha = rzold / (p' * Ap)\nvoid dot_alpha(const int rp_time,\n               const int M,\n               //const unsigned long rz0,\n               tapa::istream<double> & qrz,\n               tapa::istream<double_v8> & q1,\n               tapa::istream<double_v8> & q2,\n               tapa::ostreams<double, 2> & q3,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M end: res = r' * r\nvoid dot_res(const int rp_time,\n             const int M,\n             const double th_termination,\n             tapa::istream<double_v8> & q1,\n             tapa::ostream<ResTerm> & q2,\n             tapa::ostream<bool> & q_termination\n             ) ;\n//M6: rznew = r' * z\nvoid dot_rznew(const int rp_time,\n               const int M,\n               tapa::istream<double_v8> & qr,\n               tapa::istream<double_v8> & qz,\n               tapa::ostream<double_v8> & qr_out,\n               tapa::ostreams<double, 2> & qrz,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M3: x = x + alpha * p\nvoid updt_x(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qx,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M7: p = z + (rznew/rzold) * p\nvoid updt_p(const int rp_time,\n            const int M,\n            //const unsigned long rz0,\n            tapa::istream<double> & qrznew,\n            tapa::istream<double_v8> & qz,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qp2m3,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M4: r = r - alpha * Ap\nvoid updt_r(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qr,\n            tapa::istream<double_v8> & qap,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M5: z = diagA \\ r\nvoid left_div(const int rp_time,\n              const int M,\n              tapa::istream<double_v8> & qr,\n              tapa::istream<double_v8> & qdiagA,\n              tapa::ostreams<double_v8, 2> & qz,\n              tapa::ostream<double_v8> & qr_m6,\n              tapa::ostream<double_v8> & qrmem,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out\n              ) ;\nvoid wr_r(const int rp_time,\n          uint64_t  vec_r,\n          tapa::istream<ResTerm> & q_din\n          ) ;\nvoid duplicator(tapa::istream<double_v8> & q_in,\n                tapa::ostream<double_v8> & q_out1,\n                tapa::ostream<double_v8> & q_out2\n                ) ;\nvoid vecp_mux(const int rp_time,\n              const int M,\n              tapa::istream<bool> & q_gbc,\n              tapa::istream<double_v8> & q_in1,\n              tapa::istream<double_v8> & q_in2,\n              tapa::ostream<double_v8> & q_out\n              ) ;\nvoid Callipepla(uint64_t  edge_list_ptr,\n                uint64_t edge_list_ch_0, uint64_t edge_list_ch_1, uint64_t edge_list_ch_2, uint64_t edge_list_ch_3, uint64_t edge_list_ch_4, uint64_t edge_list_ch_5, uint64_t edge_list_ch_6, uint64_t edge_list_ch_7, uint64_t edge_list_ch_8, uint64_t edge_list_ch_9, uint64_t edge_list_ch_10, uint64_t edge_list_ch_11, uint64_t edge_list_ch_12, uint64_t edge_list_ch_13, uint64_t edge_list_ch_14, uint64_t edge_list_ch_15,\n                uint64_t vec_x_0, uint64_t vec_x_1,\n                uint64_t vec_p_0, uint64_t vec_p_1,\n                uint64_t  vec_Ap,\n                uint64_t vec_r_0, uint64_t vec_r_1,\n                uint64_t  vec_digA,\n                uint64_t  vec_res,\n                const int NUM_ITE,\n                const int NUM_A_LEN,\n                const int M,\n                const int rp_time,\n                const double th_termination\n                ) ;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "ctrl_X": {
            "code": "\n\n #include <ap_int.h>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cassert>\n\n\n #include \"ap_utils.h\"\n\n#include <tapa.h>\n\n\n\n #include <ap_int.h>\n\n#include <tapa.h>\nconstexpr int NUM_CH_SPARSE = 16;\nconstexpr int X_PARTITION_FACTOR = 4; // BRAMs = 512 / 16 / 2 = 16 -> factor = 16 / (64 / 16)\nconstexpr int WINDOW_SIZE = X_PARTITION_FACTOR * 1024;\nconstexpr int DEP_DIST_LOAD_STORE = 7;\nconstexpr int URAM_DEPTH = 3 * 4096;\n// ch16: 3 * 4096 * 16 * 8 = 1,572,864\nusing double_v8 = tapa::vec_t<double, 8>;\nvoid Callipepla(tapa::mmap<int> edge_list_ptr,\n                tapa::mmaps<ap_uint<512>, NUM_CH_SPARSE> edge_list_ch,\n                tapa::mmaps<double_v8, 2> vec_x,\n                tapa::mmaps<double_v8, 2> vec_p,\n                tapa::mmap<double_v8> vec_Ap,\n                tapa::mmaps<double_v8, 2> vec_r,\n                tapa::mmap<double_v8> vec_digA,\n                tapa::mmap<double> vec_res,\n                const int NUM_ITE, const int NUM_A_LEN, const int M,\n                const int rp_time,\n                const double th_termination\n                );\n\nconstexpr int FIFO_DEPTH = 2;\nconstexpr int FIFO_DEPTH_M6 = 50;\nconst int NUM_CH_SPARSE_div_8 = NUM_CH_SPARSE / 8;\nconst int NUM_CH_SPARSE_mult_8 = NUM_CH_SPARSE * 8;\nconst int WINDOW_SIZE_div_8 = WINDOW_SIZE / 8;\nstruct MultXVec {\n    tapa::vec_t<ap_uint<18>, 8> row;\n    double_v8 axv;\n};\nstruct InstRdWr {\n    bool rd;\n    bool wr;\n    //bool require_response;\n    int base_addr;\n    int len;\n};\nstruct InstVCtrl {\n    bool rd;\n    bool wr;\n    int base_addr;\n    int len;\n    ap_uint<3> q_rd_idx;\n    //ap_uint<3> q_wr_idx;\n};\nstruct InstCmp {\n    int len;\n    double alpha;\n    ap_uint<3> q_idx;\n};\nstruct ResTerm {\n    double res;\n    bool term;\n};\ntemplate <typename T, typename R>\ninline void async_read(tapa::async_mmap<T> & A,\n                       tapa::ostream<T> & fifo_A,\n                       const R i_end_addr,\n                       R & i_req,\n                       R & i_resp) {\n#pragma HLS inline\n    if ((i_req < i_end_addr) &\n        !A.read_addr.full()) {\n        A.read_addr.try_write(i_req);\n        ++i_req;\n    }\n    if (!fifo_A.full() & !A.read_data.empty()) {\n        T tmp;\n        A.read_data.try_read(tmp);\n        fifo_A.try_write(tmp);\n        ++i_resp;\n    }\n}\ntemplate <typename T, typename R>\ninline void async_write(tapa::async_mmap<T> & Y_out,\n                        tapa::istream<T> & fifo_Y,\n                        const R num_ite_Y,\n                        R & i_req,\n                        R & i_resp\n                        ) {\n#pragma HLS inline\n    if ((i_req < num_ite_Y) &\n        !fifo_Y.empty() &\n        !Y_out.write_addr.full() &\n        !Y_out.write_data.full() ) {\n        Y_out.write_addr.try_write(i_req);\n        T tmpv;\n        fifo_Y.try_read(tmpv);\n        Y_out.write_data.try_write(tmpv);\n        ++i_req;\n    }\n    uint8_t n_resp;\n    if (Y_out.write_resp.try_read(n_resp)) {\n        i_resp += R(n_resp) + 1;\n    }\n}\nvoid rdwr_vec(uint64_t  vec_p,\n              tapa::istream<InstRdWr> & q_inst,\n              tapa::istream<double_v8> & q_din,\n              tapa::ostream<double_v8> & q_dout,\n              tapa::ostream<bool> & q_response\n              ) ;\ntemplate <typename data_t>\ninline void q2q(tapa::istream<data_t> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty() & !qout.full()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void clearq(tapa::istream<data_t> & qin,\n                   const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void q2q(tapa::istreams<data_t, 2> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite,\n                const int idx) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin[idx].empty() & !qout.full()) {\n            data_t tmp;\n            qin[idx].try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void qq2qq(tapa::istream<data_t> & qin_pe,\n                  tapa::ostreams<data_t, 2> & qout_mem,\n                  tapa::istreams<data_t, 2> & qin_mem,\n                  tapa::ostream<data_t> & qout_qe,\n                  const int num_ite,\n                  const int idx) {\n#pragma HLS inline\nqq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin_pe.empty() & !qout_mem[idx].full()) {\n            data_t tmp;\n            qin_pe.try_read(tmp);\n            qout_mem[idx].try_write(tmp);\n            ++i;\n        }\n        if (!qin_mem[1 - idx].empty() & !qout_qe.full()) {\n            data_t tmp;\n            qin_mem[1 - idx].try_read(tmp);\n            qout_qe.try_write(tmp);\n        }\n    }\n}\nvoid term_signal_router(tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_to_rdA,\n                        tapa::ostream<bool> & q_to_edgepointer,\n                        tapa::ostream<bool> & q_to_abiter,\n                        tapa::ostream<bool> & q_to_ctrlmem,\n                        tapa::ostream<bool> & q_to_mux\n                        ) ;\nvoid read_edge_list_ptr(const int num_ite,\n                        const int M,\n                        const int rp_time, //P_N,\n                        uint64_t  edge_list_ptr,\n                        tapa::ostream<int> & PE_inst,\n                        tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_gbc_out\n                        ) ;\nvoid read_vec(const int rp_time, //P_N\n              const int M, //K,\n              tapa::async_mmap<double_v8> & vec_X,\n              tapa::ostream<double_v8> & fifo_X\n              ) {\n    //const int rp_time = (P_N == 0)? 1 : P_N;\n    const int num_ite_X = (M + 7) >> 3;\nl_rp:\n    for(int rp = 0; rp < rp_time; rp++) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n    rd_X:\n        for(int i_req = 0, i_resp = 0; i_resp < num_ite_X;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n            async_read(vec_X,\n                       fifo_X,\n                       num_ite_X,\n                       i_req, i_resp);\n        }\n    }\n}\nvoid read_A(const int rp_time, //P_N,\n            const int A_len,\n            uint64_t  A,\n            tapa::ostream<ap_uint<512>> & fifo_A,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid PEG_Xvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<ap_uint<512>> & fifo_A,\n              tapa::istream<double_v8> & fifo_X_in,\n              tapa::ostream<int> & fifo_inst_out,\n              tapa::ostream<double_v8> & fifo_X_out,\n              // to PEG_Yvec\n              tapa::ostream<int> & fifo_inst_out_to_Yvec,\n              tapa::ostream<MultXVec> & fifo_aXvec,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out,\n              tapa::ostream<bool> & q_gbc_out_Y\n              ) ;\nvoid PEG_Yvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<MultXVec> & fifo_aXvec,\n              tapa::ostream<double> & fifo_Y_out,\n              tapa::istream<bool> & q_gbc\n              ) ;\nvoid Arbiter_Y(const int rp_time, //P_N,\n               const int M,\n               tapa::istreams<double, NUM_CH_SPARSE_div_8> & fifo_in, // 2 = 16 / 8\n               tapa::ostream<double> & fifo_out,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\nvoid Merger_Y(tapa::istreams<double, 8> & fifo_in,\n              tapa::ostreams<double_v8, 2> & fifo_out) ;\ntemplate <typename data_t>\ninline void bh(tapa::istream<data_t> & q) {\n#pragma HLS inline\n    for (;;) {\n#pragma HLS pipeline II=1\n        data_t tmp; q.try_read(tmp);\n    }\n}\nvoid black_hole_int(tapa::istream<int> & fifo_in) ;\nvoid black_hole_double_v8(tapa::istream<double_v8> & fifo_in) ;\nvoid black_hole_bool(tapa::istream<bool> & fifo_in) ;\nvoid ctrl_P(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time, //P_N\n            const int M, //K,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_spmv,\n            tapa::ostream<double_v8> & q_dotp,\n            //tapa::ostream<double_v8> & q_updtx,\n            tapa::ostream<double_v8> & q_updtp,\n            tapa::istream<double_v8> & q_updated,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_AP(tapa::istream<double_v8> & qm_din,\n             tapa::ostream<double_v8> & qm_dout,\n             const int rp_time,\n             const int M,\n             tapa::ostream<InstRdWr> & q_inst,\n             tapa::ostream<double_v8> & q_updr,\n             tapa::istream<double_v8> & q_pe,\n             tapa::istream<bool> & q_res,\n             tapa::istream<bool> & q_gbc,\n             tapa::ostream<bool> & q_gbc_out\n             ) ;\nvoid ctrl_X(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_oldx,\n            tapa::istream<double_v8> & q_newx,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) {\n#pragma HLS disaggregate variable = qm_din\n#pragma HLS array_partition variable = qm_din complete\n#pragma HLS interface ap_fifo port = qm_din[0]._\n#pragma HLS aggregate variable = qm_din[0]._ bit\n#pragma HLS interface ap_fifo port = qm_din[0]._peek\n#pragma HLS aggregate variable = qm_din[0]._peek bit\nvoid(qm_din[0]._.empty());\nvoid(qm_din[0]._peek.empty());\n#pragma HLS interface ap_fifo port = qm_din[1]._\n#pragma HLS aggregate variable = qm_din[1]._ bit\n#pragma HLS interface ap_fifo port = qm_din[1]._peek\n#pragma HLS aggregate variable = qm_din[1]._peek bit\nvoid(qm_din[1]._.empty());\nvoid(qm_din[1]._peek.empty());\n\n#pragma HLS disaggregate variable = qm_dout\n#pragma HLS array_partition variable = qm_dout complete\n#pragma HLS interface ap_fifo port = qm_dout[0]._\n#pragma HLS aggregate variable = qm_dout[0]._ bit\nvoid(qm_dout[0]._.full());\n#pragma HLS interface ap_fifo port = qm_dout[1]._\n#pragma HLS aggregate variable = qm_dout[1]._ bit\nvoid(qm_dout[1]._.full());\n\n\n\n#pragma HLS disaggregate variable = q_inst\n#pragma HLS array_partition variable = q_inst complete\n#pragma HLS interface ap_fifo port = q_inst[0]._\n#pragma HLS aggregate variable = q_inst[0]._ bit\nvoid(q_inst[0]._.full());\n#pragma HLS interface ap_fifo port = q_inst[1]._\n#pragma HLS aggregate variable = q_inst[1]._ bit\nvoid(q_inst[1]._.full());\n\n#pragma HLS disaggregate variable = q_oldx\n#pragma HLS interface ap_fifo port = q_oldx._\n#pragma HLS aggregate variable = q_oldx._ bit\nvoid(q_oldx._.full());\n\n#pragma HLS disaggregate variable = q_newx\n#pragma HLS interface ap_fifo port = q_newx._\n#pragma HLS aggregate variable = q_newx._ bit\n#pragma HLS interface ap_fifo port = q_newx._peek\n#pragma HLS aggregate variable = q_newx._peek bit\nvoid(q_newx._.empty());\nvoid(q_newx._peek.empty());\n\n#pragma HLS disaggregate variable = q_res\n#pragma HLS array_partition variable = q_res complete\n#pragma HLS interface ap_fifo port = q_res[0]._\n#pragma HLS aggregate variable = q_res[0]._ bit\n#pragma HLS interface ap_fifo port = q_res[0]._peek\n#pragma HLS aggregate variable = q_res[0]._peek bit\nvoid(q_res[0]._.empty());\nvoid(q_res[0]._peek.empty());\n#pragma HLS interface ap_fifo port = q_res[1]._\n#pragma HLS aggregate variable = q_res[1]._ bit\n#pragma HLS interface ap_fifo port = q_res[1]._peek\n#pragma HLS aggregate variable = q_res[1]._peek bit\nvoid(q_res[1]._.empty());\nvoid(q_res[1]._peek.empty());\n\n#pragma HLS disaggregate variable = q_gbc\n#pragma HLS interface ap_fifo port = q_gbc._\n#pragma HLS aggregate variable = q_gbc._ bit\n#pragma HLS interface ap_fifo port = q_gbc._peek\n#pragma HLS aggregate variable = q_gbc._peek bit\nvoid(q_gbc._.empty());\nvoid(q_gbc._peek.empty());\n\n    // InstVCtrl vinst = {true, true, 0, (M + 7) >> 3, 0};\n    const int num_ite_M = (M + 7) >> 3;\n    bool term_flag = false;\nl_rp:\n    for(int rp = -1, ch = 0; !term_flag & (rp < rp_time); rp++, ch = 1 - ch) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n        InstRdWr ist;\n        ist.rd = true;\n        ist.wr = false;\n        ist.base_addr = 0;\n        ist.len = num_ite_M;\n        q_inst[ch].write(ist);\n        ap_wait();\n        ist.rd = false;\n        ist.wr = true;\n        q_inst[1 - ch].write(ist);\n        ap_wait();\n        qq2qq(q_newx,\n              qm_dout,\n              qm_din,\n              q_oldx,\n              ist.len,\n              1 - ch);\n        ap_wait();\n        q_res[1 - ch].read();\n        ap_wait();\n        term_flag = q_gbc.read();\n        //q_gbc_out.write(term_flag);\n    }\n    //cout << \"## exit ctrl_X\\n\";\n}\nvoid ctrl_R(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & qr_to_pe,\n            tapa::istream<double_v8> & qr_from_pe,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid read_digA(uint64_t  vec_mem,\n               const int rp_time, //P_N\n               const int M, //K,\n               tapa::ostream<double_v8> & q_dout,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n/*  computation modules  */\n//M2: alpha = rzold / (p' * Ap)\nvoid dot_alpha(const int rp_time,\n               const int M,\n               //const unsigned long rz0,\n               tapa::istream<double> & qrz,\n               tapa::istream<double_v8> & q1,\n               tapa::istream<double_v8> & q2,\n               tapa::ostreams<double, 2> & q3,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M end: res = r' * r\nvoid dot_res(const int rp_time,\n             const int M,\n             const double th_termination,\n             tapa::istream<double_v8> & q1,\n             tapa::ostream<ResTerm> & q2,\n             tapa::ostream<bool> & q_termination\n             ) ;\n//M6: rznew = r' * z\nvoid dot_rznew(const int rp_time,\n               const int M,\n               tapa::istream<double_v8> & qr,\n               tapa::istream<double_v8> & qz,\n               tapa::ostream<double_v8> & qr_out,\n               tapa::ostreams<double, 2> & qrz,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M3: x = x + alpha * p\nvoid updt_x(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qx,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M7: p = z + (rznew/rzold) * p\nvoid updt_p(const int rp_time,\n            const int M,\n            //const unsigned long rz0,\n            tapa::istream<double> & qrznew,\n            tapa::istream<double_v8> & qz,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qp2m3,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M4: r = r - alpha * Ap\nvoid updt_r(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qr,\n            tapa::istream<double_v8> & qap,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M5: z = diagA \\ r\nvoid left_div(const int rp_time,\n              const int M,\n              tapa::istream<double_v8> & qr,\n              tapa::istream<double_v8> & qdiagA,\n              tapa::ostreams<double_v8, 2> & qz,\n              tapa::ostream<double_v8> & qr_m6,\n              tapa::ostream<double_v8> & qrmem,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out\n              ) ;\nvoid wr_r(const int rp_time,\n          uint64_t  vec_r,\n          tapa::istream<ResTerm> & q_din\n          ) ;\nvoid duplicator(tapa::istream<double_v8> & q_in,\n                tapa::ostream<double_v8> & q_out1,\n                tapa::ostream<double_v8> & q_out2\n                ) ;\nvoid vecp_mux(const int rp_time,\n              const int M,\n              tapa::istream<bool> & q_gbc,\n              tapa::istream<double_v8> & q_in1,\n              tapa::istream<double_v8> & q_in2,\n              tapa::ostream<double_v8> & q_out\n              ) ;\nvoid Callipepla(uint64_t  edge_list_ptr,\n                uint64_t edge_list_ch_0, uint64_t edge_list_ch_1, uint64_t edge_list_ch_2, uint64_t edge_list_ch_3, uint64_t edge_list_ch_4, uint64_t edge_list_ch_5, uint64_t edge_list_ch_6, uint64_t edge_list_ch_7, uint64_t edge_list_ch_8, uint64_t edge_list_ch_9, uint64_t edge_list_ch_10, uint64_t edge_list_ch_11, uint64_t edge_list_ch_12, uint64_t edge_list_ch_13, uint64_t edge_list_ch_14, uint64_t edge_list_ch_15,\n                uint64_t vec_x_0, uint64_t vec_x_1,\n                uint64_t vec_p_0, uint64_t vec_p_1,\n                uint64_t  vec_Ap,\n                uint64_t vec_r_0, uint64_t vec_r_1,\n                uint64_t  vec_digA,\n                uint64_t  vec_res,\n                const int NUM_ITE,\n                const int NUM_A_LEN,\n                const int M,\n                const int rp_time,\n                const double th_termination\n                ) ;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "dot_alpha": {
            "code": "\n\n #include <ap_int.h>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cassert>\n\n\n #include \"ap_utils.h\"\n\n#include <tapa.h>\n\n\n\n #include <ap_int.h>\n\n#include <tapa.h>\nconstexpr int NUM_CH_SPARSE = 16;\nconstexpr int X_PARTITION_FACTOR = 4; // BRAMs = 512 / 16 / 2 = 16 -> factor = 16 / (64 / 16)\nconstexpr int WINDOW_SIZE = X_PARTITION_FACTOR * 1024;\nconstexpr int DEP_DIST_LOAD_STORE = 7;\nconstexpr int URAM_DEPTH = 3 * 4096;\n// ch16: 3 * 4096 * 16 * 8 = 1,572,864\nusing double_v8 = tapa::vec_t<double, 8>;\nvoid Callipepla(tapa::mmap<int> edge_list_ptr,\n                tapa::mmaps<ap_uint<512>, NUM_CH_SPARSE> edge_list_ch,\n                tapa::mmaps<double_v8, 2> vec_x,\n                tapa::mmaps<double_v8, 2> vec_p,\n                tapa::mmap<double_v8> vec_Ap,\n                tapa::mmaps<double_v8, 2> vec_r,\n                tapa::mmap<double_v8> vec_digA,\n                tapa::mmap<double> vec_res,\n                const int NUM_ITE, const int NUM_A_LEN, const int M,\n                const int rp_time,\n                const double th_termination\n                );\n\nconstexpr int FIFO_DEPTH = 2;\nconstexpr int FIFO_DEPTH_M6 = 50;\nconst int NUM_CH_SPARSE_div_8 = NUM_CH_SPARSE / 8;\nconst int NUM_CH_SPARSE_mult_8 = NUM_CH_SPARSE * 8;\nconst int WINDOW_SIZE_div_8 = WINDOW_SIZE / 8;\nstruct MultXVec {\n    tapa::vec_t<ap_uint<18>, 8> row;\n    double_v8 axv;\n};\nstruct InstRdWr {\n    bool rd;\n    bool wr;\n    //bool require_response;\n    int base_addr;\n    int len;\n};\nstruct InstVCtrl {\n    bool rd;\n    bool wr;\n    int base_addr;\n    int len;\n    ap_uint<3> q_rd_idx;\n    //ap_uint<3> q_wr_idx;\n};\nstruct InstCmp {\n    int len;\n    double alpha;\n    ap_uint<3> q_idx;\n};\nstruct ResTerm {\n    double res;\n    bool term;\n};\ntemplate <typename T, typename R>\ninline void async_read(tapa::async_mmap<T> & A,\n                       tapa::ostream<T> & fifo_A,\n                       const R i_end_addr,\n                       R & i_req,\n                       R & i_resp) {\n#pragma HLS inline\n    if ((i_req < i_end_addr) &\n        !A.read_addr.full()) {\n        A.read_addr.try_write(i_req);\n        ++i_req;\n    }\n    if (!fifo_A.full() & !A.read_data.empty()) {\n        T tmp;\n        A.read_data.try_read(tmp);\n        fifo_A.try_write(tmp);\n        ++i_resp;\n    }\n}\ntemplate <typename T, typename R>\ninline void async_write(tapa::async_mmap<T> & Y_out,\n                        tapa::istream<T> & fifo_Y,\n                        const R num_ite_Y,\n                        R & i_req,\n                        R & i_resp\n                        ) {\n#pragma HLS inline\n    if ((i_req < num_ite_Y) &\n        !fifo_Y.empty() &\n        !Y_out.write_addr.full() &\n        !Y_out.write_data.full() ) {\n        Y_out.write_addr.try_write(i_req);\n        T tmpv;\n        fifo_Y.try_read(tmpv);\n        Y_out.write_data.try_write(tmpv);\n        ++i_req;\n    }\n    uint8_t n_resp;\n    if (Y_out.write_resp.try_read(n_resp)) {\n        i_resp += R(n_resp) + 1;\n    }\n}\nvoid rdwr_vec(uint64_t  vec_p,\n              tapa::istream<InstRdWr> & q_inst,\n              tapa::istream<double_v8> & q_din,\n              tapa::ostream<double_v8> & q_dout,\n              tapa::ostream<bool> & q_response\n              ) ;\ntemplate <typename data_t>\ninline void q2q(tapa::istream<data_t> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty() & !qout.full()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void clearq(tapa::istream<data_t> & qin,\n                   const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void q2q(tapa::istreams<data_t, 2> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite,\n                const int idx) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin[idx].empty() & !qout.full()) {\n            data_t tmp;\n            qin[idx].try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void qq2qq(tapa::istream<data_t> & qin_pe,\n                  tapa::ostreams<data_t, 2> & qout_mem,\n                  tapa::istreams<data_t, 2> & qin_mem,\n                  tapa::ostream<data_t> & qout_qe,\n                  const int num_ite,\n                  const int idx) {\n#pragma HLS inline\nqq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin_pe.empty() & !qout_mem[idx].full()) {\n            data_t tmp;\n            qin_pe.try_read(tmp);\n            qout_mem[idx].try_write(tmp);\n            ++i;\n        }\n        if (!qin_mem[1 - idx].empty() & !qout_qe.full()) {\n            data_t tmp;\n            qin_mem[1 - idx].try_read(tmp);\n            qout_qe.try_write(tmp);\n        }\n    }\n}\nvoid term_signal_router(tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_to_rdA,\n                        tapa::ostream<bool> & q_to_edgepointer,\n                        tapa::ostream<bool> & q_to_abiter,\n                        tapa::ostream<bool> & q_to_ctrlmem,\n                        tapa::ostream<bool> & q_to_mux\n                        ) ;\nvoid read_edge_list_ptr(const int num_ite,\n                        const int M,\n                        const int rp_time, //P_N,\n                        uint64_t  edge_list_ptr,\n                        tapa::ostream<int> & PE_inst,\n                        tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_gbc_out\n                        ) ;\nvoid read_vec(const int rp_time, //P_N\n              const int M, //K,\n              tapa::async_mmap<double_v8> & vec_X,\n              tapa::ostream<double_v8> & fifo_X\n              ) {\n    //const int rp_time = (P_N == 0)? 1 : P_N;\n    const int num_ite_X = (M + 7) >> 3;\nl_rp:\n    for(int rp = 0; rp < rp_time; rp++) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n    rd_X:\n        for(int i_req = 0, i_resp = 0; i_resp < num_ite_X;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n            async_read(vec_X,\n                       fifo_X,\n                       num_ite_X,\n                       i_req, i_resp);\n        }\n    }\n}\nvoid read_A(const int rp_time, //P_N,\n            const int A_len,\n            uint64_t  A,\n            tapa::ostream<ap_uint<512>> & fifo_A,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid PEG_Xvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<ap_uint<512>> & fifo_A,\n              tapa::istream<double_v8> & fifo_X_in,\n              tapa::ostream<int> & fifo_inst_out,\n              tapa::ostream<double_v8> & fifo_X_out,\n              // to PEG_Yvec\n              tapa::ostream<int> & fifo_inst_out_to_Yvec,\n              tapa::ostream<MultXVec> & fifo_aXvec,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out,\n              tapa::ostream<bool> & q_gbc_out_Y\n              ) ;\nvoid PEG_Yvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<MultXVec> & fifo_aXvec,\n              tapa::ostream<double> & fifo_Y_out,\n              tapa::istream<bool> & q_gbc\n              ) ;\nvoid Arbiter_Y(const int rp_time, //P_N,\n               const int M,\n               tapa::istreams<double, NUM_CH_SPARSE_div_8> & fifo_in, // 2 = 16 / 8\n               tapa::ostream<double> & fifo_out,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\nvoid Merger_Y(tapa::istreams<double, 8> & fifo_in,\n              tapa::ostreams<double_v8, 2> & fifo_out) ;\ntemplate <typename data_t>\ninline void bh(tapa::istream<data_t> & q) {\n#pragma HLS inline\n    for (;;) {\n#pragma HLS pipeline II=1\n        data_t tmp; q.try_read(tmp);\n    }\n}\nvoid black_hole_int(tapa::istream<int> & fifo_in) ;\nvoid black_hole_double_v8(tapa::istream<double_v8> & fifo_in) ;\nvoid black_hole_bool(tapa::istream<bool> & fifo_in) ;\nvoid ctrl_P(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time, //P_N\n            const int M, //K,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_spmv,\n            tapa::ostream<double_v8> & q_dotp,\n            //tapa::ostream<double_v8> & q_updtx,\n            tapa::ostream<double_v8> & q_updtp,\n            tapa::istream<double_v8> & q_updated,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_AP(tapa::istream<double_v8> & qm_din,\n             tapa::ostream<double_v8> & qm_dout,\n             const int rp_time,\n             const int M,\n             tapa::ostream<InstRdWr> & q_inst,\n             tapa::ostream<double_v8> & q_updr,\n             tapa::istream<double_v8> & q_pe,\n             tapa::istream<bool> & q_res,\n             tapa::istream<bool> & q_gbc,\n             tapa::ostream<bool> & q_gbc_out\n             ) ;\nvoid ctrl_X(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_oldx,\n            tapa::istream<double_v8> & q_newx,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_R(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & qr_to_pe,\n            tapa::istream<double_v8> & qr_from_pe,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid read_digA(uint64_t  vec_mem,\n               const int rp_time, //P_N\n               const int M, //K,\n               tapa::ostream<double_v8> & q_dout,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n/*  computation modules  */\n//M2: alpha = rzold / (p' * Ap)\nvoid dot_alpha(const int rp_time,\n               const int M,\n               //const unsigned long rz0,\n               tapa::istream<double> & qrz,\n               tapa::istream<double_v8> & q1,\n               tapa::istream<double_v8> & q2,\n               tapa::ostreams<double, 2> & q3,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) {\n\n\n#pragma HLS disaggregate variable = qrz\n#pragma HLS interface ap_fifo port = qrz._\n#pragma HLS aggregate variable = qrz._ bit\n#pragma HLS interface ap_fifo port = qrz._peek\n#pragma HLS aggregate variable = qrz._peek bit\nvoid(qrz._.empty());\nvoid(qrz._peek.empty());\n\n#pragma HLS disaggregate variable = q1\n#pragma HLS interface ap_fifo port = q1._\n#pragma HLS aggregate variable = q1._ bit\n#pragma HLS interface ap_fifo port = q1._peek\n#pragma HLS aggregate variable = q1._peek bit\nvoid(q1._.empty());\nvoid(q1._peek.empty());\n\n#pragma HLS disaggregate variable = q2\n#pragma HLS interface ap_fifo port = q2._\n#pragma HLS aggregate variable = q2._ bit\n#pragma HLS interface ap_fifo port = q2._peek\n#pragma HLS aggregate variable = q2._peek bit\nvoid(q2._.empty());\nvoid(q2._peek.empty());\n\n#pragma HLS disaggregate variable = q3\n#pragma HLS array_partition variable = q3 complete\n#pragma HLS interface ap_fifo port = q3[0]._\n#pragma HLS aggregate variable = q3[0]._ bit\nvoid(q3[0]._.full());\n#pragma HLS interface ap_fifo port = q3[1]._\n#pragma HLS aggregate variable = q3[1]._ bit\nvoid(q3[1]._.full());\n\n#pragma HLS disaggregate variable = q_gbc\n#pragma HLS interface ap_fifo port = q_gbc._\n#pragma HLS aggregate variable = q_gbc._ bit\n#pragma HLS interface ap_fifo port = q_gbc._peek\n#pragma HLS aggregate variable = q_gbc._peek bit\nvoid(q_gbc._.empty());\nvoid(q_gbc._peek.empty());\n\n#pragma HLS disaggregate variable = q_gbc_out\n#pragma HLS interface ap_fifo port = q_gbc_out._\n#pragma HLS aggregate variable = q_gbc_out._ bit\nvoid(q_gbc_out._.full());\n\n    //const InstCmp inst = {(M + 7) >> 3, 0.0, 0};\n    const int num_ite = (M + 7) >> 3;\n    double rzold = 0.0;\n    bool term_flag = false;\nrp:\n    for(int rp = -1; !term_flag & (rp < rp_time); rp++) {\n#pragma HLS loop_flatten off\n        double psum[8][DEP_DIST_LOAD_STORE];\n#pragma HLS array_partition complete variable=psum dim=1\n    init:\n        for (int i = 0; i < DEP_DIST_LOAD_STORE; ++i) {\n#pragma HLS pipeline II=1\n            for (int p = 0; p < 8; ++p) {psum[p][i] = 0.0;}\n        }\n    comp1:\n        for (int i = 0, idx = 0; i < num_ite; ) {\n#pragma HLS pipeline II=1\n#pragma HLS dependence true variable=psum distance=DEP_DIST_LOAD_STORE\n            //DEBUG\n            bool tmp1 = q1.empty();\n            bool tmp2 = q2.empty();\n            if (!q1.empty() & !q2.empty()) {\n                double_v8 v1; q1.try_read(v1);\n                double_v8 v2; q2.try_read(v2);\n                for (int p = 0; p < 8; ++p) {\n                    psum[p][idx] += ((i * 8 + p < M)? v1[p] * v2[p] : 0.0);\n                }\n                ++i;\n                ++idx;\n                if (idx == DEP_DIST_LOAD_STORE) {idx = 0;}\n            }\n        }\n    comp2:\n        for (int i = DEP_DIST_LOAD_STORE; i < DEP_DIST_LOAD_STORE * 8; ++i) {\n#pragma HLS pipeline II=1\n#pragma HLS dependence true variable=psum distance=DEP_DIST_LOAD_STORE\n            psum[0][i % DEP_DIST_LOAD_STORE] += psum[i / DEP_DIST_LOAD_STORE][i % DEP_DIST_LOAD_STORE];\n        }\n    comp3:\n        for (int i = 1; i < DEP_DIST_LOAD_STORE; ++i) {\n#pragma HLS pipeline II=1\n            psum[0][0] += psum[0][i];\n        }\n        double pAp = psum[0][0];\n        double alpha = rzold / pAp;\n        double alpha_out[2];\n        alpha_out[0] = alpha;\n        alpha_out[1] = alpha;\n        if (rp < 0) {\n            alpha_out[0] = 0.0;\n            alpha_out[1] = 1.0;\n        }\n        q3[0].write(alpha_out[0]);\n        q3[1].write(alpha_out[1]);\n        ap_wait();\n        rzold = qrz.read();\n        ap_wait();\n        term_flag = q_gbc.read();\n        q_gbc_out.write(term_flag);\n    }\n    //cout << \"@@@ exit dot_alpha\\n\";\n}\n//M end: res = r' * r\nvoid dot_res(const int rp_time,\n             const int M,\n             const double th_termination,\n             tapa::istream<double_v8> & q1,\n             tapa::ostream<ResTerm> & q2,\n             tapa::ostream<bool> & q_termination\n             ) ;\n//M6: rznew = r' * z\nvoid dot_rznew(const int rp_time,\n               const int M,\n               tapa::istream<double_v8> & qr,\n               tapa::istream<double_v8> & qz,\n               tapa::ostream<double_v8> & qr_out,\n               tapa::ostreams<double, 2> & qrz,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M3: x = x + alpha * p\nvoid updt_x(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qx,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M7: p = z + (rznew/rzold) * p\nvoid updt_p(const int rp_time,\n            const int M,\n            //const unsigned long rz0,\n            tapa::istream<double> & qrznew,\n            tapa::istream<double_v8> & qz,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qp2m3,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M4: r = r - alpha * Ap\nvoid updt_r(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qr,\n            tapa::istream<double_v8> & qap,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M5: z = diagA \\ r\nvoid left_div(const int rp_time,\n              const int M,\n              tapa::istream<double_v8> & qr,\n              tapa::istream<double_v8> & qdiagA,\n              tapa::ostreams<double_v8, 2> & qz,\n              tapa::ostream<double_v8> & qr_m6,\n              tapa::ostream<double_v8> & qrmem,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out\n              ) ;\nvoid wr_r(const int rp_time,\n          uint64_t  vec_r,\n          tapa::istream<ResTerm> & q_din\n          ) ;\nvoid duplicator(tapa::istream<double_v8> & q_in,\n                tapa::ostream<double_v8> & q_out1,\n                tapa::ostream<double_v8> & q_out2\n                ) ;\nvoid vecp_mux(const int rp_time,\n              const int M,\n              tapa::istream<bool> & q_gbc,\n              tapa::istream<double_v8> & q_in1,\n              tapa::istream<double_v8> & q_in2,\n              tapa::ostream<double_v8> & q_out\n              ) ;\nvoid Callipepla(uint64_t  edge_list_ptr,\n                uint64_t edge_list_ch_0, uint64_t edge_list_ch_1, uint64_t edge_list_ch_2, uint64_t edge_list_ch_3, uint64_t edge_list_ch_4, uint64_t edge_list_ch_5, uint64_t edge_list_ch_6, uint64_t edge_list_ch_7, uint64_t edge_list_ch_8, uint64_t edge_list_ch_9, uint64_t edge_list_ch_10, uint64_t edge_list_ch_11, uint64_t edge_list_ch_12, uint64_t edge_list_ch_13, uint64_t edge_list_ch_14, uint64_t edge_list_ch_15,\n                uint64_t vec_x_0, uint64_t vec_x_1,\n                uint64_t vec_p_0, uint64_t vec_p_1,\n                uint64_t  vec_Ap,\n                uint64_t vec_r_0, uint64_t vec_r_1,\n                uint64_t  vec_digA,\n                uint64_t  vec_res,\n                const int NUM_ITE,\n                const int NUM_A_LEN,\n                const int M,\n                const int rp_time,\n                const double th_termination\n                ) ;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "dot_res": {
            "code": "\n\n #include <ap_int.h>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cassert>\n\n\n #include \"ap_utils.h\"\n\n#include <tapa.h>\n\n\n\n #include <ap_int.h>\n\n#include <tapa.h>\nconstexpr int NUM_CH_SPARSE = 16;\nconstexpr int X_PARTITION_FACTOR = 4; // BRAMs = 512 / 16 / 2 = 16 -> factor = 16 / (64 / 16)\nconstexpr int WINDOW_SIZE = X_PARTITION_FACTOR * 1024;\nconstexpr int DEP_DIST_LOAD_STORE = 7;\nconstexpr int URAM_DEPTH = 3 * 4096;\n// ch16: 3 * 4096 * 16 * 8 = 1,572,864\nusing double_v8 = tapa::vec_t<double, 8>;\nvoid Callipepla(tapa::mmap<int> edge_list_ptr,\n                tapa::mmaps<ap_uint<512>, NUM_CH_SPARSE> edge_list_ch,\n                tapa::mmaps<double_v8, 2> vec_x,\n                tapa::mmaps<double_v8, 2> vec_p,\n                tapa::mmap<double_v8> vec_Ap,\n                tapa::mmaps<double_v8, 2> vec_r,\n                tapa::mmap<double_v8> vec_digA,\n                tapa::mmap<double> vec_res,\n                const int NUM_ITE, const int NUM_A_LEN, const int M,\n                const int rp_time,\n                const double th_termination\n                );\n\nconstexpr int FIFO_DEPTH = 2;\nconstexpr int FIFO_DEPTH_M6 = 50;\nconst int NUM_CH_SPARSE_div_8 = NUM_CH_SPARSE / 8;\nconst int NUM_CH_SPARSE_mult_8 = NUM_CH_SPARSE * 8;\nconst int WINDOW_SIZE_div_8 = WINDOW_SIZE / 8;\nstruct MultXVec {\n    tapa::vec_t<ap_uint<18>, 8> row;\n    double_v8 axv;\n};\nstruct InstRdWr {\n    bool rd;\n    bool wr;\n    //bool require_response;\n    int base_addr;\n    int len;\n};\nstruct InstVCtrl {\n    bool rd;\n    bool wr;\n    int base_addr;\n    int len;\n    ap_uint<3> q_rd_idx;\n    //ap_uint<3> q_wr_idx;\n};\nstruct InstCmp {\n    int len;\n    double alpha;\n    ap_uint<3> q_idx;\n};\nstruct ResTerm {\n    double res;\n    bool term;\n};\ntemplate <typename T, typename R>\ninline void async_read(tapa::async_mmap<T> & A,\n                       tapa::ostream<T> & fifo_A,\n                       const R i_end_addr,\n                       R & i_req,\n                       R & i_resp) {\n#pragma HLS inline\n    if ((i_req < i_end_addr) &\n        !A.read_addr.full()) {\n        A.read_addr.try_write(i_req);\n        ++i_req;\n    }\n    if (!fifo_A.full() & !A.read_data.empty()) {\n        T tmp;\n        A.read_data.try_read(tmp);\n        fifo_A.try_write(tmp);\n        ++i_resp;\n    }\n}\ntemplate <typename T, typename R>\ninline void async_write(tapa::async_mmap<T> & Y_out,\n                        tapa::istream<T> & fifo_Y,\n                        const R num_ite_Y,\n                        R & i_req,\n                        R & i_resp\n                        ) {\n#pragma HLS inline\n    if ((i_req < num_ite_Y) &\n        !fifo_Y.empty() &\n        !Y_out.write_addr.full() &\n        !Y_out.write_data.full() ) {\n        Y_out.write_addr.try_write(i_req);\n        T tmpv;\n        fifo_Y.try_read(tmpv);\n        Y_out.write_data.try_write(tmpv);\n        ++i_req;\n    }\n    uint8_t n_resp;\n    if (Y_out.write_resp.try_read(n_resp)) {\n        i_resp += R(n_resp) + 1;\n    }\n}\nvoid rdwr_vec(uint64_t  vec_p,\n              tapa::istream<InstRdWr> & q_inst,\n              tapa::istream<double_v8> & q_din,\n              tapa::ostream<double_v8> & q_dout,\n              tapa::ostream<bool> & q_response\n              ) ;\ntemplate <typename data_t>\ninline void q2q(tapa::istream<data_t> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty() & !qout.full()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void clearq(tapa::istream<data_t> & qin,\n                   const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void q2q(tapa::istreams<data_t, 2> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite,\n                const int idx) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin[idx].empty() & !qout.full()) {\n            data_t tmp;\n            qin[idx].try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void qq2qq(tapa::istream<data_t> & qin_pe,\n                  tapa::ostreams<data_t, 2> & qout_mem,\n                  tapa::istreams<data_t, 2> & qin_mem,\n                  tapa::ostream<data_t> & qout_qe,\n                  const int num_ite,\n                  const int idx) {\n#pragma HLS inline\nqq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin_pe.empty() & !qout_mem[idx].full()) {\n            data_t tmp;\n            qin_pe.try_read(tmp);\n            qout_mem[idx].try_write(tmp);\n            ++i;\n        }\n        if (!qin_mem[1 - idx].empty() & !qout_qe.full()) {\n            data_t tmp;\n            qin_mem[1 - idx].try_read(tmp);\n            qout_qe.try_write(tmp);\n        }\n    }\n}\nvoid term_signal_router(tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_to_rdA,\n                        tapa::ostream<bool> & q_to_edgepointer,\n                        tapa::ostream<bool> & q_to_abiter,\n                        tapa::ostream<bool> & q_to_ctrlmem,\n                        tapa::ostream<bool> & q_to_mux\n                        ) ;\nvoid read_edge_list_ptr(const int num_ite,\n                        const int M,\n                        const int rp_time, //P_N,\n                        uint64_t  edge_list_ptr,\n                        tapa::ostream<int> & PE_inst,\n                        tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_gbc_out\n                        ) ;\nvoid read_vec(const int rp_time, //P_N\n              const int M, //K,\n              tapa::async_mmap<double_v8> & vec_X,\n              tapa::ostream<double_v8> & fifo_X\n              ) {\n    //const int rp_time = (P_N == 0)? 1 : P_N;\n    const int num_ite_X = (M + 7) >> 3;\nl_rp:\n    for(int rp = 0; rp < rp_time; rp++) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n    rd_X:\n        for(int i_req = 0, i_resp = 0; i_resp < num_ite_X;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n            async_read(vec_X,\n                       fifo_X,\n                       num_ite_X,\n                       i_req, i_resp);\n        }\n    }\n}\nvoid read_A(const int rp_time, //P_N,\n            const int A_len,\n            uint64_t  A,\n            tapa::ostream<ap_uint<512>> & fifo_A,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid PEG_Xvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<ap_uint<512>> & fifo_A,\n              tapa::istream<double_v8> & fifo_X_in,\n              tapa::ostream<int> & fifo_inst_out,\n              tapa::ostream<double_v8> & fifo_X_out,\n              // to PEG_Yvec\n              tapa::ostream<int> & fifo_inst_out_to_Yvec,\n              tapa::ostream<MultXVec> & fifo_aXvec,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out,\n              tapa::ostream<bool> & q_gbc_out_Y\n              ) ;\nvoid PEG_Yvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<MultXVec> & fifo_aXvec,\n              tapa::ostream<double> & fifo_Y_out,\n              tapa::istream<bool> & q_gbc\n              ) ;\nvoid Arbiter_Y(const int rp_time, //P_N,\n               const int M,\n               tapa::istreams<double, NUM_CH_SPARSE_div_8> & fifo_in, // 2 = 16 / 8\n               tapa::ostream<double> & fifo_out,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\nvoid Merger_Y(tapa::istreams<double, 8> & fifo_in,\n              tapa::ostreams<double_v8, 2> & fifo_out) ;\ntemplate <typename data_t>\ninline void bh(tapa::istream<data_t> & q) {\n#pragma HLS inline\n    for (;;) {\n#pragma HLS pipeline II=1\n        data_t tmp; q.try_read(tmp);\n    }\n}\nvoid black_hole_int(tapa::istream<int> & fifo_in) ;\nvoid black_hole_double_v8(tapa::istream<double_v8> & fifo_in) ;\nvoid black_hole_bool(tapa::istream<bool> & fifo_in) ;\nvoid ctrl_P(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time, //P_N\n            const int M, //K,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_spmv,\n            tapa::ostream<double_v8> & q_dotp,\n            //tapa::ostream<double_v8> & q_updtx,\n            tapa::ostream<double_v8> & q_updtp,\n            tapa::istream<double_v8> & q_updated,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_AP(tapa::istream<double_v8> & qm_din,\n             tapa::ostream<double_v8> & qm_dout,\n             const int rp_time,\n             const int M,\n             tapa::ostream<InstRdWr> & q_inst,\n             tapa::ostream<double_v8> & q_updr,\n             tapa::istream<double_v8> & q_pe,\n             tapa::istream<bool> & q_res,\n             tapa::istream<bool> & q_gbc,\n             tapa::ostream<bool> & q_gbc_out\n             ) ;\nvoid ctrl_X(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_oldx,\n            tapa::istream<double_v8> & q_newx,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_R(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & qr_to_pe,\n            tapa::istream<double_v8> & qr_from_pe,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid read_digA(uint64_t  vec_mem,\n               const int rp_time, //P_N\n               const int M, //K,\n               tapa::ostream<double_v8> & q_dout,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n/*  computation modules  */\n//M2: alpha = rzold / (p' * Ap)\nvoid dot_alpha(const int rp_time,\n               const int M,\n               //const unsigned long rz0,\n               tapa::istream<double> & qrz,\n               tapa::istream<double_v8> & q1,\n               tapa::istream<double_v8> & q2,\n               tapa::ostreams<double, 2> & q3,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M end: res = r' * r\nvoid dot_res(const int rp_time,\n             const int M,\n             const double th_termination,\n             tapa::istream<double_v8> & q1,\n             tapa::ostream<ResTerm> & q2,\n             tapa::ostream<bool> & q_termination\n             ) {\n\n\n\n#pragma HLS disaggregate variable = q1\n#pragma HLS interface ap_fifo port = q1._\n#pragma HLS aggregate variable = q1._ bit\n#pragma HLS interface ap_fifo port = q1._peek\n#pragma HLS aggregate variable = q1._peek bit\nvoid(q1._.empty());\nvoid(q1._peek.empty());\n\n#pragma HLS disaggregate variable = q2\n#pragma HLS interface ap_fifo port = q2._\n#pragma HLS aggregate variable = q2._ bit\nvoid(q2._.full());\n\n#pragma HLS disaggregate variable = q_termination\n#pragma HLS interface ap_fifo port = q_termination._\n#pragma HLS aggregate variable = q_termination._ bit\nvoid(q_termination._.full());\n\n    //InstCmp inst = {(M + 7) >> 3, 0.0, 0};\n    const int num_ite = (M + 7) >> 3;\n    bool term_flag = false;\nrp:\n    for(int rp = -1; !term_flag & (rp < rp_time); rp++) {\n#pragma HLS loop_flatten off\n        double psum[8][DEP_DIST_LOAD_STORE];\n#pragma HLS array_partition complete variable=psum dim=1\n    init:\n        for (int i = 0; i < DEP_DIST_LOAD_STORE; ++i) {\n#pragma HLS pipeline II=1\n            for (int p = 0; p < 8; ++p) {psum[p][i] = 0.0;}\n        }\n    comp1:\n        for (int i = 0, idx = 0; i < num_ite; ) {\n#pragma HLS pipeline II=1\n#pragma HLS dependence true variable=psum distance=DEP_DIST_LOAD_STORE\n            if (!q1.empty()) {\n                double_v8 v1; q1.try_read(v1);\n                for (int p = 0; p < 8; ++p) {\n                    psum[p][idx] += ((i * 8 + p < M)? v1[p] * v1[p] : 0.0);\n                }\n                ++i;\n                ++idx;\n                if (idx == DEP_DIST_LOAD_STORE) {idx = 0;}\n            }\n        }\n    comp2:\n        for (int i = DEP_DIST_LOAD_STORE; i < DEP_DIST_LOAD_STORE * 8; ++i) {\n#pragma HLS pipeline II=1\n#pragma HLS dependence true variable=psum distance=DEP_DIST_LOAD_STORE\n            psum[0][i % DEP_DIST_LOAD_STORE] += psum[i / DEP_DIST_LOAD_STORE][i % DEP_DIST_LOAD_STORE];\n        }\n    comp3:\n        for (int i = 1; i < DEP_DIST_LOAD_STORE; ++i) {\n#pragma HLS pipeline II=1\n            psum[0][0] += psum[0][i];\n        }\n        ResTerm out_p;\n        out_p.res = psum[0][0];\n        //cout << \"ite = \" << rp << \", res = \" << res << endl;\n        term_flag = out_p.res < th_termination;\n        out_p.term = term_flag;\n        q2.write(out_p);\n        ap_wait();\n        q_termination.write(term_flag);\n    }\n    //cout << \"$$$ exit dot_res\\n\";\n}\n//M6: rznew = r' * z\nvoid dot_rznew(const int rp_time,\n               const int M,\n               tapa::istream<double_v8> & qr,\n               tapa::istream<double_v8> & qz,\n               tapa::ostream<double_v8> & qr_out,\n               tapa::ostreams<double, 2> & qrz,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M3: x = x + alpha * p\nvoid updt_x(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qx,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M7: p = z + (rznew/rzold) * p\nvoid updt_p(const int rp_time,\n            const int M,\n            //const unsigned long rz0,\n            tapa::istream<double> & qrznew,\n            tapa::istream<double_v8> & qz,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qp2m3,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M4: r = r - alpha * Ap\nvoid updt_r(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qr,\n            tapa::istream<double_v8> & qap,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M5: z = diagA \\ r\nvoid left_div(const int rp_time,\n              const int M,\n              tapa::istream<double_v8> & qr,\n              tapa::istream<double_v8> & qdiagA,\n              tapa::ostreams<double_v8, 2> & qz,\n              tapa::ostream<double_v8> & qr_m6,\n              tapa::ostream<double_v8> & qrmem,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out\n              ) ;\nvoid wr_r(const int rp_time,\n          uint64_t  vec_r,\n          tapa::istream<ResTerm> & q_din\n          ) ;\nvoid duplicator(tapa::istream<double_v8> & q_in,\n                tapa::ostream<double_v8> & q_out1,\n                tapa::ostream<double_v8> & q_out2\n                ) ;\nvoid vecp_mux(const int rp_time,\n              const int M,\n              tapa::istream<bool> & q_gbc,\n              tapa::istream<double_v8> & q_in1,\n              tapa::istream<double_v8> & q_in2,\n              tapa::ostream<double_v8> & q_out\n              ) ;\nvoid Callipepla(uint64_t  edge_list_ptr,\n                uint64_t edge_list_ch_0, uint64_t edge_list_ch_1, uint64_t edge_list_ch_2, uint64_t edge_list_ch_3, uint64_t edge_list_ch_4, uint64_t edge_list_ch_5, uint64_t edge_list_ch_6, uint64_t edge_list_ch_7, uint64_t edge_list_ch_8, uint64_t edge_list_ch_9, uint64_t edge_list_ch_10, uint64_t edge_list_ch_11, uint64_t edge_list_ch_12, uint64_t edge_list_ch_13, uint64_t edge_list_ch_14, uint64_t edge_list_ch_15,\n                uint64_t vec_x_0, uint64_t vec_x_1,\n                uint64_t vec_p_0, uint64_t vec_p_1,\n                uint64_t  vec_Ap,\n                uint64_t vec_r_0, uint64_t vec_r_1,\n                uint64_t  vec_digA,\n                uint64_t  vec_res,\n                const int NUM_ITE,\n                const int NUM_A_LEN,\n                const int M,\n                const int rp_time,\n                const double th_termination\n                ) ;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "dot_rznew": {
            "code": "\n\n #include <ap_int.h>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cassert>\n\n\n #include \"ap_utils.h\"\n\n#include <tapa.h>\n\n\n\n #include <ap_int.h>\n\n#include <tapa.h>\nconstexpr int NUM_CH_SPARSE = 16;\nconstexpr int X_PARTITION_FACTOR = 4; // BRAMs = 512 / 16 / 2 = 16 -> factor = 16 / (64 / 16)\nconstexpr int WINDOW_SIZE = X_PARTITION_FACTOR * 1024;\nconstexpr int DEP_DIST_LOAD_STORE = 7;\nconstexpr int URAM_DEPTH = 3 * 4096;\n// ch16: 3 * 4096 * 16 * 8 = 1,572,864\nusing double_v8 = tapa::vec_t<double, 8>;\nvoid Callipepla(tapa::mmap<int> edge_list_ptr,\n                tapa::mmaps<ap_uint<512>, NUM_CH_SPARSE> edge_list_ch,\n                tapa::mmaps<double_v8, 2> vec_x,\n                tapa::mmaps<double_v8, 2> vec_p,\n                tapa::mmap<double_v8> vec_Ap,\n                tapa::mmaps<double_v8, 2> vec_r,\n                tapa::mmap<double_v8> vec_digA,\n                tapa::mmap<double> vec_res,\n                const int NUM_ITE, const int NUM_A_LEN, const int M,\n                const int rp_time,\n                const double th_termination\n                );\n\nconstexpr int FIFO_DEPTH = 2;\nconstexpr int FIFO_DEPTH_M6 = 50;\nconst int NUM_CH_SPARSE_div_8 = NUM_CH_SPARSE / 8;\nconst int NUM_CH_SPARSE_mult_8 = NUM_CH_SPARSE * 8;\nconst int WINDOW_SIZE_div_8 = WINDOW_SIZE / 8;\nstruct MultXVec {\n    tapa::vec_t<ap_uint<18>, 8> row;\n    double_v8 axv;\n};\nstruct InstRdWr {\n    bool rd;\n    bool wr;\n    //bool require_response;\n    int base_addr;\n    int len;\n};\nstruct InstVCtrl {\n    bool rd;\n    bool wr;\n    int base_addr;\n    int len;\n    ap_uint<3> q_rd_idx;\n    //ap_uint<3> q_wr_idx;\n};\nstruct InstCmp {\n    int len;\n    double alpha;\n    ap_uint<3> q_idx;\n};\nstruct ResTerm {\n    double res;\n    bool term;\n};\ntemplate <typename T, typename R>\ninline void async_read(tapa::async_mmap<T> & A,\n                       tapa::ostream<T> & fifo_A,\n                       const R i_end_addr,\n                       R & i_req,\n                       R & i_resp) {\n#pragma HLS inline\n    if ((i_req < i_end_addr) &\n        !A.read_addr.full()) {\n        A.read_addr.try_write(i_req);\n        ++i_req;\n    }\n    if (!fifo_A.full() & !A.read_data.empty()) {\n        T tmp;\n        A.read_data.try_read(tmp);\n        fifo_A.try_write(tmp);\n        ++i_resp;\n    }\n}\ntemplate <typename T, typename R>\ninline void async_write(tapa::async_mmap<T> & Y_out,\n                        tapa::istream<T> & fifo_Y,\n                        const R num_ite_Y,\n                        R & i_req,\n                        R & i_resp\n                        ) {\n#pragma HLS inline\n    if ((i_req < num_ite_Y) &\n        !fifo_Y.empty() &\n        !Y_out.write_addr.full() &\n        !Y_out.write_data.full() ) {\n        Y_out.write_addr.try_write(i_req);\n        T tmpv;\n        fifo_Y.try_read(tmpv);\n        Y_out.write_data.try_write(tmpv);\n        ++i_req;\n    }\n    uint8_t n_resp;\n    if (Y_out.write_resp.try_read(n_resp)) {\n        i_resp += R(n_resp) + 1;\n    }\n}\nvoid rdwr_vec(uint64_t  vec_p,\n              tapa::istream<InstRdWr> & q_inst,\n              tapa::istream<double_v8> & q_din,\n              tapa::ostream<double_v8> & q_dout,\n              tapa::ostream<bool> & q_response\n              ) ;\ntemplate <typename data_t>\ninline void q2q(tapa::istream<data_t> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty() & !qout.full()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void clearq(tapa::istream<data_t> & qin,\n                   const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void q2q(tapa::istreams<data_t, 2> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite,\n                const int idx) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin[idx].empty() & !qout.full()) {\n            data_t tmp;\n            qin[idx].try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void qq2qq(tapa::istream<data_t> & qin_pe,\n                  tapa::ostreams<data_t, 2> & qout_mem,\n                  tapa::istreams<data_t, 2> & qin_mem,\n                  tapa::ostream<data_t> & qout_qe,\n                  const int num_ite,\n                  const int idx) {\n#pragma HLS inline\nqq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin_pe.empty() & !qout_mem[idx].full()) {\n            data_t tmp;\n            qin_pe.try_read(tmp);\n            qout_mem[idx].try_write(tmp);\n            ++i;\n        }\n        if (!qin_mem[1 - idx].empty() & !qout_qe.full()) {\n            data_t tmp;\n            qin_mem[1 - idx].try_read(tmp);\n            qout_qe.try_write(tmp);\n        }\n    }\n}\nvoid term_signal_router(tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_to_rdA,\n                        tapa::ostream<bool> & q_to_edgepointer,\n                        tapa::ostream<bool> & q_to_abiter,\n                        tapa::ostream<bool> & q_to_ctrlmem,\n                        tapa::ostream<bool> & q_to_mux\n                        ) ;\nvoid read_edge_list_ptr(const int num_ite,\n                        const int M,\n                        const int rp_time, //P_N,\n                        uint64_t  edge_list_ptr,\n                        tapa::ostream<int> & PE_inst,\n                        tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_gbc_out\n                        ) ;\nvoid read_vec(const int rp_time, //P_N\n              const int M, //K,\n              tapa::async_mmap<double_v8> & vec_X,\n              tapa::ostream<double_v8> & fifo_X\n              ) {\n    //const int rp_time = (P_N == 0)? 1 : P_N;\n    const int num_ite_X = (M + 7) >> 3;\nl_rp:\n    for(int rp = 0; rp < rp_time; rp++) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n    rd_X:\n        for(int i_req = 0, i_resp = 0; i_resp < num_ite_X;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n            async_read(vec_X,\n                       fifo_X,\n                       num_ite_X,\n                       i_req, i_resp);\n        }\n    }\n}\nvoid read_A(const int rp_time, //P_N,\n            const int A_len,\n            uint64_t  A,\n            tapa::ostream<ap_uint<512>> & fifo_A,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid PEG_Xvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<ap_uint<512>> & fifo_A,\n              tapa::istream<double_v8> & fifo_X_in,\n              tapa::ostream<int> & fifo_inst_out,\n              tapa::ostream<double_v8> & fifo_X_out,\n              // to PEG_Yvec\n              tapa::ostream<int> & fifo_inst_out_to_Yvec,\n              tapa::ostream<MultXVec> & fifo_aXvec,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out,\n              tapa::ostream<bool> & q_gbc_out_Y\n              ) ;\nvoid PEG_Yvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<MultXVec> & fifo_aXvec,\n              tapa::ostream<double> & fifo_Y_out,\n              tapa::istream<bool> & q_gbc\n              ) ;\nvoid Arbiter_Y(const int rp_time, //P_N,\n               const int M,\n               tapa::istreams<double, NUM_CH_SPARSE_div_8> & fifo_in, // 2 = 16 / 8\n               tapa::ostream<double> & fifo_out,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\nvoid Merger_Y(tapa::istreams<double, 8> & fifo_in,\n              tapa::ostreams<double_v8, 2> & fifo_out) ;\ntemplate <typename data_t>\ninline void bh(tapa::istream<data_t> & q) {\n#pragma HLS inline\n    for (;;) {\n#pragma HLS pipeline II=1\n        data_t tmp; q.try_read(tmp);\n    }\n}\nvoid black_hole_int(tapa::istream<int> & fifo_in) ;\nvoid black_hole_double_v8(tapa::istream<double_v8> & fifo_in) ;\nvoid black_hole_bool(tapa::istream<bool> & fifo_in) ;\nvoid ctrl_P(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time, //P_N\n            const int M, //K,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_spmv,\n            tapa::ostream<double_v8> & q_dotp,\n            //tapa::ostream<double_v8> & q_updtx,\n            tapa::ostream<double_v8> & q_updtp,\n            tapa::istream<double_v8> & q_updated,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_AP(tapa::istream<double_v8> & qm_din,\n             tapa::ostream<double_v8> & qm_dout,\n             const int rp_time,\n             const int M,\n             tapa::ostream<InstRdWr> & q_inst,\n             tapa::ostream<double_v8> & q_updr,\n             tapa::istream<double_v8> & q_pe,\n             tapa::istream<bool> & q_res,\n             tapa::istream<bool> & q_gbc,\n             tapa::ostream<bool> & q_gbc_out\n             ) ;\nvoid ctrl_X(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_oldx,\n            tapa::istream<double_v8> & q_newx,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_R(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & qr_to_pe,\n            tapa::istream<double_v8> & qr_from_pe,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid read_digA(uint64_t  vec_mem,\n               const int rp_time, //P_N\n               const int M, //K,\n               tapa::ostream<double_v8> & q_dout,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n/*  computation modules  */\n//M2: alpha = rzold / (p' * Ap)\nvoid dot_alpha(const int rp_time,\n               const int M,\n               //const unsigned long rz0,\n               tapa::istream<double> & qrz,\n               tapa::istream<double_v8> & q1,\n               tapa::istream<double_v8> & q2,\n               tapa::ostreams<double, 2> & q3,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M end: res = r' * r\nvoid dot_res(const int rp_time,\n             const int M,\n             const double th_termination,\n             tapa::istream<double_v8> & q1,\n             tapa::ostream<ResTerm> & q2,\n             tapa::ostream<bool> & q_termination\n             ) ;\n//M6: rznew = r' * z\nvoid dot_rznew(const int rp_time,\n               const int M,\n               tapa::istream<double_v8> & qr,\n               tapa::istream<double_v8> & qz,\n               tapa::ostream<double_v8> & qr_out,\n               tapa::ostreams<double, 2> & qrz,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) {\n\n\n#pragma HLS disaggregate variable = qr\n#pragma HLS interface ap_fifo port = qr._\n#pragma HLS aggregate variable = qr._ bit\n#pragma HLS interface ap_fifo port = qr._peek\n#pragma HLS aggregate variable = qr._peek bit\nvoid(qr._.empty());\nvoid(qr._peek.empty());\n\n#pragma HLS disaggregate variable = qz\n#pragma HLS interface ap_fifo port = qz._\n#pragma HLS aggregate variable = qz._ bit\n#pragma HLS interface ap_fifo port = qz._peek\n#pragma HLS aggregate variable = qz._peek bit\nvoid(qz._.empty());\nvoid(qz._peek.empty());\n\n#pragma HLS disaggregate variable = qr_out\n#pragma HLS interface ap_fifo port = qr_out._\n#pragma HLS aggregate variable = qr_out._ bit\nvoid(qr_out._.full());\n\n#pragma HLS disaggregate variable = qrz\n#pragma HLS array_partition variable = qrz complete\n#pragma HLS interface ap_fifo port = qrz[0]._\n#pragma HLS aggregate variable = qrz[0]._ bit\nvoid(qrz[0]._.full());\n#pragma HLS interface ap_fifo port = qrz[1]._\n#pragma HLS aggregate variable = qrz[1]._ bit\nvoid(qrz[1]._.full());\n\n#pragma HLS disaggregate variable = q_gbc\n#pragma HLS interface ap_fifo port = q_gbc._\n#pragma HLS aggregate variable = q_gbc._ bit\n#pragma HLS interface ap_fifo port = q_gbc._peek\n#pragma HLS aggregate variable = q_gbc._peek bit\nvoid(q_gbc._.empty());\nvoid(q_gbc._peek.empty());\n\n#pragma HLS disaggregate variable = q_gbc_out\n#pragma HLS interface ap_fifo port = q_gbc_out._\n#pragma HLS aggregate variable = q_gbc_out._ bit\nvoid(q_gbc_out._.full());\n\n    //InstCmp inst = {(M + 7) >> 3, 0.0, 0};\n    const int num_ite = (M + 7) >> 3;\n    bool term_flag = false;\nrp:\n    for(int rp = -1; !term_flag & (rp < rp_time); rp++) {\n#pragma HLS loop_flatten off\n        double psum[8][DEP_DIST_LOAD_STORE];\n#pragma HLS array_partition complete variable=psum dim=1\n    init:\n        for (int i = 0; i < DEP_DIST_LOAD_STORE; ++i) {\n#pragma HLS pipeline II=1\n            for (int p = 0; p < 8; ++p) {psum[p][i] = 0.0;}\n        }\n    comp1:\n        for (int i = 0, idx = 0; i < num_ite; ) {\n#pragma HLS pipeline II=1\n#pragma HLS dependence true variable=psum distance=DEP_DIST_LOAD_STORE\n            //DEBUG\n            bool tmp1 = qr.empty();\n            bool tmp2 = qz.empty();\n            bool tmp3 = qr_out.full();\n            if (!qr.empty() & !qz.empty() & !qr_out.full()) {\n                double_v8 v1; qr.try_read(v1);\n                double_v8 v2; qz.try_read(v2);\n                qr_out.try_write(v1);\n                for (int p = 0; p < 8; ++p) {\n                    psum[p][idx] += ((i * 8 + p < M)? v1[p] * v2[p] : 0.0);\n                }\n                ++i;\n                ++idx;\n                if (idx == DEP_DIST_LOAD_STORE) {idx = 0;}\n            }\n        }\n    comp2:\n        for (int i = DEP_DIST_LOAD_STORE; i < DEP_DIST_LOAD_STORE * 8; ++i) {\n#pragma HLS pipeline II=1\n#pragma HLS dependence true variable=psum distance=DEP_DIST_LOAD_STORE\n            psum[0][i % DEP_DIST_LOAD_STORE] += psum[i / DEP_DIST_LOAD_STORE][i % DEP_DIST_LOAD_STORE];\n        }\n    comp3:\n        for (int i = 1; i < DEP_DIST_LOAD_STORE; ++i) {\n#pragma HLS pipeline II=1\n            psum[0][0] += psum[0][i];\n        }\n        double rz = psum[0][0];\n        qrz[0].write(rz);\n        qrz[1].write(rz);\n        ap_wait();\n        term_flag = q_gbc.read();\n        q_gbc_out.write(term_flag);\n    }\n    //cout << \"@@@ exit dot_rznew\\n\";\n}\n//M3: x = x + alpha * p\nvoid updt_x(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qx,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M7: p = z + (rznew/rzold) * p\nvoid updt_p(const int rp_time,\n            const int M,\n            //const unsigned long rz0,\n            tapa::istream<double> & qrznew,\n            tapa::istream<double_v8> & qz,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qp2m3,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M4: r = r - alpha * Ap\nvoid updt_r(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qr,\n            tapa::istream<double_v8> & qap,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M5: z = diagA \\ r\nvoid left_div(const int rp_time,\n              const int M,\n              tapa::istream<double_v8> & qr,\n              tapa::istream<double_v8> & qdiagA,\n              tapa::ostreams<double_v8, 2> & qz,\n              tapa::ostream<double_v8> & qr_m6,\n              tapa::ostream<double_v8> & qrmem,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out\n              ) ;\nvoid wr_r(const int rp_time,\n          uint64_t  vec_r,\n          tapa::istream<ResTerm> & q_din\n          ) ;\nvoid duplicator(tapa::istream<double_v8> & q_in,\n                tapa::ostream<double_v8> & q_out1,\n                tapa::ostream<double_v8> & q_out2\n                ) ;\nvoid vecp_mux(const int rp_time,\n              const int M,\n              tapa::istream<bool> & q_gbc,\n              tapa::istream<double_v8> & q_in1,\n              tapa::istream<double_v8> & q_in2,\n              tapa::ostream<double_v8> & q_out\n              ) ;\nvoid Callipepla(uint64_t  edge_list_ptr,\n                uint64_t edge_list_ch_0, uint64_t edge_list_ch_1, uint64_t edge_list_ch_2, uint64_t edge_list_ch_3, uint64_t edge_list_ch_4, uint64_t edge_list_ch_5, uint64_t edge_list_ch_6, uint64_t edge_list_ch_7, uint64_t edge_list_ch_8, uint64_t edge_list_ch_9, uint64_t edge_list_ch_10, uint64_t edge_list_ch_11, uint64_t edge_list_ch_12, uint64_t edge_list_ch_13, uint64_t edge_list_ch_14, uint64_t edge_list_ch_15,\n                uint64_t vec_x_0, uint64_t vec_x_1,\n                uint64_t vec_p_0, uint64_t vec_p_1,\n                uint64_t  vec_Ap,\n                uint64_t vec_r_0, uint64_t vec_r_1,\n                uint64_t  vec_digA,\n                uint64_t  vec_res,\n                const int NUM_ITE,\n                const int NUM_A_LEN,\n                const int M,\n                const int rp_time,\n                const double th_termination\n                ) ;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "duplicator": {
            "code": "\n\n #include <ap_int.h>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cassert>\n\n\n #include \"ap_utils.h\"\n\n#include <tapa.h>\n\n\n\n #include <ap_int.h>\n\n#include <tapa.h>\nconstexpr int NUM_CH_SPARSE = 16;\nconstexpr int X_PARTITION_FACTOR = 4; // BRAMs = 512 / 16 / 2 = 16 -> factor = 16 / (64 / 16)\nconstexpr int WINDOW_SIZE = X_PARTITION_FACTOR * 1024;\nconstexpr int DEP_DIST_LOAD_STORE = 7;\nconstexpr int URAM_DEPTH = 3 * 4096;\n// ch16: 3 * 4096 * 16 * 8 = 1,572,864\nusing double_v8 = tapa::vec_t<double, 8>;\nvoid Callipepla(tapa::mmap<int> edge_list_ptr,\n                tapa::mmaps<ap_uint<512>, NUM_CH_SPARSE> edge_list_ch,\n                tapa::mmaps<double_v8, 2> vec_x,\n                tapa::mmaps<double_v8, 2> vec_p,\n                tapa::mmap<double_v8> vec_Ap,\n                tapa::mmaps<double_v8, 2> vec_r,\n                tapa::mmap<double_v8> vec_digA,\n                tapa::mmap<double> vec_res,\n                const int NUM_ITE, const int NUM_A_LEN, const int M,\n                const int rp_time,\n                const double th_termination\n                );\n\nconstexpr int FIFO_DEPTH = 2;\nconstexpr int FIFO_DEPTH_M6 = 50;\nconst int NUM_CH_SPARSE_div_8 = NUM_CH_SPARSE / 8;\nconst int NUM_CH_SPARSE_mult_8 = NUM_CH_SPARSE * 8;\nconst int WINDOW_SIZE_div_8 = WINDOW_SIZE / 8;\nstruct MultXVec {\n    tapa::vec_t<ap_uint<18>, 8> row;\n    double_v8 axv;\n};\nstruct InstRdWr {\n    bool rd;\n    bool wr;\n    //bool require_response;\n    int base_addr;\n    int len;\n};\nstruct InstVCtrl {\n    bool rd;\n    bool wr;\n    int base_addr;\n    int len;\n    ap_uint<3> q_rd_idx;\n    //ap_uint<3> q_wr_idx;\n};\nstruct InstCmp {\n    int len;\n    double alpha;\n    ap_uint<3> q_idx;\n};\nstruct ResTerm {\n    double res;\n    bool term;\n};\ntemplate <typename T, typename R>\ninline void async_read(tapa::async_mmap<T> & A,\n                       tapa::ostream<T> & fifo_A,\n                       const R i_end_addr,\n                       R & i_req,\n                       R & i_resp) {\n#pragma HLS inline\n    if ((i_req < i_end_addr) &\n        !A.read_addr.full()) {\n        A.read_addr.try_write(i_req);\n        ++i_req;\n    }\n    if (!fifo_A.full() & !A.read_data.empty()) {\n        T tmp;\n        A.read_data.try_read(tmp);\n        fifo_A.try_write(tmp);\n        ++i_resp;\n    }\n}\ntemplate <typename T, typename R>\ninline void async_write(tapa::async_mmap<T> & Y_out,\n                        tapa::istream<T> & fifo_Y,\n                        const R num_ite_Y,\n                        R & i_req,\n                        R & i_resp\n                        ) {\n#pragma HLS inline\n    if ((i_req < num_ite_Y) &\n        !fifo_Y.empty() &\n        !Y_out.write_addr.full() &\n        !Y_out.write_data.full() ) {\n        Y_out.write_addr.try_write(i_req);\n        T tmpv;\n        fifo_Y.try_read(tmpv);\n        Y_out.write_data.try_write(tmpv);\n        ++i_req;\n    }\n    uint8_t n_resp;\n    if (Y_out.write_resp.try_read(n_resp)) {\n        i_resp += R(n_resp) + 1;\n    }\n}\nvoid rdwr_vec(uint64_t  vec_p,\n              tapa::istream<InstRdWr> & q_inst,\n              tapa::istream<double_v8> & q_din,\n              tapa::ostream<double_v8> & q_dout,\n              tapa::ostream<bool> & q_response\n              ) ;\ntemplate <typename data_t>\ninline void q2q(tapa::istream<data_t> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty() & !qout.full()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void clearq(tapa::istream<data_t> & qin,\n                   const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void q2q(tapa::istreams<data_t, 2> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite,\n                const int idx) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin[idx].empty() & !qout.full()) {\n            data_t tmp;\n            qin[idx].try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void qq2qq(tapa::istream<data_t> & qin_pe,\n                  tapa::ostreams<data_t, 2> & qout_mem,\n                  tapa::istreams<data_t, 2> & qin_mem,\n                  tapa::ostream<data_t> & qout_qe,\n                  const int num_ite,\n                  const int idx) {\n#pragma HLS inline\nqq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin_pe.empty() & !qout_mem[idx].full()) {\n            data_t tmp;\n            qin_pe.try_read(tmp);\n            qout_mem[idx].try_write(tmp);\n            ++i;\n        }\n        if (!qin_mem[1 - idx].empty() & !qout_qe.full()) {\n            data_t tmp;\n            qin_mem[1 - idx].try_read(tmp);\n            qout_qe.try_write(tmp);\n        }\n    }\n}\nvoid term_signal_router(tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_to_rdA,\n                        tapa::ostream<bool> & q_to_edgepointer,\n                        tapa::ostream<bool> & q_to_abiter,\n                        tapa::ostream<bool> & q_to_ctrlmem,\n                        tapa::ostream<bool> & q_to_mux\n                        ) ;\nvoid read_edge_list_ptr(const int num_ite,\n                        const int M,\n                        const int rp_time, //P_N,\n                        uint64_t  edge_list_ptr,\n                        tapa::ostream<int> & PE_inst,\n                        tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_gbc_out\n                        ) ;\nvoid read_vec(const int rp_time, //P_N\n              const int M, //K,\n              tapa::async_mmap<double_v8> & vec_X,\n              tapa::ostream<double_v8> & fifo_X\n              ) {\n    //const int rp_time = (P_N == 0)? 1 : P_N;\n    const int num_ite_X = (M + 7) >> 3;\nl_rp:\n    for(int rp = 0; rp < rp_time; rp++) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n    rd_X:\n        for(int i_req = 0, i_resp = 0; i_resp < num_ite_X;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n            async_read(vec_X,\n                       fifo_X,\n                       num_ite_X,\n                       i_req, i_resp);\n        }\n    }\n}\nvoid read_A(const int rp_time, //P_N,\n            const int A_len,\n            uint64_t  A,\n            tapa::ostream<ap_uint<512>> & fifo_A,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid PEG_Xvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<ap_uint<512>> & fifo_A,\n              tapa::istream<double_v8> & fifo_X_in,\n              tapa::ostream<int> & fifo_inst_out,\n              tapa::ostream<double_v8> & fifo_X_out,\n              // to PEG_Yvec\n              tapa::ostream<int> & fifo_inst_out_to_Yvec,\n              tapa::ostream<MultXVec> & fifo_aXvec,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out,\n              tapa::ostream<bool> & q_gbc_out_Y\n              ) ;\nvoid PEG_Yvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<MultXVec> & fifo_aXvec,\n              tapa::ostream<double> & fifo_Y_out,\n              tapa::istream<bool> & q_gbc\n              ) ;\nvoid Arbiter_Y(const int rp_time, //P_N,\n               const int M,\n               tapa::istreams<double, NUM_CH_SPARSE_div_8> & fifo_in, // 2 = 16 / 8\n               tapa::ostream<double> & fifo_out,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\nvoid Merger_Y(tapa::istreams<double, 8> & fifo_in,\n              tapa::ostreams<double_v8, 2> & fifo_out) ;\ntemplate <typename data_t>\ninline void bh(tapa::istream<data_t> & q) {\n#pragma HLS inline\n    for (;;) {\n#pragma HLS pipeline II=1\n        data_t tmp; q.try_read(tmp);\n    }\n}\nvoid black_hole_int(tapa::istream<int> & fifo_in) ;\nvoid black_hole_double_v8(tapa::istream<double_v8> & fifo_in) ;\nvoid black_hole_bool(tapa::istream<bool> & fifo_in) ;\nvoid ctrl_P(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time, //P_N\n            const int M, //K,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_spmv,\n            tapa::ostream<double_v8> & q_dotp,\n            //tapa::ostream<double_v8> & q_updtx,\n            tapa::ostream<double_v8> & q_updtp,\n            tapa::istream<double_v8> & q_updated,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_AP(tapa::istream<double_v8> & qm_din,\n             tapa::ostream<double_v8> & qm_dout,\n             const int rp_time,\n             const int M,\n             tapa::ostream<InstRdWr> & q_inst,\n             tapa::ostream<double_v8> & q_updr,\n             tapa::istream<double_v8> & q_pe,\n             tapa::istream<bool> & q_res,\n             tapa::istream<bool> & q_gbc,\n             tapa::ostream<bool> & q_gbc_out\n             ) ;\nvoid ctrl_X(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_oldx,\n            tapa::istream<double_v8> & q_newx,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_R(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & qr_to_pe,\n            tapa::istream<double_v8> & qr_from_pe,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid read_digA(uint64_t  vec_mem,\n               const int rp_time, //P_N\n               const int M, //K,\n               tapa::ostream<double_v8> & q_dout,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n/*  computation modules  */\n//M2: alpha = rzold / (p' * Ap)\nvoid dot_alpha(const int rp_time,\n               const int M,\n               //const unsigned long rz0,\n               tapa::istream<double> & qrz,\n               tapa::istream<double_v8> & q1,\n               tapa::istream<double_v8> & q2,\n               tapa::ostreams<double, 2> & q3,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M end: res = r' * r\nvoid dot_res(const int rp_time,\n             const int M,\n             const double th_termination,\n             tapa::istream<double_v8> & q1,\n             tapa::ostream<ResTerm> & q2,\n             tapa::ostream<bool> & q_termination\n             ) ;\n//M6: rznew = r' * z\nvoid dot_rznew(const int rp_time,\n               const int M,\n               tapa::istream<double_v8> & qr,\n               tapa::istream<double_v8> & qz,\n               tapa::ostream<double_v8> & qr_out,\n               tapa::ostreams<double, 2> & qrz,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M3: x = x + alpha * p\nvoid updt_x(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qx,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M7: p = z + (rznew/rzold) * p\nvoid updt_p(const int rp_time,\n            const int M,\n            //const unsigned long rz0,\n            tapa::istream<double> & qrznew,\n            tapa::istream<double_v8> & qz,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qp2m3,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M4: r = r - alpha * Ap\nvoid updt_r(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qr,\n            tapa::istream<double_v8> & qap,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M5: z = diagA \\ r\nvoid left_div(const int rp_time,\n              const int M,\n              tapa::istream<double_v8> & qr,\n              tapa::istream<double_v8> & qdiagA,\n              tapa::ostreams<double_v8, 2> & qz,\n              tapa::ostream<double_v8> & qr_m6,\n              tapa::ostream<double_v8> & qrmem,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out\n              ) ;\nvoid wr_r(const int rp_time,\n          uint64_t  vec_r,\n          tapa::istream<ResTerm> & q_din\n          ) ;\nvoid duplicator(tapa::istream<double_v8> & q_in,\n                tapa::ostream<double_v8> & q_out1,\n                tapa::ostream<double_v8> & q_out2\n                ) {\n#pragma HLS disaggregate variable = q_in\n#pragma HLS interface ap_fifo port = q_in._\n#pragma HLS aggregate variable = q_in._ bit\n#pragma HLS interface ap_fifo port = q_in._peek\n#pragma HLS aggregate variable = q_in._peek bit\nvoid(q_in._.empty());\nvoid(q_in._peek.empty());\n\n#pragma HLS disaggregate variable = q_out1\n#pragma HLS interface ap_fifo port = q_out1._\n#pragma HLS aggregate variable = q_out1._ bit\nvoid(q_out1._.full());\n\n#pragma HLS disaggregate variable = q_out2\n#pragma HLS interface ap_fifo port = q_out2._\n#pragma HLS aggregate variable = q_out2._ bit\nvoid(q_out2._.full());\n\ncc:\n    for (;;) {\n#pragma HLS pipeline II=1\n        if (!q_in.empty() &\n            !q_out1.full() &\n            !q_out2.full()\n            ) {\n            double_v8 tmp;\n            q_in.try_read(tmp);\n            q_out1.try_write(tmp);\n            q_out2.try_write(tmp);\n        }\n    }\n}\nvoid vecp_mux(const int rp_time,\n              const int M,\n              tapa::istream<bool> & q_gbc,\n              tapa::istream<double_v8> & q_in1,\n              tapa::istream<double_v8> & q_in2,\n              tapa::ostream<double_v8> & q_out\n              ) ;\nvoid Callipepla(uint64_t  edge_list_ptr,\n                uint64_t edge_list_ch_0, uint64_t edge_list_ch_1, uint64_t edge_list_ch_2, uint64_t edge_list_ch_3, uint64_t edge_list_ch_4, uint64_t edge_list_ch_5, uint64_t edge_list_ch_6, uint64_t edge_list_ch_7, uint64_t edge_list_ch_8, uint64_t edge_list_ch_9, uint64_t edge_list_ch_10, uint64_t edge_list_ch_11, uint64_t edge_list_ch_12, uint64_t edge_list_ch_13, uint64_t edge_list_ch_14, uint64_t edge_list_ch_15,\n                uint64_t vec_x_0, uint64_t vec_x_1,\n                uint64_t vec_p_0, uint64_t vec_p_1,\n                uint64_t  vec_Ap,\n                uint64_t vec_r_0, uint64_t vec_r_1,\n                uint64_t  vec_digA,\n                uint64_t  vec_res,\n                const int NUM_ITE,\n                const int NUM_A_LEN,\n                const int M,\n                const int rp_time,\n                const double th_termination\n                ) ;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "left_div": {
            "code": "\n\n #include <ap_int.h>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cassert>\n\n\n #include \"ap_utils.h\"\n\n#include <tapa.h>\n\n\n\n #include <ap_int.h>\n\n#include <tapa.h>\nconstexpr int NUM_CH_SPARSE = 16;\nconstexpr int X_PARTITION_FACTOR = 4; // BRAMs = 512 / 16 / 2 = 16 -> factor = 16 / (64 / 16)\nconstexpr int WINDOW_SIZE = X_PARTITION_FACTOR * 1024;\nconstexpr int DEP_DIST_LOAD_STORE = 7;\nconstexpr int URAM_DEPTH = 3 * 4096;\n// ch16: 3 * 4096 * 16 * 8 = 1,572,864\nusing double_v8 = tapa::vec_t<double, 8>;\nvoid Callipepla(tapa::mmap<int> edge_list_ptr,\n                tapa::mmaps<ap_uint<512>, NUM_CH_SPARSE> edge_list_ch,\n                tapa::mmaps<double_v8, 2> vec_x,\n                tapa::mmaps<double_v8, 2> vec_p,\n                tapa::mmap<double_v8> vec_Ap,\n                tapa::mmaps<double_v8, 2> vec_r,\n                tapa::mmap<double_v8> vec_digA,\n                tapa::mmap<double> vec_res,\n                const int NUM_ITE, const int NUM_A_LEN, const int M,\n                const int rp_time,\n                const double th_termination\n                );\n\nconstexpr int FIFO_DEPTH = 2;\nconstexpr int FIFO_DEPTH_M6 = 50;\nconst int NUM_CH_SPARSE_div_8 = NUM_CH_SPARSE / 8;\nconst int NUM_CH_SPARSE_mult_8 = NUM_CH_SPARSE * 8;\nconst int WINDOW_SIZE_div_8 = WINDOW_SIZE / 8;\nstruct MultXVec {\n    tapa::vec_t<ap_uint<18>, 8> row;\n    double_v8 axv;\n};\nstruct InstRdWr {\n    bool rd;\n    bool wr;\n    //bool require_response;\n    int base_addr;\n    int len;\n};\nstruct InstVCtrl {\n    bool rd;\n    bool wr;\n    int base_addr;\n    int len;\n    ap_uint<3> q_rd_idx;\n    //ap_uint<3> q_wr_idx;\n};\nstruct InstCmp {\n    int len;\n    double alpha;\n    ap_uint<3> q_idx;\n};\nstruct ResTerm {\n    double res;\n    bool term;\n};\ntemplate <typename T, typename R>\ninline void async_read(tapa::async_mmap<T> & A,\n                       tapa::ostream<T> & fifo_A,\n                       const R i_end_addr,\n                       R & i_req,\n                       R & i_resp) {\n#pragma HLS inline\n    if ((i_req < i_end_addr) &\n        !A.read_addr.full()) {\n        A.read_addr.try_write(i_req);\n        ++i_req;\n    }\n    if (!fifo_A.full() & !A.read_data.empty()) {\n        T tmp;\n        A.read_data.try_read(tmp);\n        fifo_A.try_write(tmp);\n        ++i_resp;\n    }\n}\ntemplate <typename T, typename R>\ninline void async_write(tapa::async_mmap<T> & Y_out,\n                        tapa::istream<T> & fifo_Y,\n                        const R num_ite_Y,\n                        R & i_req,\n                        R & i_resp\n                        ) {\n#pragma HLS inline\n    if ((i_req < num_ite_Y) &\n        !fifo_Y.empty() &\n        !Y_out.write_addr.full() &\n        !Y_out.write_data.full() ) {\n        Y_out.write_addr.try_write(i_req);\n        T tmpv;\n        fifo_Y.try_read(tmpv);\n        Y_out.write_data.try_write(tmpv);\n        ++i_req;\n    }\n    uint8_t n_resp;\n    if (Y_out.write_resp.try_read(n_resp)) {\n        i_resp += R(n_resp) + 1;\n    }\n}\nvoid rdwr_vec(uint64_t  vec_p,\n              tapa::istream<InstRdWr> & q_inst,\n              tapa::istream<double_v8> & q_din,\n              tapa::ostream<double_v8> & q_dout,\n              tapa::ostream<bool> & q_response\n              ) ;\ntemplate <typename data_t>\ninline void q2q(tapa::istream<data_t> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty() & !qout.full()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void clearq(tapa::istream<data_t> & qin,\n                   const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void q2q(tapa::istreams<data_t, 2> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite,\n                const int idx) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin[idx].empty() & !qout.full()) {\n            data_t tmp;\n            qin[idx].try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void qq2qq(tapa::istream<data_t> & qin_pe,\n                  tapa::ostreams<data_t, 2> & qout_mem,\n                  tapa::istreams<data_t, 2> & qin_mem,\n                  tapa::ostream<data_t> & qout_qe,\n                  const int num_ite,\n                  const int idx) {\n#pragma HLS inline\nqq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin_pe.empty() & !qout_mem[idx].full()) {\n            data_t tmp;\n            qin_pe.try_read(tmp);\n            qout_mem[idx].try_write(tmp);\n            ++i;\n        }\n        if (!qin_mem[1 - idx].empty() & !qout_qe.full()) {\n            data_t tmp;\n            qin_mem[1 - idx].try_read(tmp);\n            qout_qe.try_write(tmp);\n        }\n    }\n}\nvoid term_signal_router(tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_to_rdA,\n                        tapa::ostream<bool> & q_to_edgepointer,\n                        tapa::ostream<bool> & q_to_abiter,\n                        tapa::ostream<bool> & q_to_ctrlmem,\n                        tapa::ostream<bool> & q_to_mux\n                        ) ;\nvoid read_edge_list_ptr(const int num_ite,\n                        const int M,\n                        const int rp_time, //P_N,\n                        uint64_t  edge_list_ptr,\n                        tapa::ostream<int> & PE_inst,\n                        tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_gbc_out\n                        ) ;\nvoid read_vec(const int rp_time, //P_N\n              const int M, //K,\n              tapa::async_mmap<double_v8> & vec_X,\n              tapa::ostream<double_v8> & fifo_X\n              ) {\n    //const int rp_time = (P_N == 0)? 1 : P_N;\n    const int num_ite_X = (M + 7) >> 3;\nl_rp:\n    for(int rp = 0; rp < rp_time; rp++) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n    rd_X:\n        for(int i_req = 0, i_resp = 0; i_resp < num_ite_X;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n            async_read(vec_X,\n                       fifo_X,\n                       num_ite_X,\n                       i_req, i_resp);\n        }\n    }\n}\nvoid read_A(const int rp_time, //P_N,\n            const int A_len,\n            uint64_t  A,\n            tapa::ostream<ap_uint<512>> & fifo_A,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid PEG_Xvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<ap_uint<512>> & fifo_A,\n              tapa::istream<double_v8> & fifo_X_in,\n              tapa::ostream<int> & fifo_inst_out,\n              tapa::ostream<double_v8> & fifo_X_out,\n              // to PEG_Yvec\n              tapa::ostream<int> & fifo_inst_out_to_Yvec,\n              tapa::ostream<MultXVec> & fifo_aXvec,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out,\n              tapa::ostream<bool> & q_gbc_out_Y\n              ) ;\nvoid PEG_Yvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<MultXVec> & fifo_aXvec,\n              tapa::ostream<double> & fifo_Y_out,\n              tapa::istream<bool> & q_gbc\n              ) ;\nvoid Arbiter_Y(const int rp_time, //P_N,\n               const int M,\n               tapa::istreams<double, NUM_CH_SPARSE_div_8> & fifo_in, // 2 = 16 / 8\n               tapa::ostream<double> & fifo_out,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\nvoid Merger_Y(tapa::istreams<double, 8> & fifo_in,\n              tapa::ostreams<double_v8, 2> & fifo_out) ;\ntemplate <typename data_t>\ninline void bh(tapa::istream<data_t> & q) {\n#pragma HLS inline\n    for (;;) {\n#pragma HLS pipeline II=1\n        data_t tmp; q.try_read(tmp);\n    }\n}\nvoid black_hole_int(tapa::istream<int> & fifo_in) ;\nvoid black_hole_double_v8(tapa::istream<double_v8> & fifo_in) ;\nvoid black_hole_bool(tapa::istream<bool> & fifo_in) ;\nvoid ctrl_P(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time, //P_N\n            const int M, //K,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_spmv,\n            tapa::ostream<double_v8> & q_dotp,\n            //tapa::ostream<double_v8> & q_updtx,\n            tapa::ostream<double_v8> & q_updtp,\n            tapa::istream<double_v8> & q_updated,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_AP(tapa::istream<double_v8> & qm_din,\n             tapa::ostream<double_v8> & qm_dout,\n             const int rp_time,\n             const int M,\n             tapa::ostream<InstRdWr> & q_inst,\n             tapa::ostream<double_v8> & q_updr,\n             tapa::istream<double_v8> & q_pe,\n             tapa::istream<bool> & q_res,\n             tapa::istream<bool> & q_gbc,\n             tapa::ostream<bool> & q_gbc_out\n             ) ;\nvoid ctrl_X(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_oldx,\n            tapa::istream<double_v8> & q_newx,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_R(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & qr_to_pe,\n            tapa::istream<double_v8> & qr_from_pe,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid read_digA(uint64_t  vec_mem,\n               const int rp_time, //P_N\n               const int M, //K,\n               tapa::ostream<double_v8> & q_dout,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n/*  computation modules  */\n//M2: alpha = rzold / (p' * Ap)\nvoid dot_alpha(const int rp_time,\n               const int M,\n               //const unsigned long rz0,\n               tapa::istream<double> & qrz,\n               tapa::istream<double_v8> & q1,\n               tapa::istream<double_v8> & q2,\n               tapa::ostreams<double, 2> & q3,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M end: res = r' * r\nvoid dot_res(const int rp_time,\n             const int M,\n             const double th_termination,\n             tapa::istream<double_v8> & q1,\n             tapa::ostream<ResTerm> & q2,\n             tapa::ostream<bool> & q_termination\n             ) ;\n//M6: rznew = r' * z\nvoid dot_rznew(const int rp_time,\n               const int M,\n               tapa::istream<double_v8> & qr,\n               tapa::istream<double_v8> & qz,\n               tapa::ostream<double_v8> & qr_out,\n               tapa::ostreams<double, 2> & qrz,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M3: x = x + alpha * p\nvoid updt_x(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qx,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M7: p = z + (rznew/rzold) * p\nvoid updt_p(const int rp_time,\n            const int M,\n            //const unsigned long rz0,\n            tapa::istream<double> & qrznew,\n            tapa::istream<double_v8> & qz,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qp2m3,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M4: r = r - alpha * Ap\nvoid updt_r(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qr,\n            tapa::istream<double_v8> & qap,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M5: z = diagA \\ r\nvoid left_div(const int rp_time,\n              const int M,\n              tapa::istream<double_v8> & qr,\n              tapa::istream<double_v8> & qdiagA,\n              tapa::ostreams<double_v8, 2> & qz,\n              tapa::ostream<double_v8> & qr_m6,\n              tapa::ostream<double_v8> & qrmem,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out\n              ) {\n\n\n#pragma HLS disaggregate variable = qr\n#pragma HLS interface ap_fifo port = qr._\n#pragma HLS aggregate variable = qr._ bit\n#pragma HLS interface ap_fifo port = qr._peek\n#pragma HLS aggregate variable = qr._peek bit\nvoid(qr._.empty());\nvoid(qr._peek.empty());\n\n#pragma HLS disaggregate variable = qdiagA\n#pragma HLS interface ap_fifo port = qdiagA._\n#pragma HLS aggregate variable = qdiagA._ bit\n#pragma HLS interface ap_fifo port = qdiagA._peek\n#pragma HLS aggregate variable = qdiagA._peek bit\nvoid(qdiagA._.empty());\nvoid(qdiagA._peek.empty());\n\n#pragma HLS disaggregate variable = qz\n#pragma HLS array_partition variable = qz complete\n#pragma HLS interface ap_fifo port = qz[0]._\n#pragma HLS aggregate variable = qz[0]._ bit\nvoid(qz[0]._.full());\n#pragma HLS interface ap_fifo port = qz[1]._\n#pragma HLS aggregate variable = qz[1]._ bit\nvoid(qz[1]._.full());\n\n#pragma HLS disaggregate variable = qr_m6\n#pragma HLS interface ap_fifo port = qr_m6._\n#pragma HLS aggregate variable = qr_m6._ bit\nvoid(qr_m6._.full());\n\n#pragma HLS disaggregate variable = qrmem\n#pragma HLS interface ap_fifo port = qrmem._\n#pragma HLS aggregate variable = qrmem._ bit\nvoid(qrmem._.full());\n\n#pragma HLS disaggregate variable = q_gbc\n#pragma HLS interface ap_fifo port = q_gbc._\n#pragma HLS aggregate variable = q_gbc._ bit\n#pragma HLS interface ap_fifo port = q_gbc._peek\n#pragma HLS aggregate variable = q_gbc._peek bit\nvoid(q_gbc._.empty());\nvoid(q_gbc._peek.empty());\n\n#pragma HLS disaggregate variable = q_gbc_out\n#pragma HLS interface ap_fifo port = q_gbc_out._\n#pragma HLS aggregate variable = q_gbc_out._ bit\nvoid(q_gbc_out._.full());\n\n    //InstCmp inst1 = {(M + 7) >> 3, 0.0, 0};\n    //InstCmp inst2 = {(M + 7) >> 3, 0.0, 1};\n    InstCmp inst = {(M + 7) >> 3, 0.0, 0};\n    bool term_flag = false;\nrp:\n    for(int rp = -2; !term_flag & (rp < rp_time * 2); rp++) {\n#pragma HLS loop_flatten off\n        inst.q_idx = rp&0x1;\n    cc:\n        for (int i = 0; i < inst.len; ) {\n#pragma HLS pipeline II=1\n            //DEBUG\n            bool tmp1 = qr.empty();\n            bool tmp2 = qdiagA.empty();\n            bool nop_flag = qr.empty() | qdiagA.empty();\n            if (inst.q_idx == 0) {\n                nop_flag |= qr_m6.full();\n            } else {\n                nop_flag |= qrmem.full();\n            }\n            if (!nop_flag) {\n                double_v8 v1; qr.try_read(v1);\n                if (inst.q_idx == 0) {\n                    qr_m6.try_write(v1);\n                } else {\n                    qrmem.try_write(v1);\n                }\n                double_v8 v2; qdiagA.try_read(v2);\n                double_v8 result;\n                for (int p = 0; p < 8; ++p) {\n                    result[p] = ((i * 8 + p < M)? v1[p] / v2[p] : 0.0);\n                }\n                ++i;\n                qz[inst.q_idx].write(result);\n            }\n        }\n        ap_wait();\n        if (inst.q_idx == 1) {\n            term_flag = q_gbc.read();\n            q_gbc_out.write(term_flag);\n        }\n    }\n    //cout << \"@@@ exit left_div\\n\";\n}\nvoid wr_r(const int rp_time,\n          uint64_t  vec_r,\n          tapa::istream<ResTerm> & q_din\n          ) ;\nvoid duplicator(tapa::istream<double_v8> & q_in,\n                tapa::ostream<double_v8> & q_out1,\n                tapa::ostream<double_v8> & q_out2\n                ) ;\nvoid vecp_mux(const int rp_time,\n              const int M,\n              tapa::istream<bool> & q_gbc,\n              tapa::istream<double_v8> & q_in1,\n              tapa::istream<double_v8> & q_in2,\n              tapa::ostream<double_v8> & q_out\n              ) ;\nvoid Callipepla(uint64_t  edge_list_ptr,\n                uint64_t edge_list_ch_0, uint64_t edge_list_ch_1, uint64_t edge_list_ch_2, uint64_t edge_list_ch_3, uint64_t edge_list_ch_4, uint64_t edge_list_ch_5, uint64_t edge_list_ch_6, uint64_t edge_list_ch_7, uint64_t edge_list_ch_8, uint64_t edge_list_ch_9, uint64_t edge_list_ch_10, uint64_t edge_list_ch_11, uint64_t edge_list_ch_12, uint64_t edge_list_ch_13, uint64_t edge_list_ch_14, uint64_t edge_list_ch_15,\n                uint64_t vec_x_0, uint64_t vec_x_1,\n                uint64_t vec_p_0, uint64_t vec_p_1,\n                uint64_t  vec_Ap,\n                uint64_t vec_r_0, uint64_t vec_r_1,\n                uint64_t  vec_digA,\n                uint64_t  vec_res,\n                const int NUM_ITE,\n                const int NUM_A_LEN,\n                const int M,\n                const int rp_time,\n                const double th_termination\n                ) ;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "rdwr_vec": {
            "code": "\n\n #include <ap_int.h>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cassert>\n\n\n #include \"ap_utils.h\"\n\n#include <tapa.h>\n\n\n\n #include <ap_int.h>\n\n#include <tapa.h>\nconstexpr int NUM_CH_SPARSE = 16;\nconstexpr int X_PARTITION_FACTOR = 4; // BRAMs = 512 / 16 / 2 = 16 -> factor = 16 / (64 / 16)\nconstexpr int WINDOW_SIZE = X_PARTITION_FACTOR * 1024;\nconstexpr int DEP_DIST_LOAD_STORE = 7;\nconstexpr int URAM_DEPTH = 3 * 4096;\n// ch16: 3 * 4096 * 16 * 8 = 1,572,864\nusing double_v8 = tapa::vec_t<double, 8>;\nvoid Callipepla(tapa::mmap<int> edge_list_ptr,\n                tapa::mmaps<ap_uint<512>, NUM_CH_SPARSE> edge_list_ch,\n                tapa::mmaps<double_v8, 2> vec_x,\n                tapa::mmaps<double_v8, 2> vec_p,\n                tapa::mmap<double_v8> vec_Ap,\n                tapa::mmaps<double_v8, 2> vec_r,\n                tapa::mmap<double_v8> vec_digA,\n                tapa::mmap<double> vec_res,\n                const int NUM_ITE, const int NUM_A_LEN, const int M,\n                const int rp_time,\n                const double th_termination\n                );\n\nconstexpr int FIFO_DEPTH = 2;\nconstexpr int FIFO_DEPTH_M6 = 50;\nconst int NUM_CH_SPARSE_div_8 = NUM_CH_SPARSE / 8;\nconst int NUM_CH_SPARSE_mult_8 = NUM_CH_SPARSE * 8;\nconst int WINDOW_SIZE_div_8 = WINDOW_SIZE / 8;\nstruct MultXVec {\n    tapa::vec_t<ap_uint<18>, 8> row;\n    double_v8 axv;\n};\nstruct InstRdWr {\n    bool rd;\n    bool wr;\n    //bool require_response;\n    int base_addr;\n    int len;\n};\nstruct InstVCtrl {\n    bool rd;\n    bool wr;\n    int base_addr;\n    int len;\n    ap_uint<3> q_rd_idx;\n    //ap_uint<3> q_wr_idx;\n};\nstruct InstCmp {\n    int len;\n    double alpha;\n    ap_uint<3> q_idx;\n};\nstruct ResTerm {\n    double res;\n    bool term;\n};\ntemplate <typename T, typename R>\ninline void async_read(tapa::async_mmap<T> & A,\n                       tapa::ostream<T> & fifo_A,\n                       const R i_end_addr,\n                       R & i_req,\n                       R & i_resp) {\n#pragma HLS inline\n    if ((i_req < i_end_addr) &\n        !A.read_addr.full()) {\n        A.read_addr.try_write(i_req);\n        ++i_req;\n    }\n    if (!fifo_A.full() & !A.read_data.empty()) {\n        T tmp;\n        A.read_data.try_read(tmp);\n        fifo_A.try_write(tmp);\n        ++i_resp;\n    }\n}\ntemplate <typename T, typename R>\ninline void async_write(tapa::async_mmap<T> & Y_out,\n                        tapa::istream<T> & fifo_Y,\n                        const R num_ite_Y,\n                        R & i_req,\n                        R & i_resp\n                        ) {\n#pragma HLS inline\n    if ((i_req < num_ite_Y) &\n        !fifo_Y.empty() &\n        !Y_out.write_addr.full() &\n        !Y_out.write_data.full() ) {\n        Y_out.write_addr.try_write(i_req);\n        T tmpv;\n        fifo_Y.try_read(tmpv);\n        Y_out.write_data.try_write(tmpv);\n        ++i_req;\n    }\n    uint8_t n_resp;\n    if (Y_out.write_resp.try_read(n_resp)) {\n        i_resp += R(n_resp) + 1;\n    }\n}\nvoid rdwr_vec(tapa::async_mmap<double_v8> & vec_p,\n              tapa::istream<InstRdWr> & q_inst,\n              tapa::istream<double_v8> & q_din,\n              tapa::ostream<double_v8> & q_dout,\n              tapa::ostream<bool> & q_response\n              ) {\n#pragma HLS disaggregate variable = vec_p\n#pragma HLS interface ap_fifo port = vec_p.read_addr._\n#pragma HLS aggregate variable = vec_p.read_addr._  bit\n#pragma HLS interface ap_fifo port = vec_p.read_data._\n#pragma HLS aggregate variable = vec_p.read_data._  bit\n#pragma HLS interface ap_fifo port = vec_p.write_addr._\n#pragma HLS aggregate variable = vec_p.write_addr._  bit\n#pragma HLS interface ap_fifo port = vec_p.write_data._\n#pragma HLS aggregate variable = vec_p.write_data._  bit\n#pragma HLS interface ap_fifo port = vec_p.write_resp._\n#pragma HLS aggregate variable = vec_p.write_resp._  bit\n#pragma HLS disaggregate variable = vec_p .read_data\n#pragma HLS interface ap_fifo port = vec_p.read_data._peek\n#pragma HLS aggregate variable = vec_p.read_data._peek bit\n#pragma HLS disaggregate variable = vec_p .write_resp\n#pragma HLS interface ap_fifo port = vec_p.write_resp._peek\n#pragma HLS aggregate variable = vec_p.write_resp._peek bit\nvoid(vec_p.read_addr._.full());\nvoid(vec_p.read_data._.empty());\nvoid(vec_p.read_data._peek.empty());\nvoid(vec_p.write_addr._.full());\nvoid(vec_p.write_data._.full());\nvoid(vec_p.write_resp._.empty());\nvoid(vec_p.write_resp._peek.empty());\n\n#pragma HLS disaggregate variable = q_inst\n#pragma HLS interface ap_fifo port = q_inst._\n#pragma HLS aggregate variable = q_inst._ bit\n#pragma HLS interface ap_fifo port = q_inst._peek\n#pragma HLS aggregate variable = q_inst._peek bit\nvoid(q_inst._.empty());\nvoid(q_inst._peek.empty());\n\n#pragma HLS disaggregate variable = q_din\n#pragma HLS interface ap_fifo port = q_din._\n#pragma HLS aggregate variable = q_din._ bit\n#pragma HLS interface ap_fifo port = q_din._peek\n#pragma HLS aggregate variable = q_din._peek bit\nvoid(q_din._.empty());\nvoid(q_din._peek.empty());\n\n#pragma HLS disaggregate variable = q_dout\n#pragma HLS interface ap_fifo port = q_dout._\n#pragma HLS aggregate variable = q_dout._ bit\nvoid(q_dout._.full());\n\n#pragma HLS disaggregate variable = q_response\n#pragma HLS interface ap_fifo port = q_response._\n#pragma HLS aggregate variable = q_response._ bit\nvoid(q_response._.full());\n\n    for (;;) {\n        auto inst = q_inst.read();\n        const int rd_end_addr = inst.rd? (inst.base_addr + inst.len) : 0;\n        const int wr_end_addr = inst.wr? (inst.base_addr + inst.len) : 0;\n        const int rd_total = inst.rd? inst.len : 0;\n        const int wr_total = inst.wr? inst.len : 0;\n    rdwr:\n        for (int rd_req = inst.base_addr, rd_resp = 0,\n             wr_req = inst.base_addr, wr_resp = 0;\n             (rd_resp < rd_total) | (wr_resp < wr_total);) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n            // rd\n            if ((rd_req < rd_end_addr) &\n                !vec_p.read_addr.full()) {\n                vec_p.read_addr.try_write(rd_req);\n                ++rd_req;\n            }\n            if (!q_dout.full() & !vec_p.read_data.empty()) {\n                double_v8 tmp;\n                vec_p.read_data.try_read(tmp);\n                q_dout.try_write(tmp);\n                ++rd_resp;\n            }\n            //wr\n            if ((wr_req < wr_end_addr) &\n                !q_din.empty() &\n                !vec_p.write_addr.full() &\n                !vec_p.write_data.full() ) {\n                vec_p.write_addr.try_write(wr_req);\n                double_v8 tmpv;\n                q_din.try_read(tmpv);\n                vec_p.write_data.try_write(tmpv);\n                ++wr_req;\n            }\n            uint8_t n_resp;\n            if (vec_p.write_resp.try_read(n_resp)) {\n                wr_resp += int(n_resp) + 1;\n            }\n        }\n        ap_wait();\n        if (inst.wr){\n            q_response.write(true);\n        }\n    }\n}\ntemplate <typename data_t>\ninline void q2q(tapa::istream<data_t> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty() & !qout.full()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void clearq(tapa::istream<data_t> & qin,\n                   const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void q2q(tapa::istreams<data_t, 2> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite,\n                const int idx) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin[idx].empty() & !qout.full()) {\n            data_t tmp;\n            qin[idx].try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void qq2qq(tapa::istream<data_t> & qin_pe,\n                  tapa::ostreams<data_t, 2> & qout_mem,\n                  tapa::istreams<data_t, 2> & qin_mem,\n                  tapa::ostream<data_t> & qout_qe,\n                  const int num_ite,\n                  const int idx) {\n#pragma HLS inline\nqq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin_pe.empty() & !qout_mem[idx].full()) {\n            data_t tmp;\n            qin_pe.try_read(tmp);\n            qout_mem[idx].try_write(tmp);\n            ++i;\n        }\n        if (!qin_mem[1 - idx].empty() & !qout_qe.full()) {\n            data_t tmp;\n            qin_mem[1 - idx].try_read(tmp);\n            qout_qe.try_write(tmp);\n        }\n    }\n}\nvoid term_signal_router(tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_to_rdA,\n                        tapa::ostream<bool> & q_to_edgepointer,\n                        tapa::ostream<bool> & q_to_abiter,\n                        tapa::ostream<bool> & q_to_ctrlmem,\n                        tapa::ostream<bool> & q_to_mux\n                        ) ;\nvoid read_edge_list_ptr(const int num_ite,\n                        const int M,\n                        const int rp_time, //P_N,\n                        uint64_t  edge_list_ptr,\n                        tapa::ostream<int> & PE_inst,\n                        tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_gbc_out\n                        ) ;\nvoid read_vec(const int rp_time, //P_N\n              const int M, //K,\n              tapa::async_mmap<double_v8> & vec_X,\n              tapa::ostream<double_v8> & fifo_X\n              ) {\n    //const int rp_time = (P_N == 0)? 1 : P_N;\n    const int num_ite_X = (M + 7) >> 3;\nl_rp:\n    for(int rp = 0; rp < rp_time; rp++) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n    rd_X:\n        for(int i_req = 0, i_resp = 0; i_resp < num_ite_X;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n            async_read(vec_X,\n                       fifo_X,\n                       num_ite_X,\n                       i_req, i_resp);\n        }\n    }\n}\nvoid read_A(const int rp_time, //P_N,\n            const int A_len,\n            uint64_t  A,\n            tapa::ostream<ap_uint<512>> & fifo_A,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid PEG_Xvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<ap_uint<512>> & fifo_A,\n              tapa::istream<double_v8> & fifo_X_in,\n              tapa::ostream<int> & fifo_inst_out,\n              tapa::ostream<double_v8> & fifo_X_out,\n              // to PEG_Yvec\n              tapa::ostream<int> & fifo_inst_out_to_Yvec,\n              tapa::ostream<MultXVec> & fifo_aXvec,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out,\n              tapa::ostream<bool> & q_gbc_out_Y\n              ) ;\nvoid PEG_Yvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<MultXVec> & fifo_aXvec,\n              tapa::ostream<double> & fifo_Y_out,\n              tapa::istream<bool> & q_gbc\n              ) ;\nvoid Arbiter_Y(const int rp_time, //P_N,\n               const int M,\n               tapa::istreams<double, NUM_CH_SPARSE_div_8> & fifo_in, // 2 = 16 / 8\n               tapa::ostream<double> & fifo_out,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\nvoid Merger_Y(tapa::istreams<double, 8> & fifo_in,\n              tapa::ostreams<double_v8, 2> & fifo_out) ;\ntemplate <typename data_t>\ninline void bh(tapa::istream<data_t> & q) {\n#pragma HLS inline\n    for (;;) {\n#pragma HLS pipeline II=1\n        data_t tmp; q.try_read(tmp);\n    }\n}\nvoid black_hole_int(tapa::istream<int> & fifo_in) ;\nvoid black_hole_double_v8(tapa::istream<double_v8> & fifo_in) ;\nvoid black_hole_bool(tapa::istream<bool> & fifo_in) ;\nvoid ctrl_P(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time, //P_N\n            const int M, //K,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_spmv,\n            tapa::ostream<double_v8> & q_dotp,\n            //tapa::ostream<double_v8> & q_updtx,\n            tapa::ostream<double_v8> & q_updtp,\n            tapa::istream<double_v8> & q_updated,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_AP(tapa::istream<double_v8> & qm_din,\n             tapa::ostream<double_v8> & qm_dout,\n             const int rp_time,\n             const int M,\n             tapa::ostream<InstRdWr> & q_inst,\n             tapa::ostream<double_v8> & q_updr,\n             tapa::istream<double_v8> & q_pe,\n             tapa::istream<bool> & q_res,\n             tapa::istream<bool> & q_gbc,\n             tapa::ostream<bool> & q_gbc_out\n             ) ;\nvoid ctrl_X(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_oldx,\n            tapa::istream<double_v8> & q_newx,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_R(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & qr_to_pe,\n            tapa::istream<double_v8> & qr_from_pe,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid read_digA(uint64_t  vec_mem,\n               const int rp_time, //P_N\n               const int M, //K,\n               tapa::ostream<double_v8> & q_dout,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n/*  computation modules  */\n//M2: alpha = rzold / (p' * Ap)\nvoid dot_alpha(const int rp_time,\n               const int M,\n               //const unsigned long rz0,\n               tapa::istream<double> & qrz,\n               tapa::istream<double_v8> & q1,\n               tapa::istream<double_v8> & q2,\n               tapa::ostreams<double, 2> & q3,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M end: res = r' * r\nvoid dot_res(const int rp_time,\n             const int M,\n             const double th_termination,\n             tapa::istream<double_v8> & q1,\n             tapa::ostream<ResTerm> & q2,\n             tapa::ostream<bool> & q_termination\n             ) ;\n//M6: rznew = r' * z\nvoid dot_rznew(const int rp_time,\n               const int M,\n               tapa::istream<double_v8> & qr,\n               tapa::istream<double_v8> & qz,\n               tapa::ostream<double_v8> & qr_out,\n               tapa::ostreams<double, 2> & qrz,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M3: x = x + alpha * p\nvoid updt_x(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qx,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M7: p = z + (rznew/rzold) * p\nvoid updt_p(const int rp_time,\n            const int M,\n            //const unsigned long rz0,\n            tapa::istream<double> & qrznew,\n            tapa::istream<double_v8> & qz,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qp2m3,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M4: r = r - alpha * Ap\nvoid updt_r(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qr,\n            tapa::istream<double_v8> & qap,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M5: z = diagA \\ r\nvoid left_div(const int rp_time,\n              const int M,\n              tapa::istream<double_v8> & qr,\n              tapa::istream<double_v8> & qdiagA,\n              tapa::ostreams<double_v8, 2> & qz,\n              tapa::ostream<double_v8> & qr_m6,\n              tapa::ostream<double_v8> & qrmem,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out\n              ) ;\nvoid wr_r(const int rp_time,\n          uint64_t  vec_r,\n          tapa::istream<ResTerm> & q_din\n          ) ;\nvoid duplicator(tapa::istream<double_v8> & q_in,\n                tapa::ostream<double_v8> & q_out1,\n                tapa::ostream<double_v8> & q_out2\n                ) ;\nvoid vecp_mux(const int rp_time,\n              const int M,\n              tapa::istream<bool> & q_gbc,\n              tapa::istream<double_v8> & q_in1,\n              tapa::istream<double_v8> & q_in2,\n              tapa::ostream<double_v8> & q_out\n              ) ;\nvoid Callipepla(uint64_t  edge_list_ptr,\n                uint64_t edge_list_ch_0, uint64_t edge_list_ch_1, uint64_t edge_list_ch_2, uint64_t edge_list_ch_3, uint64_t edge_list_ch_4, uint64_t edge_list_ch_5, uint64_t edge_list_ch_6, uint64_t edge_list_ch_7, uint64_t edge_list_ch_8, uint64_t edge_list_ch_9, uint64_t edge_list_ch_10, uint64_t edge_list_ch_11, uint64_t edge_list_ch_12, uint64_t edge_list_ch_13, uint64_t edge_list_ch_14, uint64_t edge_list_ch_15,\n                uint64_t vec_x_0, uint64_t vec_x_1,\n                uint64_t vec_p_0, uint64_t vec_p_1,\n                uint64_t  vec_Ap,\n                uint64_t vec_r_0, uint64_t vec_r_1,\n                uint64_t  vec_digA,\n                uint64_t  vec_res,\n                const int NUM_ITE,\n                const int NUM_A_LEN,\n                const int M,\n                const int rp_time,\n                const double th_termination\n                ) ;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "read_A": {
            "code": "\n\n #include <ap_int.h>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cassert>\n\n\n #include \"ap_utils.h\"\n\n#include <tapa.h>\n\n\n\n #include <ap_int.h>\n\n#include <tapa.h>\nconstexpr int NUM_CH_SPARSE = 16;\nconstexpr int X_PARTITION_FACTOR = 4; // BRAMs = 512 / 16 / 2 = 16 -> factor = 16 / (64 / 16)\nconstexpr int WINDOW_SIZE = X_PARTITION_FACTOR * 1024;\nconstexpr int DEP_DIST_LOAD_STORE = 7;\nconstexpr int URAM_DEPTH = 3 * 4096;\n// ch16: 3 * 4096 * 16 * 8 = 1,572,864\nusing double_v8 = tapa::vec_t<double, 8>;\nvoid Callipepla(tapa::mmap<int> edge_list_ptr,\n                tapa::mmaps<ap_uint<512>, NUM_CH_SPARSE> edge_list_ch,\n                tapa::mmaps<double_v8, 2> vec_x,\n                tapa::mmaps<double_v8, 2> vec_p,\n                tapa::mmap<double_v8> vec_Ap,\n                tapa::mmaps<double_v8, 2> vec_r,\n                tapa::mmap<double_v8> vec_digA,\n                tapa::mmap<double> vec_res,\n                const int NUM_ITE, const int NUM_A_LEN, const int M,\n                const int rp_time,\n                const double th_termination\n                );\n\nconstexpr int FIFO_DEPTH = 2;\nconstexpr int FIFO_DEPTH_M6 = 50;\nconst int NUM_CH_SPARSE_div_8 = NUM_CH_SPARSE / 8;\nconst int NUM_CH_SPARSE_mult_8 = NUM_CH_SPARSE * 8;\nconst int WINDOW_SIZE_div_8 = WINDOW_SIZE / 8;\nstruct MultXVec {\n    tapa::vec_t<ap_uint<18>, 8> row;\n    double_v8 axv;\n};\nstruct InstRdWr {\n    bool rd;\n    bool wr;\n    //bool require_response;\n    int base_addr;\n    int len;\n};\nstruct InstVCtrl {\n    bool rd;\n    bool wr;\n    int base_addr;\n    int len;\n    ap_uint<3> q_rd_idx;\n    //ap_uint<3> q_wr_idx;\n};\nstruct InstCmp {\n    int len;\n    double alpha;\n    ap_uint<3> q_idx;\n};\nstruct ResTerm {\n    double res;\n    bool term;\n};\ntemplate <typename T, typename R>\ninline void async_read(tapa::async_mmap<T> & A,\n                       tapa::ostream<T> & fifo_A,\n                       const R i_end_addr,\n                       R & i_req,\n                       R & i_resp) {\n#pragma HLS inline\n    if ((i_req < i_end_addr) &\n        !A.read_addr.full()) {\n        A.read_addr.try_write(i_req);\n        ++i_req;\n    }\n    if (!fifo_A.full() & !A.read_data.empty()) {\n        T tmp;\n        A.read_data.try_read(tmp);\n        fifo_A.try_write(tmp);\n        ++i_resp;\n    }\n}\ntemplate <typename T, typename R>\ninline void async_write(tapa::async_mmap<T> & Y_out,\n                        tapa::istream<T> & fifo_Y,\n                        const R num_ite_Y,\n                        R & i_req,\n                        R & i_resp\n                        ) {\n#pragma HLS inline\n    if ((i_req < num_ite_Y) &\n        !fifo_Y.empty() &\n        !Y_out.write_addr.full() &\n        !Y_out.write_data.full() ) {\n        Y_out.write_addr.try_write(i_req);\n        T tmpv;\n        fifo_Y.try_read(tmpv);\n        Y_out.write_data.try_write(tmpv);\n        ++i_req;\n    }\n    uint8_t n_resp;\n    if (Y_out.write_resp.try_read(n_resp)) {\n        i_resp += R(n_resp) + 1;\n    }\n}\nvoid rdwr_vec(uint64_t  vec_p,\n              tapa::istream<InstRdWr> & q_inst,\n              tapa::istream<double_v8> & q_din,\n              tapa::ostream<double_v8> & q_dout,\n              tapa::ostream<bool> & q_response\n              ) ;\ntemplate <typename data_t>\ninline void q2q(tapa::istream<data_t> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty() & !qout.full()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void clearq(tapa::istream<data_t> & qin,\n                   const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void q2q(tapa::istreams<data_t, 2> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite,\n                const int idx) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin[idx].empty() & !qout.full()) {\n            data_t tmp;\n            qin[idx].try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void qq2qq(tapa::istream<data_t> & qin_pe,\n                  tapa::ostreams<data_t, 2> & qout_mem,\n                  tapa::istreams<data_t, 2> & qin_mem,\n                  tapa::ostream<data_t> & qout_qe,\n                  const int num_ite,\n                  const int idx) {\n#pragma HLS inline\nqq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin_pe.empty() & !qout_mem[idx].full()) {\n            data_t tmp;\n            qin_pe.try_read(tmp);\n            qout_mem[idx].try_write(tmp);\n            ++i;\n        }\n        if (!qin_mem[1 - idx].empty() & !qout_qe.full()) {\n            data_t tmp;\n            qin_mem[1 - idx].try_read(tmp);\n            qout_qe.try_write(tmp);\n        }\n    }\n}\nvoid term_signal_router(tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_to_rdA,\n                        tapa::ostream<bool> & q_to_edgepointer,\n                        tapa::ostream<bool> & q_to_abiter,\n                        tapa::ostream<bool> & q_to_ctrlmem,\n                        tapa::ostream<bool> & q_to_mux\n                        ) ;\nvoid read_edge_list_ptr(const int num_ite,\n                        const int M,\n                        const int rp_time, //P_N,\n                        uint64_t  edge_list_ptr,\n                        tapa::ostream<int> & PE_inst,\n                        tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_gbc_out\n                        ) ;\nvoid read_vec(const int rp_time, //P_N\n              const int M, //K,\n              tapa::async_mmap<double_v8> & vec_X,\n              tapa::ostream<double_v8> & fifo_X\n              ) {\n    //const int rp_time = (P_N == 0)? 1 : P_N;\n    const int num_ite_X = (M + 7) >> 3;\nl_rp:\n    for(int rp = 0; rp < rp_time; rp++) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n    rd_X:\n        for(int i_req = 0, i_resp = 0; i_resp < num_ite_X;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n            async_read(vec_X,\n                       fifo_X,\n                       num_ite_X,\n                       i_req, i_resp);\n        }\n    }\n}\nvoid read_A(const int rp_time, //P_N,\n            const int A_len,\n            tapa::async_mmap<ap_uint<512>> & A,\n            tapa::ostream<ap_uint<512>> & fifo_A,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) {\n\n\n#pragma HLS disaggregate variable = A\n#pragma HLS interface ap_fifo port = A.read_addr._\n#pragma HLS aggregate variable = A.read_addr._  bit\n#pragma HLS interface ap_fifo port = A.read_data._\n#pragma HLS aggregate variable = A.read_data._  bit\n#pragma HLS interface ap_fifo port = A.write_addr._\n#pragma HLS aggregate variable = A.write_addr._  bit\n#pragma HLS interface ap_fifo port = A.write_data._\n#pragma HLS aggregate variable = A.write_data._  bit\n#pragma HLS interface ap_fifo port = A.write_resp._\n#pragma HLS aggregate variable = A.write_resp._  bit\n#pragma HLS disaggregate variable = A .read_data\n#pragma HLS interface ap_fifo port = A.read_data._peek\n#pragma HLS aggregate variable = A.read_data._peek bit\n#pragma HLS disaggregate variable = A .write_resp\n#pragma HLS interface ap_fifo port = A.write_resp._peek\n#pragma HLS aggregate variable = A.write_resp._peek bit\nvoid(A.read_addr._.full());\nvoid(A.read_data._.empty());\nvoid(A.read_data._peek.empty());\nvoid(A.write_addr._.full());\nvoid(A.write_data._.full());\nvoid(A.write_resp._.empty());\nvoid(A.write_resp._peek.empty());\n\n#pragma HLS disaggregate variable = fifo_A\n#pragma HLS interface ap_fifo port = fifo_A._\n#pragma HLS aggregate variable = fifo_A._ bit\nvoid(fifo_A._.full());\n\n#pragma HLS disaggregate variable = q_gbc\n#pragma HLS interface ap_fifo port = q_gbc._\n#pragma HLS aggregate variable = q_gbc._ bit\n#pragma HLS interface ap_fifo port = q_gbc._peek\n#pragma HLS aggregate variable = q_gbc._peek bit\nvoid(q_gbc._.empty());\nvoid(q_gbc._peek.empty());\n\n#pragma HLS disaggregate variable = q_gbc_out\n#pragma HLS interface ap_fifo port = q_gbc_out._\n#pragma HLS aggregate variable = q_gbc_out._ bit\nvoid(q_gbc_out._.full());\n\n    //const int rp_time = (P_N == 0)? 1 : P_N;\n    bool term_flag = false;\nl_rp:\n    for(int rp = -1; !term_flag & (rp < rp_time); rp++) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n    rd_A:\n        for(int i_req = 0, i_resp = 0; i_resp < A_len;) {\n#pragma HLS loop_tripcount min=1 max=10000\n#pragma HLS pipeline II=1\n            async_read(A,\n                       fifo_A,\n                       A_len,\n                       i_req, i_resp);\n        }\n        ap_wait();\n        term_flag = q_gbc.read();\n        q_gbc_out.write(term_flag);\n    }\n    //cout << \"##### exit read_A\\n\";\n}\nvoid PEG_Xvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<ap_uint<512>> & fifo_A,\n              tapa::istream<double_v8> & fifo_X_in,\n              tapa::ostream<int> & fifo_inst_out,\n              tapa::ostream<double_v8> & fifo_X_out,\n              // to PEG_Yvec\n              tapa::ostream<int> & fifo_inst_out_to_Yvec,\n              tapa::ostream<MultXVec> & fifo_aXvec,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out,\n              tapa::ostream<bool> & q_gbc_out_Y\n              ) ;\nvoid PEG_Yvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<MultXVec> & fifo_aXvec,\n              tapa::ostream<double> & fifo_Y_out,\n              tapa::istream<bool> & q_gbc\n              ) ;\nvoid Arbiter_Y(const int rp_time, //P_N,\n               const int M,\n               tapa::istreams<double, NUM_CH_SPARSE_div_8> & fifo_in, // 2 = 16 / 8\n               tapa::ostream<double> & fifo_out,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\nvoid Merger_Y(tapa::istreams<double, 8> & fifo_in,\n              tapa::ostreams<double_v8, 2> & fifo_out) ;\ntemplate <typename data_t>\ninline void bh(tapa::istream<data_t> & q) {\n#pragma HLS inline\n    for (;;) {\n#pragma HLS pipeline II=1\n        data_t tmp; q.try_read(tmp);\n    }\n}\nvoid black_hole_int(tapa::istream<int> & fifo_in) ;\nvoid black_hole_double_v8(tapa::istream<double_v8> & fifo_in) ;\nvoid black_hole_bool(tapa::istream<bool> & fifo_in) ;\nvoid ctrl_P(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time, //P_N\n            const int M, //K,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_spmv,\n            tapa::ostream<double_v8> & q_dotp,\n            //tapa::ostream<double_v8> & q_updtx,\n            tapa::ostream<double_v8> & q_updtp,\n            tapa::istream<double_v8> & q_updated,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_AP(tapa::istream<double_v8> & qm_din,\n             tapa::ostream<double_v8> & qm_dout,\n             const int rp_time,\n             const int M,\n             tapa::ostream<InstRdWr> & q_inst,\n             tapa::ostream<double_v8> & q_updr,\n             tapa::istream<double_v8> & q_pe,\n             tapa::istream<bool> & q_res,\n             tapa::istream<bool> & q_gbc,\n             tapa::ostream<bool> & q_gbc_out\n             ) ;\nvoid ctrl_X(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_oldx,\n            tapa::istream<double_v8> & q_newx,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_R(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & qr_to_pe,\n            tapa::istream<double_v8> & qr_from_pe,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid read_digA(uint64_t  vec_mem,\n               const int rp_time, //P_N\n               const int M, //K,\n               tapa::ostream<double_v8> & q_dout,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n/*  computation modules  */\n//M2: alpha = rzold / (p' * Ap)\nvoid dot_alpha(const int rp_time,\n               const int M,\n               //const unsigned long rz0,\n               tapa::istream<double> & qrz,\n               tapa::istream<double_v8> & q1,\n               tapa::istream<double_v8> & q2,\n               tapa::ostreams<double, 2> & q3,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M end: res = r' * r\nvoid dot_res(const int rp_time,\n             const int M,\n             const double th_termination,\n             tapa::istream<double_v8> & q1,\n             tapa::ostream<ResTerm> & q2,\n             tapa::ostream<bool> & q_termination\n             ) ;\n//M6: rznew = r' * z\nvoid dot_rznew(const int rp_time,\n               const int M,\n               tapa::istream<double_v8> & qr,\n               tapa::istream<double_v8> & qz,\n               tapa::ostream<double_v8> & qr_out,\n               tapa::ostreams<double, 2> & qrz,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M3: x = x + alpha * p\nvoid updt_x(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qx,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M7: p = z + (rznew/rzold) * p\nvoid updt_p(const int rp_time,\n            const int M,\n            //const unsigned long rz0,\n            tapa::istream<double> & qrznew,\n            tapa::istream<double_v8> & qz,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qp2m3,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M4: r = r - alpha * Ap\nvoid updt_r(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qr,\n            tapa::istream<double_v8> & qap,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M5: z = diagA \\ r\nvoid left_div(const int rp_time,\n              const int M,\n              tapa::istream<double_v8> & qr,\n              tapa::istream<double_v8> & qdiagA,\n              tapa::ostreams<double_v8, 2> & qz,\n              tapa::ostream<double_v8> & qr_m6,\n              tapa::ostream<double_v8> & qrmem,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out\n              ) ;\nvoid wr_r(const int rp_time,\n          uint64_t  vec_r,\n          tapa::istream<ResTerm> & q_din\n          ) ;\nvoid duplicator(tapa::istream<double_v8> & q_in,\n                tapa::ostream<double_v8> & q_out1,\n                tapa::ostream<double_v8> & q_out2\n                ) ;\nvoid vecp_mux(const int rp_time,\n              const int M,\n              tapa::istream<bool> & q_gbc,\n              tapa::istream<double_v8> & q_in1,\n              tapa::istream<double_v8> & q_in2,\n              tapa::ostream<double_v8> & q_out\n              ) ;\nvoid Callipepla(uint64_t  edge_list_ptr,\n                uint64_t edge_list_ch_0, uint64_t edge_list_ch_1, uint64_t edge_list_ch_2, uint64_t edge_list_ch_3, uint64_t edge_list_ch_4, uint64_t edge_list_ch_5, uint64_t edge_list_ch_6, uint64_t edge_list_ch_7, uint64_t edge_list_ch_8, uint64_t edge_list_ch_9, uint64_t edge_list_ch_10, uint64_t edge_list_ch_11, uint64_t edge_list_ch_12, uint64_t edge_list_ch_13, uint64_t edge_list_ch_14, uint64_t edge_list_ch_15,\n                uint64_t vec_x_0, uint64_t vec_x_1,\n                uint64_t vec_p_0, uint64_t vec_p_1,\n                uint64_t  vec_Ap,\n                uint64_t vec_r_0, uint64_t vec_r_1,\n                uint64_t  vec_digA,\n                uint64_t  vec_res,\n                const int NUM_ITE,\n                const int NUM_A_LEN,\n                const int M,\n                const int rp_time,\n                const double th_termination\n                ) ;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "read_digA": {
            "code": "\n\n #include <ap_int.h>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cassert>\n\n\n #include \"ap_utils.h\"\n\n#include <tapa.h>\n\n\n\n #include <ap_int.h>\n\n#include <tapa.h>\nconstexpr int NUM_CH_SPARSE = 16;\nconstexpr int X_PARTITION_FACTOR = 4; // BRAMs = 512 / 16 / 2 = 16 -> factor = 16 / (64 / 16)\nconstexpr int WINDOW_SIZE = X_PARTITION_FACTOR * 1024;\nconstexpr int DEP_DIST_LOAD_STORE = 7;\nconstexpr int URAM_DEPTH = 3 * 4096;\n// ch16: 3 * 4096 * 16 * 8 = 1,572,864\nusing double_v8 = tapa::vec_t<double, 8>;\nvoid Callipepla(tapa::mmap<int> edge_list_ptr,\n                tapa::mmaps<ap_uint<512>, NUM_CH_SPARSE> edge_list_ch,\n                tapa::mmaps<double_v8, 2> vec_x,\n                tapa::mmaps<double_v8, 2> vec_p,\n                tapa::mmap<double_v8> vec_Ap,\n                tapa::mmaps<double_v8, 2> vec_r,\n                tapa::mmap<double_v8> vec_digA,\n                tapa::mmap<double> vec_res,\n                const int NUM_ITE, const int NUM_A_LEN, const int M,\n                const int rp_time,\n                const double th_termination\n                );\n\nconstexpr int FIFO_DEPTH = 2;\nconstexpr int FIFO_DEPTH_M6 = 50;\nconst int NUM_CH_SPARSE_div_8 = NUM_CH_SPARSE / 8;\nconst int NUM_CH_SPARSE_mult_8 = NUM_CH_SPARSE * 8;\nconst int WINDOW_SIZE_div_8 = WINDOW_SIZE / 8;\nstruct MultXVec {\n    tapa::vec_t<ap_uint<18>, 8> row;\n    double_v8 axv;\n};\nstruct InstRdWr {\n    bool rd;\n    bool wr;\n    //bool require_response;\n    int base_addr;\n    int len;\n};\nstruct InstVCtrl {\n    bool rd;\n    bool wr;\n    int base_addr;\n    int len;\n    ap_uint<3> q_rd_idx;\n    //ap_uint<3> q_wr_idx;\n};\nstruct InstCmp {\n    int len;\n    double alpha;\n    ap_uint<3> q_idx;\n};\nstruct ResTerm {\n    double res;\n    bool term;\n};\ntemplate <typename T, typename R>\ninline void async_read(tapa::async_mmap<T> & A,\n                       tapa::ostream<T> & fifo_A,\n                       const R i_end_addr,\n                       R & i_req,\n                       R & i_resp) {\n#pragma HLS inline\n    if ((i_req < i_end_addr) &\n        !A.read_addr.full()) {\n        A.read_addr.try_write(i_req);\n        ++i_req;\n    }\n    if (!fifo_A.full() & !A.read_data.empty()) {\n        T tmp;\n        A.read_data.try_read(tmp);\n        fifo_A.try_write(tmp);\n        ++i_resp;\n    }\n}\ntemplate <typename T, typename R>\ninline void async_write(tapa::async_mmap<T> & Y_out,\n                        tapa::istream<T> & fifo_Y,\n                        const R num_ite_Y,\n                        R & i_req,\n                        R & i_resp\n                        ) {\n#pragma HLS inline\n    if ((i_req < num_ite_Y) &\n        !fifo_Y.empty() &\n        !Y_out.write_addr.full() &\n        !Y_out.write_data.full() ) {\n        Y_out.write_addr.try_write(i_req);\n        T tmpv;\n        fifo_Y.try_read(tmpv);\n        Y_out.write_data.try_write(tmpv);\n        ++i_req;\n    }\n    uint8_t n_resp;\n    if (Y_out.write_resp.try_read(n_resp)) {\n        i_resp += R(n_resp) + 1;\n    }\n}\nvoid rdwr_vec(uint64_t  vec_p,\n              tapa::istream<InstRdWr> & q_inst,\n              tapa::istream<double_v8> & q_din,\n              tapa::ostream<double_v8> & q_dout,\n              tapa::ostream<bool> & q_response\n              ) ;\ntemplate <typename data_t>\ninline void q2q(tapa::istream<data_t> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty() & !qout.full()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void clearq(tapa::istream<data_t> & qin,\n                   const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void q2q(tapa::istreams<data_t, 2> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite,\n                const int idx) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin[idx].empty() & !qout.full()) {\n            data_t tmp;\n            qin[idx].try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void qq2qq(tapa::istream<data_t> & qin_pe,\n                  tapa::ostreams<data_t, 2> & qout_mem,\n                  tapa::istreams<data_t, 2> & qin_mem,\n                  tapa::ostream<data_t> & qout_qe,\n                  const int num_ite,\n                  const int idx) {\n#pragma HLS inline\nqq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin_pe.empty() & !qout_mem[idx].full()) {\n            data_t tmp;\n            qin_pe.try_read(tmp);\n            qout_mem[idx].try_write(tmp);\n            ++i;\n        }\n        if (!qin_mem[1 - idx].empty() & !qout_qe.full()) {\n            data_t tmp;\n            qin_mem[1 - idx].try_read(tmp);\n            qout_qe.try_write(tmp);\n        }\n    }\n}\nvoid term_signal_router(tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_to_rdA,\n                        tapa::ostream<bool> & q_to_edgepointer,\n                        tapa::ostream<bool> & q_to_abiter,\n                        tapa::ostream<bool> & q_to_ctrlmem,\n                        tapa::ostream<bool> & q_to_mux\n                        ) ;\nvoid read_edge_list_ptr(const int num_ite,\n                        const int M,\n                        const int rp_time, //P_N,\n                        uint64_t  edge_list_ptr,\n                        tapa::ostream<int> & PE_inst,\n                        tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_gbc_out\n                        ) ;\nvoid read_vec(const int rp_time, //P_N\n              const int M, //K,\n              tapa::async_mmap<double_v8> & vec_X,\n              tapa::ostream<double_v8> & fifo_X\n              ) {\n    //const int rp_time = (P_N == 0)? 1 : P_N;\n    const int num_ite_X = (M + 7) >> 3;\nl_rp:\n    for(int rp = 0; rp < rp_time; rp++) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n    rd_X:\n        for(int i_req = 0, i_resp = 0; i_resp < num_ite_X;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n            async_read(vec_X,\n                       fifo_X,\n                       num_ite_X,\n                       i_req, i_resp);\n        }\n    }\n}\nvoid read_A(const int rp_time, //P_N,\n            const int A_len,\n            uint64_t  A,\n            tapa::ostream<ap_uint<512>> & fifo_A,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid PEG_Xvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<ap_uint<512>> & fifo_A,\n              tapa::istream<double_v8> & fifo_X_in,\n              tapa::ostream<int> & fifo_inst_out,\n              tapa::ostream<double_v8> & fifo_X_out,\n              // to PEG_Yvec\n              tapa::ostream<int> & fifo_inst_out_to_Yvec,\n              tapa::ostream<MultXVec> & fifo_aXvec,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out,\n              tapa::ostream<bool> & q_gbc_out_Y\n              ) ;\nvoid PEG_Yvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<MultXVec> & fifo_aXvec,\n              tapa::ostream<double> & fifo_Y_out,\n              tapa::istream<bool> & q_gbc\n              ) ;\nvoid Arbiter_Y(const int rp_time, //P_N,\n               const int M,\n               tapa::istreams<double, NUM_CH_SPARSE_div_8> & fifo_in, // 2 = 16 / 8\n               tapa::ostream<double> & fifo_out,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\nvoid Merger_Y(tapa::istreams<double, 8> & fifo_in,\n              tapa::ostreams<double_v8, 2> & fifo_out) ;\ntemplate <typename data_t>\ninline void bh(tapa::istream<data_t> & q) {\n#pragma HLS inline\n    for (;;) {\n#pragma HLS pipeline II=1\n        data_t tmp; q.try_read(tmp);\n    }\n}\nvoid black_hole_int(tapa::istream<int> & fifo_in) ;\nvoid black_hole_double_v8(tapa::istream<double_v8> & fifo_in) ;\nvoid black_hole_bool(tapa::istream<bool> & fifo_in) ;\nvoid ctrl_P(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time, //P_N\n            const int M, //K,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_spmv,\n            tapa::ostream<double_v8> & q_dotp,\n            //tapa::ostream<double_v8> & q_updtx,\n            tapa::ostream<double_v8> & q_updtp,\n            tapa::istream<double_v8> & q_updated,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_AP(tapa::istream<double_v8> & qm_din,\n             tapa::ostream<double_v8> & qm_dout,\n             const int rp_time,\n             const int M,\n             tapa::ostream<InstRdWr> & q_inst,\n             tapa::ostream<double_v8> & q_updr,\n             tapa::istream<double_v8> & q_pe,\n             tapa::istream<bool> & q_res,\n             tapa::istream<bool> & q_gbc,\n             tapa::ostream<bool> & q_gbc_out\n             ) ;\nvoid ctrl_X(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_oldx,\n            tapa::istream<double_v8> & q_newx,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_R(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & qr_to_pe,\n            tapa::istream<double_v8> & qr_from_pe,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid read_digA(tapa::async_mmap<double_v8> & vec_mem,\n               const int rp_time, //P_N\n               const int M, //K,\n               tapa::ostream<double_v8> & q_dout,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) {\n#pragma HLS disaggregate variable = vec_mem\n#pragma HLS interface ap_fifo port = vec_mem.read_addr._\n#pragma HLS aggregate variable = vec_mem.read_addr._  bit\n#pragma HLS interface ap_fifo port = vec_mem.read_data._\n#pragma HLS aggregate variable = vec_mem.read_data._  bit\n#pragma HLS interface ap_fifo port = vec_mem.write_addr._\n#pragma HLS aggregate variable = vec_mem.write_addr._  bit\n#pragma HLS interface ap_fifo port = vec_mem.write_data._\n#pragma HLS aggregate variable = vec_mem.write_data._  bit\n#pragma HLS interface ap_fifo port = vec_mem.write_resp._\n#pragma HLS aggregate variable = vec_mem.write_resp._  bit\n#pragma HLS disaggregate variable = vec_mem .read_data\n#pragma HLS interface ap_fifo port = vec_mem.read_data._peek\n#pragma HLS aggregate variable = vec_mem.read_data._peek bit\n#pragma HLS disaggregate variable = vec_mem .write_resp\n#pragma HLS interface ap_fifo port = vec_mem.write_resp._peek\n#pragma HLS aggregate variable = vec_mem.write_resp._peek bit\nvoid(vec_mem.read_addr._.full());\nvoid(vec_mem.read_data._.empty());\nvoid(vec_mem.read_data._peek.empty());\nvoid(vec_mem.write_addr._.full());\nvoid(vec_mem.write_data._.full());\nvoid(vec_mem.write_resp._.empty());\nvoid(vec_mem.write_resp._peek.empty());\n\n\n\n#pragma HLS disaggregate variable = q_dout\n#pragma HLS interface ap_fifo port = q_dout._\n#pragma HLS aggregate variable = q_dout._ bit\nvoid(q_dout._.full());\n\n#pragma HLS disaggregate variable = q_gbc\n#pragma HLS interface ap_fifo port = q_gbc._\n#pragma HLS aggregate variable = q_gbc._ bit\n#pragma HLS interface ap_fifo port = q_gbc._peek\n#pragma HLS aggregate variable = q_gbc._peek bit\nvoid(q_gbc._.empty());\nvoid(q_gbc._peek.empty());\n\n#pragma HLS disaggregate variable = q_gbc_out\n#pragma HLS interface ap_fifo port = q_gbc_out._\n#pragma HLS aggregate variable = q_gbc_out._ bit\nvoid(q_gbc_out._.full());\n\n    // InstVCtrl vinst = {true, false, 0, (M + 7) >> 3, 0};\n    const int num_ite_M = (M + 7) >> 3;\n    bool term_flag = false;\nl_rp:\n    for(int rp = -2; !term_flag & (rp < rp_time * 2); rp++) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n    rd:\n        for (int addr_req = 0, i_resp = 0; i_resp < num_ite_M;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n            async_read(vec_mem,\n                       q_dout,\n                       num_ite_M,\n                       addr_req, i_resp);\n        }\n        ap_wait();\n        if (rp & 0x1) {\n            term_flag = q_gbc.read();\n            q_gbc_out.write(term_flag);\n        }\n    }\n    //cout << \"## exit ctrl_diagA\\n\";\n}\n/*  computation modules  */\n//M2: alpha = rzold / (p' * Ap)\nvoid dot_alpha(const int rp_time,\n               const int M,\n               //const unsigned long rz0,\n               tapa::istream<double> & qrz,\n               tapa::istream<double_v8> & q1,\n               tapa::istream<double_v8> & q2,\n               tapa::ostreams<double, 2> & q3,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M end: res = r' * r\nvoid dot_res(const int rp_time,\n             const int M,\n             const double th_termination,\n             tapa::istream<double_v8> & q1,\n             tapa::ostream<ResTerm> & q2,\n             tapa::ostream<bool> & q_termination\n             ) ;\n//M6: rznew = r' * z\nvoid dot_rznew(const int rp_time,\n               const int M,\n               tapa::istream<double_v8> & qr,\n               tapa::istream<double_v8> & qz,\n               tapa::ostream<double_v8> & qr_out,\n               tapa::ostreams<double, 2> & qrz,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M3: x = x + alpha * p\nvoid updt_x(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qx,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M7: p = z + (rznew/rzold) * p\nvoid updt_p(const int rp_time,\n            const int M,\n            //const unsigned long rz0,\n            tapa::istream<double> & qrznew,\n            tapa::istream<double_v8> & qz,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qp2m3,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M4: r = r - alpha * Ap\nvoid updt_r(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qr,\n            tapa::istream<double_v8> & qap,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M5: z = diagA \\ r\nvoid left_div(const int rp_time,\n              const int M,\n              tapa::istream<double_v8> & qr,\n              tapa::istream<double_v8> & qdiagA,\n              tapa::ostreams<double_v8, 2> & qz,\n              tapa::ostream<double_v8> & qr_m6,\n              tapa::ostream<double_v8> & qrmem,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out\n              ) ;\nvoid wr_r(const int rp_time,\n          uint64_t  vec_r,\n          tapa::istream<ResTerm> & q_din\n          ) ;\nvoid duplicator(tapa::istream<double_v8> & q_in,\n                tapa::ostream<double_v8> & q_out1,\n                tapa::ostream<double_v8> & q_out2\n                ) ;\nvoid vecp_mux(const int rp_time,\n              const int M,\n              tapa::istream<bool> & q_gbc,\n              tapa::istream<double_v8> & q_in1,\n              tapa::istream<double_v8> & q_in2,\n              tapa::ostream<double_v8> & q_out\n              ) ;\nvoid Callipepla(uint64_t  edge_list_ptr,\n                uint64_t edge_list_ch_0, uint64_t edge_list_ch_1, uint64_t edge_list_ch_2, uint64_t edge_list_ch_3, uint64_t edge_list_ch_4, uint64_t edge_list_ch_5, uint64_t edge_list_ch_6, uint64_t edge_list_ch_7, uint64_t edge_list_ch_8, uint64_t edge_list_ch_9, uint64_t edge_list_ch_10, uint64_t edge_list_ch_11, uint64_t edge_list_ch_12, uint64_t edge_list_ch_13, uint64_t edge_list_ch_14, uint64_t edge_list_ch_15,\n                uint64_t vec_x_0, uint64_t vec_x_1,\n                uint64_t vec_p_0, uint64_t vec_p_1,\n                uint64_t  vec_Ap,\n                uint64_t vec_r_0, uint64_t vec_r_1,\n                uint64_t  vec_digA,\n                uint64_t  vec_res,\n                const int NUM_ITE,\n                const int NUM_A_LEN,\n                const int M,\n                const int rp_time,\n                const double th_termination\n                ) ;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "read_edge_list_ptr": {
            "code": "\n\n #include <ap_int.h>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cassert>\n\n\n #include \"ap_utils.h\"\n\n#include <tapa.h>\n\n\n\n #include <ap_int.h>\n\n#include <tapa.h>\nconstexpr int NUM_CH_SPARSE = 16;\nconstexpr int X_PARTITION_FACTOR = 4; // BRAMs = 512 / 16 / 2 = 16 -> factor = 16 / (64 / 16)\nconstexpr int WINDOW_SIZE = X_PARTITION_FACTOR * 1024;\nconstexpr int DEP_DIST_LOAD_STORE = 7;\nconstexpr int URAM_DEPTH = 3 * 4096;\n// ch16: 3 * 4096 * 16 * 8 = 1,572,864\nusing double_v8 = tapa::vec_t<double, 8>;\nvoid Callipepla(tapa::mmap<int> edge_list_ptr,\n                tapa::mmaps<ap_uint<512>, NUM_CH_SPARSE> edge_list_ch,\n                tapa::mmaps<double_v8, 2> vec_x,\n                tapa::mmaps<double_v8, 2> vec_p,\n                tapa::mmap<double_v8> vec_Ap,\n                tapa::mmaps<double_v8, 2> vec_r,\n                tapa::mmap<double_v8> vec_digA,\n                tapa::mmap<double> vec_res,\n                const int NUM_ITE, const int NUM_A_LEN, const int M,\n                const int rp_time,\n                const double th_termination\n                );\n\nconstexpr int FIFO_DEPTH = 2;\nconstexpr int FIFO_DEPTH_M6 = 50;\nconst int NUM_CH_SPARSE_div_8 = NUM_CH_SPARSE / 8;\nconst int NUM_CH_SPARSE_mult_8 = NUM_CH_SPARSE * 8;\nconst int WINDOW_SIZE_div_8 = WINDOW_SIZE / 8;\nstruct MultXVec {\n    tapa::vec_t<ap_uint<18>, 8> row;\n    double_v8 axv;\n};\nstruct InstRdWr {\n    bool rd;\n    bool wr;\n    //bool require_response;\n    int base_addr;\n    int len;\n};\nstruct InstVCtrl {\n    bool rd;\n    bool wr;\n    int base_addr;\n    int len;\n    ap_uint<3> q_rd_idx;\n    //ap_uint<3> q_wr_idx;\n};\nstruct InstCmp {\n    int len;\n    double alpha;\n    ap_uint<3> q_idx;\n};\nstruct ResTerm {\n    double res;\n    bool term;\n};\ntemplate <typename T, typename R>\ninline void async_read(tapa::async_mmap<T> & A,\n                       tapa::ostream<T> & fifo_A,\n                       const R i_end_addr,\n                       R & i_req,\n                       R & i_resp) {\n#pragma HLS inline\n    if ((i_req < i_end_addr) &\n        !A.read_addr.full()) {\n        A.read_addr.try_write(i_req);\n        ++i_req;\n    }\n    if (!fifo_A.full() & !A.read_data.empty()) {\n        T tmp;\n        A.read_data.try_read(tmp);\n        fifo_A.try_write(tmp);\n        ++i_resp;\n    }\n}\ntemplate <typename T, typename R>\ninline void async_write(tapa::async_mmap<T> & Y_out,\n                        tapa::istream<T> & fifo_Y,\n                        const R num_ite_Y,\n                        R & i_req,\n                        R & i_resp\n                        ) {\n#pragma HLS inline\n    if ((i_req < num_ite_Y) &\n        !fifo_Y.empty() &\n        !Y_out.write_addr.full() &\n        !Y_out.write_data.full() ) {\n        Y_out.write_addr.try_write(i_req);\n        T tmpv;\n        fifo_Y.try_read(tmpv);\n        Y_out.write_data.try_write(tmpv);\n        ++i_req;\n    }\n    uint8_t n_resp;\n    if (Y_out.write_resp.try_read(n_resp)) {\n        i_resp += R(n_resp) + 1;\n    }\n}\nvoid rdwr_vec(uint64_t  vec_p,\n              tapa::istream<InstRdWr> & q_inst,\n              tapa::istream<double_v8> & q_din,\n              tapa::ostream<double_v8> & q_dout,\n              tapa::ostream<bool> & q_response\n              ) ;\ntemplate <typename data_t>\ninline void q2q(tapa::istream<data_t> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty() & !qout.full()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void clearq(tapa::istream<data_t> & qin,\n                   const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void q2q(tapa::istreams<data_t, 2> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite,\n                const int idx) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin[idx].empty() & !qout.full()) {\n            data_t tmp;\n            qin[idx].try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void qq2qq(tapa::istream<data_t> & qin_pe,\n                  tapa::ostreams<data_t, 2> & qout_mem,\n                  tapa::istreams<data_t, 2> & qin_mem,\n                  tapa::ostream<data_t> & qout_qe,\n                  const int num_ite,\n                  const int idx) {\n#pragma HLS inline\nqq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin_pe.empty() & !qout_mem[idx].full()) {\n            data_t tmp;\n            qin_pe.try_read(tmp);\n            qout_mem[idx].try_write(tmp);\n            ++i;\n        }\n        if (!qin_mem[1 - idx].empty() & !qout_qe.full()) {\n            data_t tmp;\n            qin_mem[1 - idx].try_read(tmp);\n            qout_qe.try_write(tmp);\n        }\n    }\n}\nvoid term_signal_router(tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_to_rdA,\n                        tapa::ostream<bool> & q_to_edgepointer,\n                        tapa::ostream<bool> & q_to_abiter,\n                        tapa::ostream<bool> & q_to_ctrlmem,\n                        tapa::ostream<bool> & q_to_mux\n                        ) ;\nvoid read_edge_list_ptr(const int num_ite,\n                        const int M,\n                        const int rp_time, //P_N,\n                        tapa::async_mmap<int> & edge_list_ptr,\n                        tapa::ostream<int> & PE_inst,\n                        tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_gbc_out\n                        ) {\n\n\n\n#pragma HLS disaggregate variable = edge_list_ptr\n#pragma HLS interface ap_fifo port = edge_list_ptr.read_addr._\n#pragma HLS aggregate variable = edge_list_ptr.read_addr._  bit\n#pragma HLS interface ap_fifo port = edge_list_ptr.read_data._\n#pragma HLS aggregate variable = edge_list_ptr.read_data._  bit\n#pragma HLS interface ap_fifo port = edge_list_ptr.write_addr._\n#pragma HLS aggregate variable = edge_list_ptr.write_addr._  bit\n#pragma HLS interface ap_fifo port = edge_list_ptr.write_data._\n#pragma HLS aggregate variable = edge_list_ptr.write_data._  bit\n#pragma HLS interface ap_fifo port = edge_list_ptr.write_resp._\n#pragma HLS aggregate variable = edge_list_ptr.write_resp._  bit\n#pragma HLS disaggregate variable = edge_list_ptr .read_data\n#pragma HLS interface ap_fifo port = edge_list_ptr.read_data._peek\n#pragma HLS aggregate variable = edge_list_ptr.read_data._peek bit\n#pragma HLS disaggregate variable = edge_list_ptr .write_resp\n#pragma HLS interface ap_fifo port = edge_list_ptr.write_resp._peek\n#pragma HLS aggregate variable = edge_list_ptr.write_resp._peek bit\nvoid(edge_list_ptr.read_addr._.full());\nvoid(edge_list_ptr.read_data._.empty());\nvoid(edge_list_ptr.read_data._peek.empty());\nvoid(edge_list_ptr.write_addr._.full());\nvoid(edge_list_ptr.write_data._.full());\nvoid(edge_list_ptr.write_resp._.empty());\nvoid(edge_list_ptr.write_resp._peek.empty());\n\n#pragma HLS disaggregate variable = PE_inst\n#pragma HLS interface ap_fifo port = PE_inst._\n#pragma HLS aggregate variable = PE_inst._ bit\nvoid(PE_inst._.full());\n\n#pragma HLS disaggregate variable = q_gbc\n#pragma HLS interface ap_fifo port = q_gbc._\n#pragma HLS aggregate variable = q_gbc._ bit\n#pragma HLS interface ap_fifo port = q_gbc._peek\n#pragma HLS aggregate variable = q_gbc._peek bit\nvoid(q_gbc._.empty());\nvoid(q_gbc._peek.empty());\n\n#pragma HLS disaggregate variable = q_gbc_out\n#pragma HLS interface ap_fifo port = q_gbc_out._\n#pragma HLS aggregate variable = q_gbc_out._ bit\nvoid(q_gbc_out._.full());\n\n    //const int rp_time = (P_N == 0)? 1 : P_N;\n    PE_inst.write(num_ite);\n    PE_inst.write(M);\n    PE_inst.write(rp_time);\n    //PE_inst.write(K);\n    const int num_ite_plus1 = num_ite + 1;\n    bool term_flag = false;\nl_rp:\n    for(int rp = -1; !term_flag & (rp < rp_time); rp++) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n    rd_ptr:\n        for (int i_req = 0, i_resp = 0; i_resp < num_ite_plus1;) {\n#pragma HLS loop_tripcount min=1 max=800\n#pragma HLS pipeline II=1\n            async_read(edge_list_ptr,\n                       PE_inst,\n                       num_ite_plus1,\n                       i_req, i_resp);\n        }\n        ap_wait();\n        term_flag = q_gbc.read();\n        q_gbc_out.write(term_flag);\n    }\n    //cout << \"### exit read_edge_list_ptr\" << endl;\n}\nvoid read_vec(const int rp_time, //P_N\n              const int M, //K,\n              tapa::async_mmap<double_v8> & vec_X,\n              tapa::ostream<double_v8> & fifo_X\n              ) {\n    //const int rp_time = (P_N == 0)? 1 : P_N;\n    const int num_ite_X = (M + 7) >> 3;\nl_rp:\n    for(int rp = 0; rp < rp_time; rp++) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n    rd_X:\n        for(int i_req = 0, i_resp = 0; i_resp < num_ite_X;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n            async_read(vec_X,\n                       fifo_X,\n                       num_ite_X,\n                       i_req, i_resp);\n        }\n    }\n}\nvoid read_A(const int rp_time, //P_N,\n            const int A_len,\n            uint64_t  A,\n            tapa::ostream<ap_uint<512>> & fifo_A,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid PEG_Xvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<ap_uint<512>> & fifo_A,\n              tapa::istream<double_v8> & fifo_X_in,\n              tapa::ostream<int> & fifo_inst_out,\n              tapa::ostream<double_v8> & fifo_X_out,\n              // to PEG_Yvec\n              tapa::ostream<int> & fifo_inst_out_to_Yvec,\n              tapa::ostream<MultXVec> & fifo_aXvec,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out,\n              tapa::ostream<bool> & q_gbc_out_Y\n              ) ;\nvoid PEG_Yvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<MultXVec> & fifo_aXvec,\n              tapa::ostream<double> & fifo_Y_out,\n              tapa::istream<bool> & q_gbc\n              ) ;\nvoid Arbiter_Y(const int rp_time, //P_N,\n               const int M,\n               tapa::istreams<double, NUM_CH_SPARSE_div_8> & fifo_in, // 2 = 16 / 8\n               tapa::ostream<double> & fifo_out,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\nvoid Merger_Y(tapa::istreams<double, 8> & fifo_in,\n              tapa::ostreams<double_v8, 2> & fifo_out) ;\ntemplate <typename data_t>\ninline void bh(tapa::istream<data_t> & q) {\n#pragma HLS inline\n    for (;;) {\n#pragma HLS pipeline II=1\n        data_t tmp; q.try_read(tmp);\n    }\n}\nvoid black_hole_int(tapa::istream<int> & fifo_in) ;\nvoid black_hole_double_v8(tapa::istream<double_v8> & fifo_in) ;\nvoid black_hole_bool(tapa::istream<bool> & fifo_in) ;\nvoid ctrl_P(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time, //P_N\n            const int M, //K,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_spmv,\n            tapa::ostream<double_v8> & q_dotp,\n            //tapa::ostream<double_v8> & q_updtx,\n            tapa::ostream<double_v8> & q_updtp,\n            tapa::istream<double_v8> & q_updated,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_AP(tapa::istream<double_v8> & qm_din,\n             tapa::ostream<double_v8> & qm_dout,\n             const int rp_time,\n             const int M,\n             tapa::ostream<InstRdWr> & q_inst,\n             tapa::ostream<double_v8> & q_updr,\n             tapa::istream<double_v8> & q_pe,\n             tapa::istream<bool> & q_res,\n             tapa::istream<bool> & q_gbc,\n             tapa::ostream<bool> & q_gbc_out\n             ) ;\nvoid ctrl_X(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_oldx,\n            tapa::istream<double_v8> & q_newx,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_R(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & qr_to_pe,\n            tapa::istream<double_v8> & qr_from_pe,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid read_digA(uint64_t  vec_mem,\n               const int rp_time, //P_N\n               const int M, //K,\n               tapa::ostream<double_v8> & q_dout,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n/*  computation modules  */\n//M2: alpha = rzold / (p' * Ap)\nvoid dot_alpha(const int rp_time,\n               const int M,\n               //const unsigned long rz0,\n               tapa::istream<double> & qrz,\n               tapa::istream<double_v8> & q1,\n               tapa::istream<double_v8> & q2,\n               tapa::ostreams<double, 2> & q3,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M end: res = r' * r\nvoid dot_res(const int rp_time,\n             const int M,\n             const double th_termination,\n             tapa::istream<double_v8> & q1,\n             tapa::ostream<ResTerm> & q2,\n             tapa::ostream<bool> & q_termination\n             ) ;\n//M6: rznew = r' * z\nvoid dot_rznew(const int rp_time,\n               const int M,\n               tapa::istream<double_v8> & qr,\n               tapa::istream<double_v8> & qz,\n               tapa::ostream<double_v8> & qr_out,\n               tapa::ostreams<double, 2> & qrz,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M3: x = x + alpha * p\nvoid updt_x(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qx,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M7: p = z + (rznew/rzold) * p\nvoid updt_p(const int rp_time,\n            const int M,\n            //const unsigned long rz0,\n            tapa::istream<double> & qrznew,\n            tapa::istream<double_v8> & qz,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qp2m3,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M4: r = r - alpha * Ap\nvoid updt_r(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qr,\n            tapa::istream<double_v8> & qap,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M5: z = diagA \\ r\nvoid left_div(const int rp_time,\n              const int M,\n              tapa::istream<double_v8> & qr,\n              tapa::istream<double_v8> & qdiagA,\n              tapa::ostreams<double_v8, 2> & qz,\n              tapa::ostream<double_v8> & qr_m6,\n              tapa::ostream<double_v8> & qrmem,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out\n              ) ;\nvoid wr_r(const int rp_time,\n          uint64_t  vec_r,\n          tapa::istream<ResTerm> & q_din\n          ) ;\nvoid duplicator(tapa::istream<double_v8> & q_in,\n                tapa::ostream<double_v8> & q_out1,\n                tapa::ostream<double_v8> & q_out2\n                ) ;\nvoid vecp_mux(const int rp_time,\n              const int M,\n              tapa::istream<bool> & q_gbc,\n              tapa::istream<double_v8> & q_in1,\n              tapa::istream<double_v8> & q_in2,\n              tapa::ostream<double_v8> & q_out\n              ) ;\nvoid Callipepla(uint64_t  edge_list_ptr,\n                uint64_t edge_list_ch_0, uint64_t edge_list_ch_1, uint64_t edge_list_ch_2, uint64_t edge_list_ch_3, uint64_t edge_list_ch_4, uint64_t edge_list_ch_5, uint64_t edge_list_ch_6, uint64_t edge_list_ch_7, uint64_t edge_list_ch_8, uint64_t edge_list_ch_9, uint64_t edge_list_ch_10, uint64_t edge_list_ch_11, uint64_t edge_list_ch_12, uint64_t edge_list_ch_13, uint64_t edge_list_ch_14, uint64_t edge_list_ch_15,\n                uint64_t vec_x_0, uint64_t vec_x_1,\n                uint64_t vec_p_0, uint64_t vec_p_1,\n                uint64_t  vec_Ap,\n                uint64_t vec_r_0, uint64_t vec_r_1,\n                uint64_t  vec_digA,\n                uint64_t  vec_res,\n                const int NUM_ITE,\n                const int NUM_A_LEN,\n                const int M,\n                const int rp_time,\n                const double th_termination\n                ) ;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "term_signal_router": {
            "code": "\n\n #include <ap_int.h>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cassert>\n\n\n #include \"ap_utils.h\"\n\n#include <tapa.h>\n\n\n\n #include <ap_int.h>\n\n#include <tapa.h>\nconstexpr int NUM_CH_SPARSE = 16;\nconstexpr int X_PARTITION_FACTOR = 4; // BRAMs = 512 / 16 / 2 = 16 -> factor = 16 / (64 / 16)\nconstexpr int WINDOW_SIZE = X_PARTITION_FACTOR * 1024;\nconstexpr int DEP_DIST_LOAD_STORE = 7;\nconstexpr int URAM_DEPTH = 3 * 4096;\n// ch16: 3 * 4096 * 16 * 8 = 1,572,864\nusing double_v8 = tapa::vec_t<double, 8>;\nvoid Callipepla(tapa::mmap<int> edge_list_ptr,\n                tapa::mmaps<ap_uint<512>, NUM_CH_SPARSE> edge_list_ch,\n                tapa::mmaps<double_v8, 2> vec_x,\n                tapa::mmaps<double_v8, 2> vec_p,\n                tapa::mmap<double_v8> vec_Ap,\n                tapa::mmaps<double_v8, 2> vec_r,\n                tapa::mmap<double_v8> vec_digA,\n                tapa::mmap<double> vec_res,\n                const int NUM_ITE, const int NUM_A_LEN, const int M,\n                const int rp_time,\n                const double th_termination\n                );\n\nconstexpr int FIFO_DEPTH = 2;\nconstexpr int FIFO_DEPTH_M6 = 50;\nconst int NUM_CH_SPARSE_div_8 = NUM_CH_SPARSE / 8;\nconst int NUM_CH_SPARSE_mult_8 = NUM_CH_SPARSE * 8;\nconst int WINDOW_SIZE_div_8 = WINDOW_SIZE / 8;\nstruct MultXVec {\n    tapa::vec_t<ap_uint<18>, 8> row;\n    double_v8 axv;\n};\nstruct InstRdWr {\n    bool rd;\n    bool wr;\n    //bool require_response;\n    int base_addr;\n    int len;\n};\nstruct InstVCtrl {\n    bool rd;\n    bool wr;\n    int base_addr;\n    int len;\n    ap_uint<3> q_rd_idx;\n    //ap_uint<3> q_wr_idx;\n};\nstruct InstCmp {\n    int len;\n    double alpha;\n    ap_uint<3> q_idx;\n};\nstruct ResTerm {\n    double res;\n    bool term;\n};\ntemplate <typename T, typename R>\ninline void async_read(tapa::async_mmap<T> & A,\n                       tapa::ostream<T> & fifo_A,\n                       const R i_end_addr,\n                       R & i_req,\n                       R & i_resp) {\n#pragma HLS inline\n    if ((i_req < i_end_addr) &\n        !A.read_addr.full()) {\n        A.read_addr.try_write(i_req);\n        ++i_req;\n    }\n    if (!fifo_A.full() & !A.read_data.empty()) {\n        T tmp;\n        A.read_data.try_read(tmp);\n        fifo_A.try_write(tmp);\n        ++i_resp;\n    }\n}\ntemplate <typename T, typename R>\ninline void async_write(tapa::async_mmap<T> & Y_out,\n                        tapa::istream<T> & fifo_Y,\n                        const R num_ite_Y,\n                        R & i_req,\n                        R & i_resp\n                        ) {\n#pragma HLS inline\n    if ((i_req < num_ite_Y) &\n        !fifo_Y.empty() &\n        !Y_out.write_addr.full() &\n        !Y_out.write_data.full() ) {\n        Y_out.write_addr.try_write(i_req);\n        T tmpv;\n        fifo_Y.try_read(tmpv);\n        Y_out.write_data.try_write(tmpv);\n        ++i_req;\n    }\n    uint8_t n_resp;\n    if (Y_out.write_resp.try_read(n_resp)) {\n        i_resp += R(n_resp) + 1;\n    }\n}\nvoid rdwr_vec(uint64_t  vec_p,\n              tapa::istream<InstRdWr> & q_inst,\n              tapa::istream<double_v8> & q_din,\n              tapa::ostream<double_v8> & q_dout,\n              tapa::ostream<bool> & q_response\n              ) ;\ntemplate <typename data_t>\ninline void q2q(tapa::istream<data_t> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty() & !qout.full()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void clearq(tapa::istream<data_t> & qin,\n                   const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void q2q(tapa::istreams<data_t, 2> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite,\n                const int idx) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin[idx].empty() & !qout.full()) {\n            data_t tmp;\n            qin[idx].try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void qq2qq(tapa::istream<data_t> & qin_pe,\n                  tapa::ostreams<data_t, 2> & qout_mem,\n                  tapa::istreams<data_t, 2> & qin_mem,\n                  tapa::ostream<data_t> & qout_qe,\n                  const int num_ite,\n                  const int idx) {\n#pragma HLS inline\nqq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin_pe.empty() & !qout_mem[idx].full()) {\n            data_t tmp;\n            qin_pe.try_read(tmp);\n            qout_mem[idx].try_write(tmp);\n            ++i;\n        }\n        if (!qin_mem[1 - idx].empty() & !qout_qe.full()) {\n            data_t tmp;\n            qin_mem[1 - idx].try_read(tmp);\n            qout_qe.try_write(tmp);\n        }\n    }\n}\nvoid term_signal_router(tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_to_rdA,\n                        tapa::ostream<bool> & q_to_edgepointer,\n                        tapa::ostream<bool> & q_to_abiter,\n                        tapa::ostream<bool> & q_to_ctrlmem,\n                        tapa::ostream<bool> & q_to_mux\n                        ) {\n#pragma HLS disaggregate variable = q_gbc\n#pragma HLS interface ap_fifo port = q_gbc._\n#pragma HLS aggregate variable = q_gbc._ bit\n#pragma HLS interface ap_fifo port = q_gbc._peek\n#pragma HLS aggregate variable = q_gbc._peek bit\nvoid(q_gbc._.empty());\nvoid(q_gbc._peek.empty());\n\n#pragma HLS disaggregate variable = q_to_rdA\n#pragma HLS interface ap_fifo port = q_to_rdA._\n#pragma HLS aggregate variable = q_to_rdA._ bit\nvoid(q_to_rdA._.full());\n\n#pragma HLS disaggregate variable = q_to_edgepointer\n#pragma HLS interface ap_fifo port = q_to_edgepointer._\n#pragma HLS aggregate variable = q_to_edgepointer._ bit\nvoid(q_to_edgepointer._.full());\n\n#pragma HLS disaggregate variable = q_to_abiter\n#pragma HLS interface ap_fifo port = q_to_abiter._\n#pragma HLS aggregate variable = q_to_abiter._ bit\nvoid(q_to_abiter._.full());\n\n#pragma HLS disaggregate variable = q_to_ctrlmem\n#pragma HLS interface ap_fifo port = q_to_ctrlmem._\n#pragma HLS aggregate variable = q_to_ctrlmem._ bit\nvoid(q_to_ctrlmem._.full());\n\n#pragma HLS disaggregate variable = q_to_mux\n#pragma HLS interface ap_fifo port = q_to_mux._\n#pragma HLS aggregate variable = q_to_mux._ bit\nvoid(q_to_mux._.full());\n\nspin:\n    for (;;) {\n#pragma HLS pipeline II=1\n        if (!q_gbc.empty() &\n            !q_to_rdA.full() &\n            !q_to_edgepointer.full() &\n            !q_to_abiter.full() &\n            !q_to_ctrlmem.full() &\n            !q_to_mux.full()\n            ) {\n            bool tmp;\n            q_gbc.try_read(tmp);\n            q_to_rdA.try_write(tmp);\n            q_to_edgepointer.try_write(tmp);\n            q_to_abiter.try_write(tmp);\n            q_to_ctrlmem.try_write(tmp);\n            q_to_mux.try_write(tmp);\n        }\n    }\n}\nvoid read_edge_list_ptr(const int num_ite,\n                        const int M,\n                        const int rp_time, //P_N,\n                        uint64_t  edge_list_ptr,\n                        tapa::ostream<int> & PE_inst,\n                        tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_gbc_out\n                        ) ;\nvoid read_vec(const int rp_time, //P_N\n              const int M, //K,\n              tapa::async_mmap<double_v8> & vec_X,\n              tapa::ostream<double_v8> & fifo_X\n              ) {\n    //const int rp_time = (P_N == 0)? 1 : P_N;\n    const int num_ite_X = (M + 7) >> 3;\nl_rp:\n    for(int rp = 0; rp < rp_time; rp++) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n    rd_X:\n        for(int i_req = 0, i_resp = 0; i_resp < num_ite_X;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n            async_read(vec_X,\n                       fifo_X,\n                       num_ite_X,\n                       i_req, i_resp);\n        }\n    }\n}\nvoid read_A(const int rp_time, //P_N,\n            const int A_len,\n            uint64_t  A,\n            tapa::ostream<ap_uint<512>> & fifo_A,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid PEG_Xvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<ap_uint<512>> & fifo_A,\n              tapa::istream<double_v8> & fifo_X_in,\n              tapa::ostream<int> & fifo_inst_out,\n              tapa::ostream<double_v8> & fifo_X_out,\n              // to PEG_Yvec\n              tapa::ostream<int> & fifo_inst_out_to_Yvec,\n              tapa::ostream<MultXVec> & fifo_aXvec,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out,\n              tapa::ostream<bool> & q_gbc_out_Y\n              ) ;\nvoid PEG_Yvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<MultXVec> & fifo_aXvec,\n              tapa::ostream<double> & fifo_Y_out,\n              tapa::istream<bool> & q_gbc\n              ) ;\nvoid Arbiter_Y(const int rp_time, //P_N,\n               const int M,\n               tapa::istreams<double, NUM_CH_SPARSE_div_8> & fifo_in, // 2 = 16 / 8\n               tapa::ostream<double> & fifo_out,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\nvoid Merger_Y(tapa::istreams<double, 8> & fifo_in,\n              tapa::ostreams<double_v8, 2> & fifo_out) ;\ntemplate <typename data_t>\ninline void bh(tapa::istream<data_t> & q) {\n#pragma HLS inline\n    for (;;) {\n#pragma HLS pipeline II=1\n        data_t tmp; q.try_read(tmp);\n    }\n}\nvoid black_hole_int(tapa::istream<int> & fifo_in) ;\nvoid black_hole_double_v8(tapa::istream<double_v8> & fifo_in) ;\nvoid black_hole_bool(tapa::istream<bool> & fifo_in) ;\nvoid ctrl_P(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time, //P_N\n            const int M, //K,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_spmv,\n            tapa::ostream<double_v8> & q_dotp,\n            //tapa::ostream<double_v8> & q_updtx,\n            tapa::ostream<double_v8> & q_updtp,\n            tapa::istream<double_v8> & q_updated,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_AP(tapa::istream<double_v8> & qm_din,\n             tapa::ostream<double_v8> & qm_dout,\n             const int rp_time,\n             const int M,\n             tapa::ostream<InstRdWr> & q_inst,\n             tapa::ostream<double_v8> & q_updr,\n             tapa::istream<double_v8> & q_pe,\n             tapa::istream<bool> & q_res,\n             tapa::istream<bool> & q_gbc,\n             tapa::ostream<bool> & q_gbc_out\n             ) ;\nvoid ctrl_X(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_oldx,\n            tapa::istream<double_v8> & q_newx,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_R(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & qr_to_pe,\n            tapa::istream<double_v8> & qr_from_pe,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid read_digA(uint64_t  vec_mem,\n               const int rp_time, //P_N\n               const int M, //K,\n               tapa::ostream<double_v8> & q_dout,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n/*  computation modules  */\n//M2: alpha = rzold / (p' * Ap)\nvoid dot_alpha(const int rp_time,\n               const int M,\n               //const unsigned long rz0,\n               tapa::istream<double> & qrz,\n               tapa::istream<double_v8> & q1,\n               tapa::istream<double_v8> & q2,\n               tapa::ostreams<double, 2> & q3,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M end: res = r' * r\nvoid dot_res(const int rp_time,\n             const int M,\n             const double th_termination,\n             tapa::istream<double_v8> & q1,\n             tapa::ostream<ResTerm> & q2,\n             tapa::ostream<bool> & q_termination\n             ) ;\n//M6: rznew = r' * z\nvoid dot_rznew(const int rp_time,\n               const int M,\n               tapa::istream<double_v8> & qr,\n               tapa::istream<double_v8> & qz,\n               tapa::ostream<double_v8> & qr_out,\n               tapa::ostreams<double, 2> & qrz,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M3: x = x + alpha * p\nvoid updt_x(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qx,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M7: p = z + (rznew/rzold) * p\nvoid updt_p(const int rp_time,\n            const int M,\n            //const unsigned long rz0,\n            tapa::istream<double> & qrznew,\n            tapa::istream<double_v8> & qz,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qp2m3,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M4: r = r - alpha * Ap\nvoid updt_r(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qr,\n            tapa::istream<double_v8> & qap,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M5: z = diagA \\ r\nvoid left_div(const int rp_time,\n              const int M,\n              tapa::istream<double_v8> & qr,\n              tapa::istream<double_v8> & qdiagA,\n              tapa::ostreams<double_v8, 2> & qz,\n              tapa::ostream<double_v8> & qr_m6,\n              tapa::ostream<double_v8> & qrmem,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out\n              ) ;\nvoid wr_r(const int rp_time,\n          uint64_t  vec_r,\n          tapa::istream<ResTerm> & q_din\n          ) ;\nvoid duplicator(tapa::istream<double_v8> & q_in,\n                tapa::ostream<double_v8> & q_out1,\n                tapa::ostream<double_v8> & q_out2\n                ) ;\nvoid vecp_mux(const int rp_time,\n              const int M,\n              tapa::istream<bool> & q_gbc,\n              tapa::istream<double_v8> & q_in1,\n              tapa::istream<double_v8> & q_in2,\n              tapa::ostream<double_v8> & q_out\n              ) ;\nvoid Callipepla(uint64_t  edge_list_ptr,\n                uint64_t edge_list_ch_0, uint64_t edge_list_ch_1, uint64_t edge_list_ch_2, uint64_t edge_list_ch_3, uint64_t edge_list_ch_4, uint64_t edge_list_ch_5, uint64_t edge_list_ch_6, uint64_t edge_list_ch_7, uint64_t edge_list_ch_8, uint64_t edge_list_ch_9, uint64_t edge_list_ch_10, uint64_t edge_list_ch_11, uint64_t edge_list_ch_12, uint64_t edge_list_ch_13, uint64_t edge_list_ch_14, uint64_t edge_list_ch_15,\n                uint64_t vec_x_0, uint64_t vec_x_1,\n                uint64_t vec_p_0, uint64_t vec_p_1,\n                uint64_t  vec_Ap,\n                uint64_t vec_r_0, uint64_t vec_r_1,\n                uint64_t  vec_digA,\n                uint64_t  vec_res,\n                const int NUM_ITE,\n                const int NUM_A_LEN,\n                const int M,\n                const int rp_time,\n                const double th_termination\n                ) ;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "updt_p": {
            "code": "\n\n #include <ap_int.h>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cassert>\n\n\n #include \"ap_utils.h\"\n\n#include <tapa.h>\n\n\n\n #include <ap_int.h>\n\n#include <tapa.h>\nconstexpr int NUM_CH_SPARSE = 16;\nconstexpr int X_PARTITION_FACTOR = 4; // BRAMs = 512 / 16 / 2 = 16 -> factor = 16 / (64 / 16)\nconstexpr int WINDOW_SIZE = X_PARTITION_FACTOR * 1024;\nconstexpr int DEP_DIST_LOAD_STORE = 7;\nconstexpr int URAM_DEPTH = 3 * 4096;\n// ch16: 3 * 4096 * 16 * 8 = 1,572,864\nusing double_v8 = tapa::vec_t<double, 8>;\nvoid Callipepla(tapa::mmap<int> edge_list_ptr,\n                tapa::mmaps<ap_uint<512>, NUM_CH_SPARSE> edge_list_ch,\n                tapa::mmaps<double_v8, 2> vec_x,\n                tapa::mmaps<double_v8, 2> vec_p,\n                tapa::mmap<double_v8> vec_Ap,\n                tapa::mmaps<double_v8, 2> vec_r,\n                tapa::mmap<double_v8> vec_digA,\n                tapa::mmap<double> vec_res,\n                const int NUM_ITE, const int NUM_A_LEN, const int M,\n                const int rp_time,\n                const double th_termination\n                );\n\nconstexpr int FIFO_DEPTH = 2;\nconstexpr int FIFO_DEPTH_M6 = 50;\nconst int NUM_CH_SPARSE_div_8 = NUM_CH_SPARSE / 8;\nconst int NUM_CH_SPARSE_mult_8 = NUM_CH_SPARSE * 8;\nconst int WINDOW_SIZE_div_8 = WINDOW_SIZE / 8;\nstruct MultXVec {\n    tapa::vec_t<ap_uint<18>, 8> row;\n    double_v8 axv;\n};\nstruct InstRdWr {\n    bool rd;\n    bool wr;\n    //bool require_response;\n    int base_addr;\n    int len;\n};\nstruct InstVCtrl {\n    bool rd;\n    bool wr;\n    int base_addr;\n    int len;\n    ap_uint<3> q_rd_idx;\n    //ap_uint<3> q_wr_idx;\n};\nstruct InstCmp {\n    int len;\n    double alpha;\n    ap_uint<3> q_idx;\n};\nstruct ResTerm {\n    double res;\n    bool term;\n};\ntemplate <typename T, typename R>\ninline void async_read(tapa::async_mmap<T> & A,\n                       tapa::ostream<T> & fifo_A,\n                       const R i_end_addr,\n                       R & i_req,\n                       R & i_resp) {\n#pragma HLS inline\n    if ((i_req < i_end_addr) &\n        !A.read_addr.full()) {\n        A.read_addr.try_write(i_req);\n        ++i_req;\n    }\n    if (!fifo_A.full() & !A.read_data.empty()) {\n        T tmp;\n        A.read_data.try_read(tmp);\n        fifo_A.try_write(tmp);\n        ++i_resp;\n    }\n}\ntemplate <typename T, typename R>\ninline void async_write(tapa::async_mmap<T> & Y_out,\n                        tapa::istream<T> & fifo_Y,\n                        const R num_ite_Y,\n                        R & i_req,\n                        R & i_resp\n                        ) {\n#pragma HLS inline\n    if ((i_req < num_ite_Y) &\n        !fifo_Y.empty() &\n        !Y_out.write_addr.full() &\n        !Y_out.write_data.full() ) {\n        Y_out.write_addr.try_write(i_req);\n        T tmpv;\n        fifo_Y.try_read(tmpv);\n        Y_out.write_data.try_write(tmpv);\n        ++i_req;\n    }\n    uint8_t n_resp;\n    if (Y_out.write_resp.try_read(n_resp)) {\n        i_resp += R(n_resp) + 1;\n    }\n}\nvoid rdwr_vec(uint64_t  vec_p,\n              tapa::istream<InstRdWr> & q_inst,\n              tapa::istream<double_v8> & q_din,\n              tapa::ostream<double_v8> & q_dout,\n              tapa::ostream<bool> & q_response\n              ) ;\ntemplate <typename data_t>\ninline void q2q(tapa::istream<data_t> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty() & !qout.full()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void clearq(tapa::istream<data_t> & qin,\n                   const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void q2q(tapa::istreams<data_t, 2> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite,\n                const int idx) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin[idx].empty() & !qout.full()) {\n            data_t tmp;\n            qin[idx].try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void qq2qq(tapa::istream<data_t> & qin_pe,\n                  tapa::ostreams<data_t, 2> & qout_mem,\n                  tapa::istreams<data_t, 2> & qin_mem,\n                  tapa::ostream<data_t> & qout_qe,\n                  const int num_ite,\n                  const int idx) {\n#pragma HLS inline\nqq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin_pe.empty() & !qout_mem[idx].full()) {\n            data_t tmp;\n            qin_pe.try_read(tmp);\n            qout_mem[idx].try_write(tmp);\n            ++i;\n        }\n        if (!qin_mem[1 - idx].empty() & !qout_qe.full()) {\n            data_t tmp;\n            qin_mem[1 - idx].try_read(tmp);\n            qout_qe.try_write(tmp);\n        }\n    }\n}\nvoid term_signal_router(tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_to_rdA,\n                        tapa::ostream<bool> & q_to_edgepointer,\n                        tapa::ostream<bool> & q_to_abiter,\n                        tapa::ostream<bool> & q_to_ctrlmem,\n                        tapa::ostream<bool> & q_to_mux\n                        ) ;\nvoid read_edge_list_ptr(const int num_ite,\n                        const int M,\n                        const int rp_time, //P_N,\n                        uint64_t  edge_list_ptr,\n                        tapa::ostream<int> & PE_inst,\n                        tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_gbc_out\n                        ) ;\nvoid read_vec(const int rp_time, //P_N\n              const int M, //K,\n              tapa::async_mmap<double_v8> & vec_X,\n              tapa::ostream<double_v8> & fifo_X\n              ) {\n    //const int rp_time = (P_N == 0)? 1 : P_N;\n    const int num_ite_X = (M + 7) >> 3;\nl_rp:\n    for(int rp = 0; rp < rp_time; rp++) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n    rd_X:\n        for(int i_req = 0, i_resp = 0; i_resp < num_ite_X;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n            async_read(vec_X,\n                       fifo_X,\n                       num_ite_X,\n                       i_req, i_resp);\n        }\n    }\n}\nvoid read_A(const int rp_time, //P_N,\n            const int A_len,\n            uint64_t  A,\n            tapa::ostream<ap_uint<512>> & fifo_A,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid PEG_Xvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<ap_uint<512>> & fifo_A,\n              tapa::istream<double_v8> & fifo_X_in,\n              tapa::ostream<int> & fifo_inst_out,\n              tapa::ostream<double_v8> & fifo_X_out,\n              // to PEG_Yvec\n              tapa::ostream<int> & fifo_inst_out_to_Yvec,\n              tapa::ostream<MultXVec> & fifo_aXvec,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out,\n              tapa::ostream<bool> & q_gbc_out_Y\n              ) ;\nvoid PEG_Yvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<MultXVec> & fifo_aXvec,\n              tapa::ostream<double> & fifo_Y_out,\n              tapa::istream<bool> & q_gbc\n              ) ;\nvoid Arbiter_Y(const int rp_time, //P_N,\n               const int M,\n               tapa::istreams<double, NUM_CH_SPARSE_div_8> & fifo_in, // 2 = 16 / 8\n               tapa::ostream<double> & fifo_out,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\nvoid Merger_Y(tapa::istreams<double, 8> & fifo_in,\n              tapa::ostreams<double_v8, 2> & fifo_out) ;\ntemplate <typename data_t>\ninline void bh(tapa::istream<data_t> & q) {\n#pragma HLS inline\n    for (;;) {\n#pragma HLS pipeline II=1\n        data_t tmp; q.try_read(tmp);\n    }\n}\nvoid black_hole_int(tapa::istream<int> & fifo_in) ;\nvoid black_hole_double_v8(tapa::istream<double_v8> & fifo_in) ;\nvoid black_hole_bool(tapa::istream<bool> & fifo_in) ;\nvoid ctrl_P(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time, //P_N\n            const int M, //K,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_spmv,\n            tapa::ostream<double_v8> & q_dotp,\n            //tapa::ostream<double_v8> & q_updtx,\n            tapa::ostream<double_v8> & q_updtp,\n            tapa::istream<double_v8> & q_updated,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_AP(tapa::istream<double_v8> & qm_din,\n             tapa::ostream<double_v8> & qm_dout,\n             const int rp_time,\n             const int M,\n             tapa::ostream<InstRdWr> & q_inst,\n             tapa::ostream<double_v8> & q_updr,\n             tapa::istream<double_v8> & q_pe,\n             tapa::istream<bool> & q_res,\n             tapa::istream<bool> & q_gbc,\n             tapa::ostream<bool> & q_gbc_out\n             ) ;\nvoid ctrl_X(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_oldx,\n            tapa::istream<double_v8> & q_newx,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_R(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & qr_to_pe,\n            tapa::istream<double_v8> & qr_from_pe,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid read_digA(uint64_t  vec_mem,\n               const int rp_time, //P_N\n               const int M, //K,\n               tapa::ostream<double_v8> & q_dout,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n/*  computation modules  */\n//M2: alpha = rzold / (p' * Ap)\nvoid dot_alpha(const int rp_time,\n               const int M,\n               //const unsigned long rz0,\n               tapa::istream<double> & qrz,\n               tapa::istream<double_v8> & q1,\n               tapa::istream<double_v8> & q2,\n               tapa::ostreams<double, 2> & q3,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M end: res = r' * r\nvoid dot_res(const int rp_time,\n             const int M,\n             const double th_termination,\n             tapa::istream<double_v8> & q1,\n             tapa::ostream<ResTerm> & q2,\n             tapa::ostream<bool> & q_termination\n             ) ;\n//M6: rznew = r' * z\nvoid dot_rznew(const int rp_time,\n               const int M,\n               tapa::istream<double_v8> & qr,\n               tapa::istream<double_v8> & qz,\n               tapa::ostream<double_v8> & qr_out,\n               tapa::ostreams<double, 2> & qrz,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M3: x = x + alpha * p\nvoid updt_x(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qx,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M7: p = z + (rznew/rzold) * p\nvoid updt_p(const int rp_time,\n            const int M,\n            //const unsigned long rz0,\n            tapa::istream<double> & qrznew,\n            tapa::istream<double_v8> & qz,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qp2m3,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) {\n\n\n#pragma HLS disaggregate variable = qrznew\n#pragma HLS interface ap_fifo port = qrznew._\n#pragma HLS aggregate variable = qrznew._ bit\n#pragma HLS interface ap_fifo port = qrznew._peek\n#pragma HLS aggregate variable = qrznew._peek bit\nvoid(qrznew._.empty());\nvoid(qrznew._peek.empty());\n\n#pragma HLS disaggregate variable = qz\n#pragma HLS interface ap_fifo port = qz._\n#pragma HLS aggregate variable = qz._ bit\n#pragma HLS interface ap_fifo port = qz._peek\n#pragma HLS aggregate variable = qz._peek bit\nvoid(qz._.empty());\nvoid(qz._peek.empty());\n\n#pragma HLS disaggregate variable = qp\n#pragma HLS interface ap_fifo port = qp._\n#pragma HLS aggregate variable = qp._ bit\n#pragma HLS interface ap_fifo port = qp._peek\n#pragma HLS aggregate variable = qp._peek bit\nvoid(qp._.empty());\nvoid(qp._peek.empty());\n\n#pragma HLS disaggregate variable = qp2m3\n#pragma HLS interface ap_fifo port = qp2m3._\n#pragma HLS aggregate variable = qp2m3._ bit\nvoid(qp2m3._.full());\n\n#pragma HLS disaggregate variable = qout\n#pragma HLS interface ap_fifo port = qout._\n#pragma HLS aggregate variable = qout._ bit\nvoid(qout._.full());\n\n#pragma HLS disaggregate variable = q_gbc\n#pragma HLS interface ap_fifo port = q_gbc._\n#pragma HLS aggregate variable = q_gbc._ bit\n#pragma HLS interface ap_fifo port = q_gbc._peek\n#pragma HLS aggregate variable = q_gbc._peek bit\nvoid(q_gbc._.empty());\nvoid(q_gbc._peek.empty());\n\n#pragma HLS disaggregate variable = q_gbc_out\n#pragma HLS interface ap_fifo port = q_gbc_out._\n#pragma HLS aggregate variable = q_gbc_out._ bit\nvoid(q_gbc_out._.full());\n\n    //InstCmp inst = {(M + 7) >> 3, rznew/rzold, 0};\n    const int num_ite = (M + 7) >> 3;\n    double rzold = 1.0;//tapa::bit_cast<double>(rz0);\n    bool term_flag = false;\nl_rp:\n    for(int rp = -1; !term_flag & (rp < rp_time); rp++) {\n#pragma HLS loop_flatten off\n        const double rznew = qrznew.read();\n        double rzndo = rznew / rzold;\n        if (rp < 0) {\n            rzndo = 0.0;\n        }\n    cc:\n        for (int i = 0; i < num_ite;) {\n#pragma HLS pipeline II=1\n            if (!qz.empty() & !qp.empty() & !qp2m3.full()) {\n                double_v8 tmpz; qz.try_read(tmpz);\n                double_v8 tmpp; qp.try_read(tmpp);\n                qp2m3.try_write(tmpp);\n                qout.write(tmpz + rzndo * tmpp);\n                ++i;\n            }\n        }\n        rzold = rznew;\n        ap_wait();\n        term_flag = q_gbc.read();\n        q_gbc_out.write(term_flag);\n    }\n    //cout << \"@@@@ exit updt_p\\n\";\n}\n//M4: r = r - alpha * Ap\nvoid updt_r(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qr,\n            tapa::istream<double_v8> & qap,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M5: z = diagA \\ r\nvoid left_div(const int rp_time,\n              const int M,\n              tapa::istream<double_v8> & qr,\n              tapa::istream<double_v8> & qdiagA,\n              tapa::ostreams<double_v8, 2> & qz,\n              tapa::ostream<double_v8> & qr_m6,\n              tapa::ostream<double_v8> & qrmem,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out\n              ) ;\nvoid wr_r(const int rp_time,\n          uint64_t  vec_r,\n          tapa::istream<ResTerm> & q_din\n          ) ;\nvoid duplicator(tapa::istream<double_v8> & q_in,\n                tapa::ostream<double_v8> & q_out1,\n                tapa::ostream<double_v8> & q_out2\n                ) ;\nvoid vecp_mux(const int rp_time,\n              const int M,\n              tapa::istream<bool> & q_gbc,\n              tapa::istream<double_v8> & q_in1,\n              tapa::istream<double_v8> & q_in2,\n              tapa::ostream<double_v8> & q_out\n              ) ;\nvoid Callipepla(uint64_t  edge_list_ptr,\n                uint64_t edge_list_ch_0, uint64_t edge_list_ch_1, uint64_t edge_list_ch_2, uint64_t edge_list_ch_3, uint64_t edge_list_ch_4, uint64_t edge_list_ch_5, uint64_t edge_list_ch_6, uint64_t edge_list_ch_7, uint64_t edge_list_ch_8, uint64_t edge_list_ch_9, uint64_t edge_list_ch_10, uint64_t edge_list_ch_11, uint64_t edge_list_ch_12, uint64_t edge_list_ch_13, uint64_t edge_list_ch_14, uint64_t edge_list_ch_15,\n                uint64_t vec_x_0, uint64_t vec_x_1,\n                uint64_t vec_p_0, uint64_t vec_p_1,\n                uint64_t  vec_Ap,\n                uint64_t vec_r_0, uint64_t vec_r_1,\n                uint64_t  vec_digA,\n                uint64_t  vec_res,\n                const int NUM_ITE,\n                const int NUM_A_LEN,\n                const int M,\n                const int rp_time,\n                const double th_termination\n                ) ;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "updt_r": {
            "code": "\n\n #include <ap_int.h>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cassert>\n\n\n #include \"ap_utils.h\"\n\n#include <tapa.h>\n\n\n\n #include <ap_int.h>\n\n#include <tapa.h>\nconstexpr int NUM_CH_SPARSE = 16;\nconstexpr int X_PARTITION_FACTOR = 4; // BRAMs = 512 / 16 / 2 = 16 -> factor = 16 / (64 / 16)\nconstexpr int WINDOW_SIZE = X_PARTITION_FACTOR * 1024;\nconstexpr int DEP_DIST_LOAD_STORE = 7;\nconstexpr int URAM_DEPTH = 3 * 4096;\n// ch16: 3 * 4096 * 16 * 8 = 1,572,864\nusing double_v8 = tapa::vec_t<double, 8>;\nvoid Callipepla(tapa::mmap<int> edge_list_ptr,\n                tapa::mmaps<ap_uint<512>, NUM_CH_SPARSE> edge_list_ch,\n                tapa::mmaps<double_v8, 2> vec_x,\n                tapa::mmaps<double_v8, 2> vec_p,\n                tapa::mmap<double_v8> vec_Ap,\n                tapa::mmaps<double_v8, 2> vec_r,\n                tapa::mmap<double_v8> vec_digA,\n                tapa::mmap<double> vec_res,\n                const int NUM_ITE, const int NUM_A_LEN, const int M,\n                const int rp_time,\n                const double th_termination\n                );\n\nconstexpr int FIFO_DEPTH = 2;\nconstexpr int FIFO_DEPTH_M6 = 50;\nconst int NUM_CH_SPARSE_div_8 = NUM_CH_SPARSE / 8;\nconst int NUM_CH_SPARSE_mult_8 = NUM_CH_SPARSE * 8;\nconst int WINDOW_SIZE_div_8 = WINDOW_SIZE / 8;\nstruct MultXVec {\n    tapa::vec_t<ap_uint<18>, 8> row;\n    double_v8 axv;\n};\nstruct InstRdWr {\n    bool rd;\n    bool wr;\n    //bool require_response;\n    int base_addr;\n    int len;\n};\nstruct InstVCtrl {\n    bool rd;\n    bool wr;\n    int base_addr;\n    int len;\n    ap_uint<3> q_rd_idx;\n    //ap_uint<3> q_wr_idx;\n};\nstruct InstCmp {\n    int len;\n    double alpha;\n    ap_uint<3> q_idx;\n};\nstruct ResTerm {\n    double res;\n    bool term;\n};\ntemplate <typename T, typename R>\ninline void async_read(tapa::async_mmap<T> & A,\n                       tapa::ostream<T> & fifo_A,\n                       const R i_end_addr,\n                       R & i_req,\n                       R & i_resp) {\n#pragma HLS inline\n    if ((i_req < i_end_addr) &\n        !A.read_addr.full()) {\n        A.read_addr.try_write(i_req);\n        ++i_req;\n    }\n    if (!fifo_A.full() & !A.read_data.empty()) {\n        T tmp;\n        A.read_data.try_read(tmp);\n        fifo_A.try_write(tmp);\n        ++i_resp;\n    }\n}\ntemplate <typename T, typename R>\ninline void async_write(tapa::async_mmap<T> & Y_out,\n                        tapa::istream<T> & fifo_Y,\n                        const R num_ite_Y,\n                        R & i_req,\n                        R & i_resp\n                        ) {\n#pragma HLS inline\n    if ((i_req < num_ite_Y) &\n        !fifo_Y.empty() &\n        !Y_out.write_addr.full() &\n        !Y_out.write_data.full() ) {\n        Y_out.write_addr.try_write(i_req);\n        T tmpv;\n        fifo_Y.try_read(tmpv);\n        Y_out.write_data.try_write(tmpv);\n        ++i_req;\n    }\n    uint8_t n_resp;\n    if (Y_out.write_resp.try_read(n_resp)) {\n        i_resp += R(n_resp) + 1;\n    }\n}\nvoid rdwr_vec(uint64_t  vec_p,\n              tapa::istream<InstRdWr> & q_inst,\n              tapa::istream<double_v8> & q_din,\n              tapa::ostream<double_v8> & q_dout,\n              tapa::ostream<bool> & q_response\n              ) ;\ntemplate <typename data_t>\ninline void q2q(tapa::istream<data_t> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty() & !qout.full()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void clearq(tapa::istream<data_t> & qin,\n                   const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void q2q(tapa::istreams<data_t, 2> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite,\n                const int idx) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin[idx].empty() & !qout.full()) {\n            data_t tmp;\n            qin[idx].try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void qq2qq(tapa::istream<data_t> & qin_pe,\n                  tapa::ostreams<data_t, 2> & qout_mem,\n                  tapa::istreams<data_t, 2> & qin_mem,\n                  tapa::ostream<data_t> & qout_qe,\n                  const int num_ite,\n                  const int idx) {\n#pragma HLS inline\nqq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin_pe.empty() & !qout_mem[idx].full()) {\n            data_t tmp;\n            qin_pe.try_read(tmp);\n            qout_mem[idx].try_write(tmp);\n            ++i;\n        }\n        if (!qin_mem[1 - idx].empty() & !qout_qe.full()) {\n            data_t tmp;\n            qin_mem[1 - idx].try_read(tmp);\n            qout_qe.try_write(tmp);\n        }\n    }\n}\nvoid term_signal_router(tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_to_rdA,\n                        tapa::ostream<bool> & q_to_edgepointer,\n                        tapa::ostream<bool> & q_to_abiter,\n                        tapa::ostream<bool> & q_to_ctrlmem,\n                        tapa::ostream<bool> & q_to_mux\n                        ) ;\nvoid read_edge_list_ptr(const int num_ite,\n                        const int M,\n                        const int rp_time, //P_N,\n                        uint64_t  edge_list_ptr,\n                        tapa::ostream<int> & PE_inst,\n                        tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_gbc_out\n                        ) ;\nvoid read_vec(const int rp_time, //P_N\n              const int M, //K,\n              tapa::async_mmap<double_v8> & vec_X,\n              tapa::ostream<double_v8> & fifo_X\n              ) {\n    //const int rp_time = (P_N == 0)? 1 : P_N;\n    const int num_ite_X = (M + 7) >> 3;\nl_rp:\n    for(int rp = 0; rp < rp_time; rp++) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n    rd_X:\n        for(int i_req = 0, i_resp = 0; i_resp < num_ite_X;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n            async_read(vec_X,\n                       fifo_X,\n                       num_ite_X,\n                       i_req, i_resp);\n        }\n    }\n}\nvoid read_A(const int rp_time, //P_N,\n            const int A_len,\n            uint64_t  A,\n            tapa::ostream<ap_uint<512>> & fifo_A,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid PEG_Xvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<ap_uint<512>> & fifo_A,\n              tapa::istream<double_v8> & fifo_X_in,\n              tapa::ostream<int> & fifo_inst_out,\n              tapa::ostream<double_v8> & fifo_X_out,\n              // to PEG_Yvec\n              tapa::ostream<int> & fifo_inst_out_to_Yvec,\n              tapa::ostream<MultXVec> & fifo_aXvec,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out,\n              tapa::ostream<bool> & q_gbc_out_Y\n              ) ;\nvoid PEG_Yvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<MultXVec> & fifo_aXvec,\n              tapa::ostream<double> & fifo_Y_out,\n              tapa::istream<bool> & q_gbc\n              ) ;\nvoid Arbiter_Y(const int rp_time, //P_N,\n               const int M,\n               tapa::istreams<double, NUM_CH_SPARSE_div_8> & fifo_in, // 2 = 16 / 8\n               tapa::ostream<double> & fifo_out,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\nvoid Merger_Y(tapa::istreams<double, 8> & fifo_in,\n              tapa::ostreams<double_v8, 2> & fifo_out) ;\ntemplate <typename data_t>\ninline void bh(tapa::istream<data_t> & q) {\n#pragma HLS inline\n    for (;;) {\n#pragma HLS pipeline II=1\n        data_t tmp; q.try_read(tmp);\n    }\n}\nvoid black_hole_int(tapa::istream<int> & fifo_in) ;\nvoid black_hole_double_v8(tapa::istream<double_v8> & fifo_in) ;\nvoid black_hole_bool(tapa::istream<bool> & fifo_in) ;\nvoid ctrl_P(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time, //P_N\n            const int M, //K,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_spmv,\n            tapa::ostream<double_v8> & q_dotp,\n            //tapa::ostream<double_v8> & q_updtx,\n            tapa::ostream<double_v8> & q_updtp,\n            tapa::istream<double_v8> & q_updated,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_AP(tapa::istream<double_v8> & qm_din,\n             tapa::ostream<double_v8> & qm_dout,\n             const int rp_time,\n             const int M,\n             tapa::ostream<InstRdWr> & q_inst,\n             tapa::ostream<double_v8> & q_updr,\n             tapa::istream<double_v8> & q_pe,\n             tapa::istream<bool> & q_res,\n             tapa::istream<bool> & q_gbc,\n             tapa::ostream<bool> & q_gbc_out\n             ) ;\nvoid ctrl_X(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_oldx,\n            tapa::istream<double_v8> & q_newx,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_R(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & qr_to_pe,\n            tapa::istream<double_v8> & qr_from_pe,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid read_digA(uint64_t  vec_mem,\n               const int rp_time, //P_N\n               const int M, //K,\n               tapa::ostream<double_v8> & q_dout,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n/*  computation modules  */\n//M2: alpha = rzold / (p' * Ap)\nvoid dot_alpha(const int rp_time,\n               const int M,\n               //const unsigned long rz0,\n               tapa::istream<double> & qrz,\n               tapa::istream<double_v8> & q1,\n               tapa::istream<double_v8> & q2,\n               tapa::ostreams<double, 2> & q3,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M end: res = r' * r\nvoid dot_res(const int rp_time,\n             const int M,\n             const double th_termination,\n             tapa::istream<double_v8> & q1,\n             tapa::ostream<ResTerm> & q2,\n             tapa::ostream<bool> & q_termination\n             ) ;\n//M6: rznew = r' * z\nvoid dot_rznew(const int rp_time,\n               const int M,\n               tapa::istream<double_v8> & qr,\n               tapa::istream<double_v8> & qz,\n               tapa::ostream<double_v8> & qr_out,\n               tapa::ostreams<double, 2> & qrz,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M3: x = x + alpha * p\nvoid updt_x(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qx,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M7: p = z + (rznew/rzold) * p\nvoid updt_p(const int rp_time,\n            const int M,\n            //const unsigned long rz0,\n            tapa::istream<double> & qrznew,\n            tapa::istream<double_v8> & qz,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qp2m3,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M4: r = r - alpha * Ap\nvoid updt_r(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qr,\n            tapa::istream<double_v8> & qap,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) {\n\n\n#pragma HLS disaggregate variable = qalpha\n#pragma HLS interface ap_fifo port = qalpha._\n#pragma HLS aggregate variable = qalpha._ bit\n#pragma HLS interface ap_fifo port = qalpha._peek\n#pragma HLS aggregate variable = qalpha._peek bit\nvoid(qalpha._.empty());\nvoid(qalpha._peek.empty());\n\n#pragma HLS disaggregate variable = qr\n#pragma HLS interface ap_fifo port = qr._\n#pragma HLS aggregate variable = qr._ bit\n#pragma HLS interface ap_fifo port = qr._peek\n#pragma HLS aggregate variable = qr._peek bit\nvoid(qr._.empty());\nvoid(qr._peek.empty());\n\n#pragma HLS disaggregate variable = qap\n#pragma HLS interface ap_fifo port = qap._\n#pragma HLS aggregate variable = qap._ bit\n#pragma HLS interface ap_fifo port = qap._peek\n#pragma HLS aggregate variable = qap._peek bit\nvoid(qap._.empty());\nvoid(qap._peek.empty());\n\n#pragma HLS disaggregate variable = qout\n#pragma HLS interface ap_fifo port = qout._\n#pragma HLS aggregate variable = qout._ bit\nvoid(qout._.full());\n\n#pragma HLS disaggregate variable = q_gbc\n#pragma HLS interface ap_fifo port = q_gbc._\n#pragma HLS aggregate variable = q_gbc._ bit\n#pragma HLS interface ap_fifo port = q_gbc._peek\n#pragma HLS aggregate variable = q_gbc._peek bit\nvoid(q_gbc._.empty());\nvoid(q_gbc._peek.empty());\n\n#pragma HLS disaggregate variable = q_gbc_out\n#pragma HLS interface ap_fifo port = q_gbc_out._\n#pragma HLS aggregate variable = q_gbc_out._ bit\nvoid(q_gbc_out._.full());\n\n    //InstCmp inst = {(M + 7) >> 3, alpha, 0};\n    const int num_ite = (M + 7) >> 3;\n    double alpha = 0.0;\n    bool term_flag = false;\nl_rp:\n    for(int rp = -2; !term_flag & (rp < rp_time * 2); rp++) {\n#pragma HLS loop_flatten off\n        if ((rp &0x1) == 0) {\n            alpha = qalpha.read();\n        }\n        //qout = x + alpha .* p;\n    cc:\n        for (int i = 0; i < num_ite;) {\n#pragma HLS pipeline II=1\n            if (!qr.empty() & !qap.empty()) {\n                double_v8 tmpr; qr.try_read(tmpr);\n                double_v8 tmpap; qap.try_read(tmpap);\n                qout.write(tmpr - alpha * tmpap);\n                ++i;\n            }\n        }\n        ap_wait();\n        if ((rp &0x1) == 1) {\n            term_flag = q_gbc.read();\n            q_gbc_out.write(term_flag);\n        }\n    }\n    //cout << \"@@@@ exit updt_r\\n\";\n}\n//M5: z = diagA \\ r\nvoid left_div(const int rp_time,\n              const int M,\n              tapa::istream<double_v8> & qr,\n              tapa::istream<double_v8> & qdiagA,\n              tapa::ostreams<double_v8, 2> & qz,\n              tapa::ostream<double_v8> & qr_m6,\n              tapa::ostream<double_v8> & qrmem,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out\n              ) ;\nvoid wr_r(const int rp_time,\n          uint64_t  vec_r,\n          tapa::istream<ResTerm> & q_din\n          ) ;\nvoid duplicator(tapa::istream<double_v8> & q_in,\n                tapa::ostream<double_v8> & q_out1,\n                tapa::ostream<double_v8> & q_out2\n                ) ;\nvoid vecp_mux(const int rp_time,\n              const int M,\n              tapa::istream<bool> & q_gbc,\n              tapa::istream<double_v8> & q_in1,\n              tapa::istream<double_v8> & q_in2,\n              tapa::ostream<double_v8> & q_out\n              ) ;\nvoid Callipepla(uint64_t  edge_list_ptr,\n                uint64_t edge_list_ch_0, uint64_t edge_list_ch_1, uint64_t edge_list_ch_2, uint64_t edge_list_ch_3, uint64_t edge_list_ch_4, uint64_t edge_list_ch_5, uint64_t edge_list_ch_6, uint64_t edge_list_ch_7, uint64_t edge_list_ch_8, uint64_t edge_list_ch_9, uint64_t edge_list_ch_10, uint64_t edge_list_ch_11, uint64_t edge_list_ch_12, uint64_t edge_list_ch_13, uint64_t edge_list_ch_14, uint64_t edge_list_ch_15,\n                uint64_t vec_x_0, uint64_t vec_x_1,\n                uint64_t vec_p_0, uint64_t vec_p_1,\n                uint64_t  vec_Ap,\n                uint64_t vec_r_0, uint64_t vec_r_1,\n                uint64_t  vec_digA,\n                uint64_t  vec_res,\n                const int NUM_ITE,\n                const int NUM_A_LEN,\n                const int M,\n                const int rp_time,\n                const double th_termination\n                ) ;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "updt_x": {
            "code": "\n\n #include <ap_int.h>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cassert>\n\n\n #include \"ap_utils.h\"\n\n#include <tapa.h>\n\n\n\n #include <ap_int.h>\n\n#include <tapa.h>\nconstexpr int NUM_CH_SPARSE = 16;\nconstexpr int X_PARTITION_FACTOR = 4; // BRAMs = 512 / 16 / 2 = 16 -> factor = 16 / (64 / 16)\nconstexpr int WINDOW_SIZE = X_PARTITION_FACTOR * 1024;\nconstexpr int DEP_DIST_LOAD_STORE = 7;\nconstexpr int URAM_DEPTH = 3 * 4096;\n// ch16: 3 * 4096 * 16 * 8 = 1,572,864\nusing double_v8 = tapa::vec_t<double, 8>;\nvoid Callipepla(tapa::mmap<int> edge_list_ptr,\n                tapa::mmaps<ap_uint<512>, NUM_CH_SPARSE> edge_list_ch,\n                tapa::mmaps<double_v8, 2> vec_x,\n                tapa::mmaps<double_v8, 2> vec_p,\n                tapa::mmap<double_v8> vec_Ap,\n                tapa::mmaps<double_v8, 2> vec_r,\n                tapa::mmap<double_v8> vec_digA,\n                tapa::mmap<double> vec_res,\n                const int NUM_ITE, const int NUM_A_LEN, const int M,\n                const int rp_time,\n                const double th_termination\n                );\n\nconstexpr int FIFO_DEPTH = 2;\nconstexpr int FIFO_DEPTH_M6 = 50;\nconst int NUM_CH_SPARSE_div_8 = NUM_CH_SPARSE / 8;\nconst int NUM_CH_SPARSE_mult_8 = NUM_CH_SPARSE * 8;\nconst int WINDOW_SIZE_div_8 = WINDOW_SIZE / 8;\nstruct MultXVec {\n    tapa::vec_t<ap_uint<18>, 8> row;\n    double_v8 axv;\n};\nstruct InstRdWr {\n    bool rd;\n    bool wr;\n    //bool require_response;\n    int base_addr;\n    int len;\n};\nstruct InstVCtrl {\n    bool rd;\n    bool wr;\n    int base_addr;\n    int len;\n    ap_uint<3> q_rd_idx;\n    //ap_uint<3> q_wr_idx;\n};\nstruct InstCmp {\n    int len;\n    double alpha;\n    ap_uint<3> q_idx;\n};\nstruct ResTerm {\n    double res;\n    bool term;\n};\ntemplate <typename T, typename R>\ninline void async_read(tapa::async_mmap<T> & A,\n                       tapa::ostream<T> & fifo_A,\n                       const R i_end_addr,\n                       R & i_req,\n                       R & i_resp) {\n#pragma HLS inline\n    if ((i_req < i_end_addr) &\n        !A.read_addr.full()) {\n        A.read_addr.try_write(i_req);\n        ++i_req;\n    }\n    if (!fifo_A.full() & !A.read_data.empty()) {\n        T tmp;\n        A.read_data.try_read(tmp);\n        fifo_A.try_write(tmp);\n        ++i_resp;\n    }\n}\ntemplate <typename T, typename R>\ninline void async_write(tapa::async_mmap<T> & Y_out,\n                        tapa::istream<T> & fifo_Y,\n                        const R num_ite_Y,\n                        R & i_req,\n                        R & i_resp\n                        ) {\n#pragma HLS inline\n    if ((i_req < num_ite_Y) &\n        !fifo_Y.empty() &\n        !Y_out.write_addr.full() &\n        !Y_out.write_data.full() ) {\n        Y_out.write_addr.try_write(i_req);\n        T tmpv;\n        fifo_Y.try_read(tmpv);\n        Y_out.write_data.try_write(tmpv);\n        ++i_req;\n    }\n    uint8_t n_resp;\n    if (Y_out.write_resp.try_read(n_resp)) {\n        i_resp += R(n_resp) + 1;\n    }\n}\nvoid rdwr_vec(uint64_t  vec_p,\n              tapa::istream<InstRdWr> & q_inst,\n              tapa::istream<double_v8> & q_din,\n              tapa::ostream<double_v8> & q_dout,\n              tapa::ostream<bool> & q_response\n              ) ;\ntemplate <typename data_t>\ninline void q2q(tapa::istream<data_t> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty() & !qout.full()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void clearq(tapa::istream<data_t> & qin,\n                   const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void q2q(tapa::istreams<data_t, 2> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite,\n                const int idx) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin[idx].empty() & !qout.full()) {\n            data_t tmp;\n            qin[idx].try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void qq2qq(tapa::istream<data_t> & qin_pe,\n                  tapa::ostreams<data_t, 2> & qout_mem,\n                  tapa::istreams<data_t, 2> & qin_mem,\n                  tapa::ostream<data_t> & qout_qe,\n                  const int num_ite,\n                  const int idx) {\n#pragma HLS inline\nqq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin_pe.empty() & !qout_mem[idx].full()) {\n            data_t tmp;\n            qin_pe.try_read(tmp);\n            qout_mem[idx].try_write(tmp);\n            ++i;\n        }\n        if (!qin_mem[1 - idx].empty() & !qout_qe.full()) {\n            data_t tmp;\n            qin_mem[1 - idx].try_read(tmp);\n            qout_qe.try_write(tmp);\n        }\n    }\n}\nvoid term_signal_router(tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_to_rdA,\n                        tapa::ostream<bool> & q_to_edgepointer,\n                        tapa::ostream<bool> & q_to_abiter,\n                        tapa::ostream<bool> & q_to_ctrlmem,\n                        tapa::ostream<bool> & q_to_mux\n                        ) ;\nvoid read_edge_list_ptr(const int num_ite,\n                        const int M,\n                        const int rp_time, //P_N,\n                        uint64_t  edge_list_ptr,\n                        tapa::ostream<int> & PE_inst,\n                        tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_gbc_out\n                        ) ;\nvoid read_vec(const int rp_time, //P_N\n              const int M, //K,\n              tapa::async_mmap<double_v8> & vec_X,\n              tapa::ostream<double_v8> & fifo_X\n              ) {\n    //const int rp_time = (P_N == 0)? 1 : P_N;\n    const int num_ite_X = (M + 7) >> 3;\nl_rp:\n    for(int rp = 0; rp < rp_time; rp++) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n    rd_X:\n        for(int i_req = 0, i_resp = 0; i_resp < num_ite_X;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n            async_read(vec_X,\n                       fifo_X,\n                       num_ite_X,\n                       i_req, i_resp);\n        }\n    }\n}\nvoid read_A(const int rp_time, //P_N,\n            const int A_len,\n            uint64_t  A,\n            tapa::ostream<ap_uint<512>> & fifo_A,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid PEG_Xvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<ap_uint<512>> & fifo_A,\n              tapa::istream<double_v8> & fifo_X_in,\n              tapa::ostream<int> & fifo_inst_out,\n              tapa::ostream<double_v8> & fifo_X_out,\n              // to PEG_Yvec\n              tapa::ostream<int> & fifo_inst_out_to_Yvec,\n              tapa::ostream<MultXVec> & fifo_aXvec,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out,\n              tapa::ostream<bool> & q_gbc_out_Y\n              ) ;\nvoid PEG_Yvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<MultXVec> & fifo_aXvec,\n              tapa::ostream<double> & fifo_Y_out,\n              tapa::istream<bool> & q_gbc\n              ) ;\nvoid Arbiter_Y(const int rp_time, //P_N,\n               const int M,\n               tapa::istreams<double, NUM_CH_SPARSE_div_8> & fifo_in, // 2 = 16 / 8\n               tapa::ostream<double> & fifo_out,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\nvoid Merger_Y(tapa::istreams<double, 8> & fifo_in,\n              tapa::ostreams<double_v8, 2> & fifo_out) ;\ntemplate <typename data_t>\ninline void bh(tapa::istream<data_t> & q) {\n#pragma HLS inline\n    for (;;) {\n#pragma HLS pipeline II=1\n        data_t tmp; q.try_read(tmp);\n    }\n}\nvoid black_hole_int(tapa::istream<int> & fifo_in) ;\nvoid black_hole_double_v8(tapa::istream<double_v8> & fifo_in) ;\nvoid black_hole_bool(tapa::istream<bool> & fifo_in) ;\nvoid ctrl_P(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time, //P_N\n            const int M, //K,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_spmv,\n            tapa::ostream<double_v8> & q_dotp,\n            //tapa::ostream<double_v8> & q_updtx,\n            tapa::ostream<double_v8> & q_updtp,\n            tapa::istream<double_v8> & q_updated,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_AP(tapa::istream<double_v8> & qm_din,\n             tapa::ostream<double_v8> & qm_dout,\n             const int rp_time,\n             const int M,\n             tapa::ostream<InstRdWr> & q_inst,\n             tapa::ostream<double_v8> & q_updr,\n             tapa::istream<double_v8> & q_pe,\n             tapa::istream<bool> & q_res,\n             tapa::istream<bool> & q_gbc,\n             tapa::ostream<bool> & q_gbc_out\n             ) ;\nvoid ctrl_X(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_oldx,\n            tapa::istream<double_v8> & q_newx,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_R(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & qr_to_pe,\n            tapa::istream<double_v8> & qr_from_pe,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid read_digA(uint64_t  vec_mem,\n               const int rp_time, //P_N\n               const int M, //K,\n               tapa::ostream<double_v8> & q_dout,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n/*  computation modules  */\n//M2: alpha = rzold / (p' * Ap)\nvoid dot_alpha(const int rp_time,\n               const int M,\n               //const unsigned long rz0,\n               tapa::istream<double> & qrz,\n               tapa::istream<double_v8> & q1,\n               tapa::istream<double_v8> & q2,\n               tapa::ostreams<double, 2> & q3,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M end: res = r' * r\nvoid dot_res(const int rp_time,\n             const int M,\n             const double th_termination,\n             tapa::istream<double_v8> & q1,\n             tapa::ostream<ResTerm> & q2,\n             tapa::ostream<bool> & q_termination\n             ) ;\n//M6: rznew = r' * z\nvoid dot_rznew(const int rp_time,\n               const int M,\n               tapa::istream<double_v8> & qr,\n               tapa::istream<double_v8> & qz,\n               tapa::ostream<double_v8> & qr_out,\n               tapa::ostreams<double, 2> & qrz,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M3: x = x + alpha * p\nvoid updt_x(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qx,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) {\n\n\n#pragma HLS disaggregate variable = qalpha\n#pragma HLS interface ap_fifo port = qalpha._\n#pragma HLS aggregate variable = qalpha._ bit\n#pragma HLS interface ap_fifo port = qalpha._peek\n#pragma HLS aggregate variable = qalpha._peek bit\nvoid(qalpha._.empty());\nvoid(qalpha._peek.empty());\n\n#pragma HLS disaggregate variable = qx\n#pragma HLS interface ap_fifo port = qx._\n#pragma HLS aggregate variable = qx._ bit\n#pragma HLS interface ap_fifo port = qx._peek\n#pragma HLS aggregate variable = qx._peek bit\nvoid(qx._.empty());\nvoid(qx._peek.empty());\n\n#pragma HLS disaggregate variable = qp\n#pragma HLS interface ap_fifo port = qp._\n#pragma HLS aggregate variable = qp._ bit\n#pragma HLS interface ap_fifo port = qp._peek\n#pragma HLS aggregate variable = qp._peek bit\nvoid(qp._.empty());\nvoid(qp._peek.empty());\n\n#pragma HLS disaggregate variable = qout\n#pragma HLS interface ap_fifo port = qout._\n#pragma HLS aggregate variable = qout._ bit\nvoid(qout._.full());\n\n#pragma HLS disaggregate variable = q_gbc\n#pragma HLS interface ap_fifo port = q_gbc._\n#pragma HLS aggregate variable = q_gbc._ bit\n#pragma HLS interface ap_fifo port = q_gbc._peek\n#pragma HLS aggregate variable = q_gbc._peek bit\nvoid(q_gbc._.empty());\nvoid(q_gbc._peek.empty());\n\n    //InstCmp inst = {(M + 7) >> 3, qalpha.read(), 0};\n    const int num_ite = (M + 7) >> 3;\n    bool term_flag = false;\nl_rp:\n    for(int rp = -1; !term_flag & (rp < rp_time); rp++) {\n#pragma HLS loop_flatten off\n        const double alpha = qalpha.read();\n        //qout = x + alpha .* p;\n    cc:\n        for (int i = 0; i < num_ite;) {\n#pragma HLS pipeline II=1\n            if (!qx.empty() & !qp.empty()) {\n                double_v8 tmpx; qx.try_read(tmpx);\n                double_v8 tmpp; qp.try_read(tmpp);\n                qout.write(tmpx + alpha * tmpp);\n                ++i;\n            }\n        }\n        ap_wait();\n        term_flag = q_gbc.read();\n        //q_gbc_out.write(term_flag);\n    }\n    //cout << \"@@@ exit updt_x\\n\";\n}\n//M7: p = z + (rznew/rzold) * p\nvoid updt_p(const int rp_time,\n            const int M,\n            //const unsigned long rz0,\n            tapa::istream<double> & qrznew,\n            tapa::istream<double_v8> & qz,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qp2m3,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M4: r = r - alpha * Ap\nvoid updt_r(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qr,\n            tapa::istream<double_v8> & qap,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M5: z = diagA \\ r\nvoid left_div(const int rp_time,\n              const int M,\n              tapa::istream<double_v8> & qr,\n              tapa::istream<double_v8> & qdiagA,\n              tapa::ostreams<double_v8, 2> & qz,\n              tapa::ostream<double_v8> & qr_m6,\n              tapa::ostream<double_v8> & qrmem,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out\n              ) ;\nvoid wr_r(const int rp_time,\n          uint64_t  vec_r,\n          tapa::istream<ResTerm> & q_din\n          ) ;\nvoid duplicator(tapa::istream<double_v8> & q_in,\n                tapa::ostream<double_v8> & q_out1,\n                tapa::ostream<double_v8> & q_out2\n                ) ;\nvoid vecp_mux(const int rp_time,\n              const int M,\n              tapa::istream<bool> & q_gbc,\n              tapa::istream<double_v8> & q_in1,\n              tapa::istream<double_v8> & q_in2,\n              tapa::ostream<double_v8> & q_out\n              ) ;\nvoid Callipepla(uint64_t  edge_list_ptr,\n                uint64_t edge_list_ch_0, uint64_t edge_list_ch_1, uint64_t edge_list_ch_2, uint64_t edge_list_ch_3, uint64_t edge_list_ch_4, uint64_t edge_list_ch_5, uint64_t edge_list_ch_6, uint64_t edge_list_ch_7, uint64_t edge_list_ch_8, uint64_t edge_list_ch_9, uint64_t edge_list_ch_10, uint64_t edge_list_ch_11, uint64_t edge_list_ch_12, uint64_t edge_list_ch_13, uint64_t edge_list_ch_14, uint64_t edge_list_ch_15,\n                uint64_t vec_x_0, uint64_t vec_x_1,\n                uint64_t vec_p_0, uint64_t vec_p_1,\n                uint64_t  vec_Ap,\n                uint64_t vec_r_0, uint64_t vec_r_1,\n                uint64_t  vec_digA,\n                uint64_t  vec_res,\n                const int NUM_ITE,\n                const int NUM_A_LEN,\n                const int M,\n                const int rp_time,\n                const double th_termination\n                ) ;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "vecp_mux": {
            "code": "\n\n #include <ap_int.h>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cassert>\n\n\n #include \"ap_utils.h\"\n\n#include <tapa.h>\n\n\n\n #include <ap_int.h>\n\n#include <tapa.h>\nconstexpr int NUM_CH_SPARSE = 16;\nconstexpr int X_PARTITION_FACTOR = 4; // BRAMs = 512 / 16 / 2 = 16 -> factor = 16 / (64 / 16)\nconstexpr int WINDOW_SIZE = X_PARTITION_FACTOR * 1024;\nconstexpr int DEP_DIST_LOAD_STORE = 7;\nconstexpr int URAM_DEPTH = 3 * 4096;\n// ch16: 3 * 4096 * 16 * 8 = 1,572,864\nusing double_v8 = tapa::vec_t<double, 8>;\nvoid Callipepla(tapa::mmap<int> edge_list_ptr,\n                tapa::mmaps<ap_uint<512>, NUM_CH_SPARSE> edge_list_ch,\n                tapa::mmaps<double_v8, 2> vec_x,\n                tapa::mmaps<double_v8, 2> vec_p,\n                tapa::mmap<double_v8> vec_Ap,\n                tapa::mmaps<double_v8, 2> vec_r,\n                tapa::mmap<double_v8> vec_digA,\n                tapa::mmap<double> vec_res,\n                const int NUM_ITE, const int NUM_A_LEN, const int M,\n                const int rp_time,\n                const double th_termination\n                );\n\nconstexpr int FIFO_DEPTH = 2;\nconstexpr int FIFO_DEPTH_M6 = 50;\nconst int NUM_CH_SPARSE_div_8 = NUM_CH_SPARSE / 8;\nconst int NUM_CH_SPARSE_mult_8 = NUM_CH_SPARSE * 8;\nconst int WINDOW_SIZE_div_8 = WINDOW_SIZE / 8;\nstruct MultXVec {\n    tapa::vec_t<ap_uint<18>, 8> row;\n    double_v8 axv;\n};\nstruct InstRdWr {\n    bool rd;\n    bool wr;\n    //bool require_response;\n    int base_addr;\n    int len;\n};\nstruct InstVCtrl {\n    bool rd;\n    bool wr;\n    int base_addr;\n    int len;\n    ap_uint<3> q_rd_idx;\n    //ap_uint<3> q_wr_idx;\n};\nstruct InstCmp {\n    int len;\n    double alpha;\n    ap_uint<3> q_idx;\n};\nstruct ResTerm {\n    double res;\n    bool term;\n};\ntemplate <typename T, typename R>\ninline void async_read(tapa::async_mmap<T> & A,\n                       tapa::ostream<T> & fifo_A,\n                       const R i_end_addr,\n                       R & i_req,\n                       R & i_resp) {\n#pragma HLS inline\n    if ((i_req < i_end_addr) &\n        !A.read_addr.full()) {\n        A.read_addr.try_write(i_req);\n        ++i_req;\n    }\n    if (!fifo_A.full() & !A.read_data.empty()) {\n        T tmp;\n        A.read_data.try_read(tmp);\n        fifo_A.try_write(tmp);\n        ++i_resp;\n    }\n}\ntemplate <typename T, typename R>\ninline void async_write(tapa::async_mmap<T> & Y_out,\n                        tapa::istream<T> & fifo_Y,\n                        const R num_ite_Y,\n                        R & i_req,\n                        R & i_resp\n                        ) {\n#pragma HLS inline\n    if ((i_req < num_ite_Y) &\n        !fifo_Y.empty() &\n        !Y_out.write_addr.full() &\n        !Y_out.write_data.full() ) {\n        Y_out.write_addr.try_write(i_req);\n        T tmpv;\n        fifo_Y.try_read(tmpv);\n        Y_out.write_data.try_write(tmpv);\n        ++i_req;\n    }\n    uint8_t n_resp;\n    if (Y_out.write_resp.try_read(n_resp)) {\n        i_resp += R(n_resp) + 1;\n    }\n}\nvoid rdwr_vec(uint64_t  vec_p,\n              tapa::istream<InstRdWr> & q_inst,\n              tapa::istream<double_v8> & q_din,\n              tapa::ostream<double_v8> & q_dout,\n              tapa::ostream<bool> & q_response\n              ) ;\ntemplate <typename data_t>\ninline void q2q(tapa::istream<data_t> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty() & !qout.full()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void clearq(tapa::istream<data_t> & qin,\n                   const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void q2q(tapa::istreams<data_t, 2> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite,\n                const int idx) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin[idx].empty() & !qout.full()) {\n            data_t tmp;\n            qin[idx].try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void qq2qq(tapa::istream<data_t> & qin_pe,\n                  tapa::ostreams<data_t, 2> & qout_mem,\n                  tapa::istreams<data_t, 2> & qin_mem,\n                  tapa::ostream<data_t> & qout_qe,\n                  const int num_ite,\n                  const int idx) {\n#pragma HLS inline\nqq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin_pe.empty() & !qout_mem[idx].full()) {\n            data_t tmp;\n            qin_pe.try_read(tmp);\n            qout_mem[idx].try_write(tmp);\n            ++i;\n        }\n        if (!qin_mem[1 - idx].empty() & !qout_qe.full()) {\n            data_t tmp;\n            qin_mem[1 - idx].try_read(tmp);\n            qout_qe.try_write(tmp);\n        }\n    }\n}\nvoid term_signal_router(tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_to_rdA,\n                        tapa::ostream<bool> & q_to_edgepointer,\n                        tapa::ostream<bool> & q_to_abiter,\n                        tapa::ostream<bool> & q_to_ctrlmem,\n                        tapa::ostream<bool> & q_to_mux\n                        ) ;\nvoid read_edge_list_ptr(const int num_ite,\n                        const int M,\n                        const int rp_time, //P_N,\n                        uint64_t  edge_list_ptr,\n                        tapa::ostream<int> & PE_inst,\n                        tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_gbc_out\n                        ) ;\nvoid read_vec(const int rp_time, //P_N\n              const int M, //K,\n              tapa::async_mmap<double_v8> & vec_X,\n              tapa::ostream<double_v8> & fifo_X\n              ) {\n    //const int rp_time = (P_N == 0)? 1 : P_N;\n    const int num_ite_X = (M + 7) >> 3;\nl_rp:\n    for(int rp = 0; rp < rp_time; rp++) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n    rd_X:\n        for(int i_req = 0, i_resp = 0; i_resp < num_ite_X;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n            async_read(vec_X,\n                       fifo_X,\n                       num_ite_X,\n                       i_req, i_resp);\n        }\n    }\n}\nvoid read_A(const int rp_time, //P_N,\n            const int A_len,\n            uint64_t  A,\n            tapa::ostream<ap_uint<512>> & fifo_A,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid PEG_Xvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<ap_uint<512>> & fifo_A,\n              tapa::istream<double_v8> & fifo_X_in,\n              tapa::ostream<int> & fifo_inst_out,\n              tapa::ostream<double_v8> & fifo_X_out,\n              // to PEG_Yvec\n              tapa::ostream<int> & fifo_inst_out_to_Yvec,\n              tapa::ostream<MultXVec> & fifo_aXvec,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out,\n              tapa::ostream<bool> & q_gbc_out_Y\n              ) ;\nvoid PEG_Yvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<MultXVec> & fifo_aXvec,\n              tapa::ostream<double> & fifo_Y_out,\n              tapa::istream<bool> & q_gbc\n              ) ;\nvoid Arbiter_Y(const int rp_time, //P_N,\n               const int M,\n               tapa::istreams<double, NUM_CH_SPARSE_div_8> & fifo_in, // 2 = 16 / 8\n               tapa::ostream<double> & fifo_out,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\nvoid Merger_Y(tapa::istreams<double, 8> & fifo_in,\n              tapa::ostreams<double_v8, 2> & fifo_out) ;\ntemplate <typename data_t>\ninline void bh(tapa::istream<data_t> & q) {\n#pragma HLS inline\n    for (;;) {\n#pragma HLS pipeline II=1\n        data_t tmp; q.try_read(tmp);\n    }\n}\nvoid black_hole_int(tapa::istream<int> & fifo_in) ;\nvoid black_hole_double_v8(tapa::istream<double_v8> & fifo_in) ;\nvoid black_hole_bool(tapa::istream<bool> & fifo_in) ;\nvoid ctrl_P(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time, //P_N\n            const int M, //K,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_spmv,\n            tapa::ostream<double_v8> & q_dotp,\n            //tapa::ostream<double_v8> & q_updtx,\n            tapa::ostream<double_v8> & q_updtp,\n            tapa::istream<double_v8> & q_updated,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_AP(tapa::istream<double_v8> & qm_din,\n             tapa::ostream<double_v8> & qm_dout,\n             const int rp_time,\n             const int M,\n             tapa::ostream<InstRdWr> & q_inst,\n             tapa::ostream<double_v8> & q_updr,\n             tapa::istream<double_v8> & q_pe,\n             tapa::istream<bool> & q_res,\n             tapa::istream<bool> & q_gbc,\n             tapa::ostream<bool> & q_gbc_out\n             ) ;\nvoid ctrl_X(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_oldx,\n            tapa::istream<double_v8> & q_newx,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_R(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & qr_to_pe,\n            tapa::istream<double_v8> & qr_from_pe,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid read_digA(uint64_t  vec_mem,\n               const int rp_time, //P_N\n               const int M, //K,\n               tapa::ostream<double_v8> & q_dout,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n/*  computation modules  */\n//M2: alpha = rzold / (p' * Ap)\nvoid dot_alpha(const int rp_time,\n               const int M,\n               //const unsigned long rz0,\n               tapa::istream<double> & qrz,\n               tapa::istream<double_v8> & q1,\n               tapa::istream<double_v8> & q2,\n               tapa::ostreams<double, 2> & q3,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M end: res = r' * r\nvoid dot_res(const int rp_time,\n             const int M,\n             const double th_termination,\n             tapa::istream<double_v8> & q1,\n             tapa::ostream<ResTerm> & q2,\n             tapa::ostream<bool> & q_termination\n             ) ;\n//M6: rznew = r' * z\nvoid dot_rznew(const int rp_time,\n               const int M,\n               tapa::istream<double_v8> & qr,\n               tapa::istream<double_v8> & qz,\n               tapa::ostream<double_v8> & qr_out,\n               tapa::ostreams<double, 2> & qrz,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M3: x = x + alpha * p\nvoid updt_x(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qx,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M7: p = z + (rznew/rzold) * p\nvoid updt_p(const int rp_time,\n            const int M,\n            //const unsigned long rz0,\n            tapa::istream<double> & qrznew,\n            tapa::istream<double_v8> & qz,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qp2m3,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M4: r = r - alpha * Ap\nvoid updt_r(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qr,\n            tapa::istream<double_v8> & qap,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M5: z = diagA \\ r\nvoid left_div(const int rp_time,\n              const int M,\n              tapa::istream<double_v8> & qr,\n              tapa::istream<double_v8> & qdiagA,\n              tapa::ostreams<double_v8, 2> & qz,\n              tapa::ostream<double_v8> & qr_m6,\n              tapa::ostream<double_v8> & qrmem,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out\n              ) ;\nvoid wr_r(const int rp_time,\n          uint64_t  vec_r,\n          tapa::istream<ResTerm> & q_din\n          ) ;\nvoid duplicator(tapa::istream<double_v8> & q_in,\n                tapa::ostream<double_v8> & q_out1,\n                tapa::ostream<double_v8> & q_out2\n                ) ;\nvoid vecp_mux(const int rp_time,\n              const int M,\n              tapa::istream<bool> & q_gbc,\n              tapa::istream<double_v8> & q_in1,\n              tapa::istream<double_v8> & q_in2,\n              tapa::ostream<double_v8> & q_out\n              ) {\n\n\n#pragma HLS disaggregate variable = q_gbc\n#pragma HLS interface ap_fifo port = q_gbc._\n#pragma HLS aggregate variable = q_gbc._ bit\n#pragma HLS interface ap_fifo port = q_gbc._peek\n#pragma HLS aggregate variable = q_gbc._peek bit\nvoid(q_gbc._.empty());\nvoid(q_gbc._peek.empty());\n\n#pragma HLS disaggregate variable = q_in1\n#pragma HLS interface ap_fifo port = q_in1._\n#pragma HLS aggregate variable = q_in1._ bit\n#pragma HLS interface ap_fifo port = q_in1._peek\n#pragma HLS aggregate variable = q_in1._peek bit\nvoid(q_in1._.empty());\nvoid(q_in1._peek.empty());\n\n#pragma HLS disaggregate variable = q_in2\n#pragma HLS interface ap_fifo port = q_in2._\n#pragma HLS aggregate variable = q_in2._ bit\n#pragma HLS interface ap_fifo port = q_in2._peek\n#pragma HLS aggregate variable = q_in2._peek bit\nvoid(q_in2._.empty());\nvoid(q_in2._peek.empty());\n\n#pragma HLS disaggregate variable = q_out\n#pragma HLS interface ap_fifo port = q_out._\n#pragma HLS aggregate variable = q_out._ bit\nvoid(q_out._.full());\n\n    const int num_ite = (M + 7) >> 3;\n    bool term_flag = false;\n    // deliver p form memory at ite 0\n    q2q(q_in1,\n        q_out,\n        num_ite);\n    for (int rp = -1; !term_flag & (rp < rp_time); rp++) {\n#pragma HLS loop_flatten off\n        term_flag = q_gbc.read();\n        if (term_flag | (rp == rp_time - 1)) {\n            clearq(q_in2, num_ite);\n        } else {\n            q2q(q_in2,\n                q_out,\n                num_ite);\n        }\n    }\n}\nvoid Callipepla(uint64_t  edge_list_ptr,\n                uint64_t edge_list_ch_0, uint64_t edge_list_ch_1, uint64_t edge_list_ch_2, uint64_t edge_list_ch_3, uint64_t edge_list_ch_4, uint64_t edge_list_ch_5, uint64_t edge_list_ch_6, uint64_t edge_list_ch_7, uint64_t edge_list_ch_8, uint64_t edge_list_ch_9, uint64_t edge_list_ch_10, uint64_t edge_list_ch_11, uint64_t edge_list_ch_12, uint64_t edge_list_ch_13, uint64_t edge_list_ch_14, uint64_t edge_list_ch_15,\n                uint64_t vec_x_0, uint64_t vec_x_1,\n                uint64_t vec_p_0, uint64_t vec_p_1,\n                uint64_t  vec_Ap,\n                uint64_t vec_r_0, uint64_t vec_r_1,\n                uint64_t  vec_digA,\n                uint64_t  vec_res,\n                const int NUM_ITE,\n                const int NUM_A_LEN,\n                const int M,\n                const int rp_time,\n                const double th_termination\n                ) ;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        },
        "wr_r": {
            "code": "\n\n #include <ap_int.h>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cassert>\n\n\n #include \"ap_utils.h\"\n\n#include <tapa.h>\n\n\n\n #include <ap_int.h>\n\n#include <tapa.h>\nconstexpr int NUM_CH_SPARSE = 16;\nconstexpr int X_PARTITION_FACTOR = 4; // BRAMs = 512 / 16 / 2 = 16 -> factor = 16 / (64 / 16)\nconstexpr int WINDOW_SIZE = X_PARTITION_FACTOR * 1024;\nconstexpr int DEP_DIST_LOAD_STORE = 7;\nconstexpr int URAM_DEPTH = 3 * 4096;\n// ch16: 3 * 4096 * 16 * 8 = 1,572,864\nusing double_v8 = tapa::vec_t<double, 8>;\nvoid Callipepla(tapa::mmap<int> edge_list_ptr,\n                tapa::mmaps<ap_uint<512>, NUM_CH_SPARSE> edge_list_ch,\n                tapa::mmaps<double_v8, 2> vec_x,\n                tapa::mmaps<double_v8, 2> vec_p,\n                tapa::mmap<double_v8> vec_Ap,\n                tapa::mmaps<double_v8, 2> vec_r,\n                tapa::mmap<double_v8> vec_digA,\n                tapa::mmap<double> vec_res,\n                const int NUM_ITE, const int NUM_A_LEN, const int M,\n                const int rp_time,\n                const double th_termination\n                );\n\nconstexpr int FIFO_DEPTH = 2;\nconstexpr int FIFO_DEPTH_M6 = 50;\nconst int NUM_CH_SPARSE_div_8 = NUM_CH_SPARSE / 8;\nconst int NUM_CH_SPARSE_mult_8 = NUM_CH_SPARSE * 8;\nconst int WINDOW_SIZE_div_8 = WINDOW_SIZE / 8;\nstruct MultXVec {\n    tapa::vec_t<ap_uint<18>, 8> row;\n    double_v8 axv;\n};\nstruct InstRdWr {\n    bool rd;\n    bool wr;\n    //bool require_response;\n    int base_addr;\n    int len;\n};\nstruct InstVCtrl {\n    bool rd;\n    bool wr;\n    int base_addr;\n    int len;\n    ap_uint<3> q_rd_idx;\n    //ap_uint<3> q_wr_idx;\n};\nstruct InstCmp {\n    int len;\n    double alpha;\n    ap_uint<3> q_idx;\n};\nstruct ResTerm {\n    double res;\n    bool term;\n};\ntemplate <typename T, typename R>\ninline void async_read(tapa::async_mmap<T> & A,\n                       tapa::ostream<T> & fifo_A,\n                       const R i_end_addr,\n                       R & i_req,\n                       R & i_resp) {\n#pragma HLS inline\n    if ((i_req < i_end_addr) &\n        !A.read_addr.full()) {\n        A.read_addr.try_write(i_req);\n        ++i_req;\n    }\n    if (!fifo_A.full() & !A.read_data.empty()) {\n        T tmp;\n        A.read_data.try_read(tmp);\n        fifo_A.try_write(tmp);\n        ++i_resp;\n    }\n}\ntemplate <typename T, typename R>\ninline void async_write(tapa::async_mmap<T> & Y_out,\n                        tapa::istream<T> & fifo_Y,\n                        const R num_ite_Y,\n                        R & i_req,\n                        R & i_resp\n                        ) {\n#pragma HLS inline\n    if ((i_req < num_ite_Y) &\n        !fifo_Y.empty() &\n        !Y_out.write_addr.full() &\n        !Y_out.write_data.full() ) {\n        Y_out.write_addr.try_write(i_req);\n        T tmpv;\n        fifo_Y.try_read(tmpv);\n        Y_out.write_data.try_write(tmpv);\n        ++i_req;\n    }\n    uint8_t n_resp;\n    if (Y_out.write_resp.try_read(n_resp)) {\n        i_resp += R(n_resp) + 1;\n    }\n}\nvoid rdwr_vec(uint64_t  vec_p,\n              tapa::istream<InstRdWr> & q_inst,\n              tapa::istream<double_v8> & q_din,\n              tapa::ostream<double_v8> & q_dout,\n              tapa::ostream<bool> & q_response\n              ) ;\ntemplate <typename data_t>\ninline void q2q(tapa::istream<data_t> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty() & !qout.full()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void clearq(tapa::istream<data_t> & qin,\n                   const int num_ite) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin.empty()) {\n            data_t tmp;\n            qin.try_read(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void q2q(tapa::istreams<data_t, 2> & qin,\n                tapa::ostream<data_t> & qout,\n                const int num_ite,\n                const int idx) {\n#pragma HLS inline\nq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin[idx].empty() & !qout.full()) {\n            data_t tmp;\n            qin[idx].try_read(tmp);\n            qout.try_write(tmp);\n            ++i;\n        }\n    }\n}\ntemplate <typename data_t>\ninline void qq2qq(tapa::istream<data_t> & qin_pe,\n                  tapa::ostreams<data_t, 2> & qout_mem,\n                  tapa::istreams<data_t, 2> & qin_mem,\n                  tapa::ostream<data_t> & qout_qe,\n                  const int num_ite,\n                  const int idx) {\n#pragma HLS inline\nqq:\n    for(int i = 0; i < num_ite;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if (!qin_pe.empty() & !qout_mem[idx].full()) {\n            data_t tmp;\n            qin_pe.try_read(tmp);\n            qout_mem[idx].try_write(tmp);\n            ++i;\n        }\n        if (!qin_mem[1 - idx].empty() & !qout_qe.full()) {\n            data_t tmp;\n            qin_mem[1 - idx].try_read(tmp);\n            qout_qe.try_write(tmp);\n        }\n    }\n}\nvoid term_signal_router(tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_to_rdA,\n                        tapa::ostream<bool> & q_to_edgepointer,\n                        tapa::ostream<bool> & q_to_abiter,\n                        tapa::ostream<bool> & q_to_ctrlmem,\n                        tapa::ostream<bool> & q_to_mux\n                        ) ;\nvoid read_edge_list_ptr(const int num_ite,\n                        const int M,\n                        const int rp_time, //P_N,\n                        uint64_t  edge_list_ptr,\n                        tapa::ostream<int> & PE_inst,\n                        tapa::istream<bool> & q_gbc,\n                        tapa::ostream<bool> & q_gbc_out\n                        ) ;\nvoid read_vec(const int rp_time, //P_N\n              const int M, //K,\n              tapa::async_mmap<double_v8> & vec_X,\n              tapa::ostream<double_v8> & fifo_X\n              ) {\n    //const int rp_time = (P_N == 0)? 1 : P_N;\n    const int num_ite_X = (M + 7) >> 3;\nl_rp:\n    for(int rp = 0; rp < rp_time; rp++) {\n#pragma HLS loop_flatten off\n#pragma HLS loop_tripcount min=1 max=16\n    rd_X:\n        for(int i_req = 0, i_resp = 0; i_resp < num_ite_X;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n            async_read(vec_X,\n                       fifo_X,\n                       num_ite_X,\n                       i_req, i_resp);\n        }\n    }\n}\nvoid read_A(const int rp_time, //P_N,\n            const int A_len,\n            uint64_t  A,\n            tapa::ostream<ap_uint<512>> & fifo_A,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid PEG_Xvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<ap_uint<512>> & fifo_A,\n              tapa::istream<double_v8> & fifo_X_in,\n              tapa::ostream<int> & fifo_inst_out,\n              tapa::ostream<double_v8> & fifo_X_out,\n              // to PEG_Yvec\n              tapa::ostream<int> & fifo_inst_out_to_Yvec,\n              tapa::ostream<MultXVec> & fifo_aXvec,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out,\n              tapa::ostream<bool> & q_gbc_out_Y\n              ) ;\nvoid PEG_Yvec(tapa::istream<int> & fifo_inst_in,\n              tapa::istream<MultXVec> & fifo_aXvec,\n              tapa::ostream<double> & fifo_Y_out,\n              tapa::istream<bool> & q_gbc\n              ) ;\nvoid Arbiter_Y(const int rp_time, //P_N,\n               const int M,\n               tapa::istreams<double, NUM_CH_SPARSE_div_8> & fifo_in, // 2 = 16 / 8\n               tapa::ostream<double> & fifo_out,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\nvoid Merger_Y(tapa::istreams<double, 8> & fifo_in,\n              tapa::ostreams<double_v8, 2> & fifo_out) ;\ntemplate <typename data_t>\ninline void bh(tapa::istream<data_t> & q) {\n#pragma HLS inline\n    for (;;) {\n#pragma HLS pipeline II=1\n        data_t tmp; q.try_read(tmp);\n    }\n}\nvoid black_hole_int(tapa::istream<int> & fifo_in) ;\nvoid black_hole_double_v8(tapa::istream<double_v8> & fifo_in) ;\nvoid black_hole_bool(tapa::istream<bool> & fifo_in) ;\nvoid ctrl_P(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time, //P_N\n            const int M, //K,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_spmv,\n            tapa::ostream<double_v8> & q_dotp,\n            //tapa::ostream<double_v8> & q_updtx,\n            tapa::ostream<double_v8> & q_updtp,\n            tapa::istream<double_v8> & q_updated,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_AP(tapa::istream<double_v8> & qm_din,\n             tapa::ostream<double_v8> & qm_dout,\n             const int rp_time,\n             const int M,\n             tapa::ostream<InstRdWr> & q_inst,\n             tapa::ostream<double_v8> & q_updr,\n             tapa::istream<double_v8> & q_pe,\n             tapa::istream<bool> & q_res,\n             tapa::istream<bool> & q_gbc,\n             tapa::ostream<bool> & q_gbc_out\n             ) ;\nvoid ctrl_X(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & q_oldx,\n            tapa::istream<double_v8> & q_newx,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid ctrl_R(tapa::istreams<double_v8, 2> & qm_din,\n            tapa::ostreams<double_v8, 2> & qm_dout,\n            const int rp_time,\n            const int M,\n            tapa::ostreams<InstRdWr, 2> & q_inst,\n            tapa::ostream<double_v8> & qr_to_pe,\n            tapa::istream<double_v8> & qr_from_pe,\n            tapa::istreams<bool, 2> & q_res,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\nvoid read_digA(uint64_t  vec_mem,\n               const int rp_time, //P_N\n               const int M, //K,\n               tapa::ostream<double_v8> & q_dout,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n/*  computation modules  */\n//M2: alpha = rzold / (p' * Ap)\nvoid dot_alpha(const int rp_time,\n               const int M,\n               //const unsigned long rz0,\n               tapa::istream<double> & qrz,\n               tapa::istream<double_v8> & q1,\n               tapa::istream<double_v8> & q2,\n               tapa::ostreams<double, 2> & q3,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M end: res = r' * r\nvoid dot_res(const int rp_time,\n             const int M,\n             const double th_termination,\n             tapa::istream<double_v8> & q1,\n             tapa::ostream<ResTerm> & q2,\n             tapa::ostream<bool> & q_termination\n             ) ;\n//M6: rznew = r' * z\nvoid dot_rznew(const int rp_time,\n               const int M,\n               tapa::istream<double_v8> & qr,\n               tapa::istream<double_v8> & qz,\n               tapa::ostream<double_v8> & qr_out,\n               tapa::ostreams<double, 2> & qrz,\n               tapa::istream<bool> & q_gbc,\n               tapa::ostream<bool> & q_gbc_out\n               ) ;\n//M3: x = x + alpha * p\nvoid updt_x(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qx,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc\n            //tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M7: p = z + (rznew/rzold) * p\nvoid updt_p(const int rp_time,\n            const int M,\n            //const unsigned long rz0,\n            tapa::istream<double> & qrznew,\n            tapa::istream<double_v8> & qz,\n            tapa::istream<double_v8> & qp,\n            tapa::ostream<double_v8> & qp2m3,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M4: r = r - alpha * Ap\nvoid updt_r(const int rp_time,\n            const int M,\n            tapa::istream<double> & qalpha,\n            tapa::istream<double_v8> & qr,\n            tapa::istream<double_v8> & qap,\n            tapa::ostream<double_v8> & qout,\n            tapa::istream<bool> & q_gbc,\n            tapa::ostream<bool> & q_gbc_out\n            ) ;\n//M5: z = diagA \\ r\nvoid left_div(const int rp_time,\n              const int M,\n              tapa::istream<double_v8> & qr,\n              tapa::istream<double_v8> & qdiagA,\n              tapa::ostreams<double_v8, 2> & qz,\n              tapa::ostream<double_v8> & qr_m6,\n              tapa::ostream<double_v8> & qrmem,\n              tapa::istream<bool> & q_gbc,\n              tapa::ostream<bool> & q_gbc_out\n              ) ;\nvoid wr_r(const int rp_time,\n          tapa::async_mmap<double> & vec_r,\n          tapa::istream<ResTerm> & q_din\n          ) {\n\n#pragma HLS disaggregate variable = vec_r\n#pragma HLS interface ap_fifo port = vec_r.read_addr._\n#pragma HLS aggregate variable = vec_r.read_addr._  bit\n#pragma HLS interface ap_fifo port = vec_r.read_data._\n#pragma HLS aggregate variable = vec_r.read_data._  bit\n#pragma HLS interface ap_fifo port = vec_r.write_addr._\n#pragma HLS aggregate variable = vec_r.write_addr._  bit\n#pragma HLS interface ap_fifo port = vec_r.write_data._\n#pragma HLS aggregate variable = vec_r.write_data._  bit\n#pragma HLS interface ap_fifo port = vec_r.write_resp._\n#pragma HLS aggregate variable = vec_r.write_resp._  bit\n#pragma HLS disaggregate variable = vec_r .read_data\n#pragma HLS interface ap_fifo port = vec_r.read_data._peek\n#pragma HLS aggregate variable = vec_r.read_data._peek bit\n#pragma HLS disaggregate variable = vec_r .write_resp\n#pragma HLS interface ap_fifo port = vec_r.write_resp._peek\n#pragma HLS aggregate variable = vec_r.write_resp._peek bit\nvoid(vec_r.read_addr._.full());\nvoid(vec_r.read_data._.empty());\nvoid(vec_r.read_data._peek.empty());\nvoid(vec_r.write_addr._.full());\nvoid(vec_r.write_data._.full());\nvoid(vec_r.write_resp._.empty());\nvoid(vec_r.write_resp._peek.empty());\n\n#pragma HLS disaggregate variable = q_din\n#pragma HLS interface ap_fifo port = q_din._\n#pragma HLS aggregate variable = q_din._ bit\n#pragma HLS interface ap_fifo port = q_din._peek\n#pragma HLS aggregate variable = q_din._peek bit\nvoid(q_din._.empty());\nvoid(q_din._peek.empty());\n\n    int wr_count = rp_time + 1;\nwr:\n    for (int addr_req = 0, i_resp = 0; i_resp < wr_count;) {\n#pragma HLS loop_tripcount min=1 max=500000\n#pragma HLS pipeline II=1\n        if ((addr_req < wr_count) &\n            !q_din.empty() &\n            !vec_r.write_addr.full() &\n            !vec_r.write_data.full() ) {\n            vec_r.write_addr.try_write(addr_req);\n            ResTerm tmpv;\n            q_din.try_read(tmpv);\n            vec_r.write_data.try_write(tmpv.res);\n            ++addr_req;\n            if (tmpv.term) {wr_count = addr_req;}\n        }\n        uint8_t n_resp;\n        if (vec_r.write_resp.try_read(n_resp)) {\n            i_resp += int(n_resp) + 1;\n        }\n    }\n    //cout << \"$$$$ exit wr_r\\n\";\n}\nvoid duplicator(tapa::istream<double_v8> & q_in,\n                tapa::ostream<double_v8> & q_out1,\n                tapa::ostream<double_v8> & q_out2\n                ) ;\nvoid vecp_mux(const int rp_time,\n              const int M,\n              tapa::istream<bool> & q_gbc,\n              tapa::istream<double_v8> & q_in1,\n              tapa::istream<double_v8> & q_in2,\n              tapa::ostream<double_v8> & q_out\n              ) ;\nvoid Callipepla(uint64_t  edge_list_ptr,\n                uint64_t edge_list_ch_0, uint64_t edge_list_ch_1, uint64_t edge_list_ch_2, uint64_t edge_list_ch_3, uint64_t edge_list_ch_4, uint64_t edge_list_ch_5, uint64_t edge_list_ch_6, uint64_t edge_list_ch_7, uint64_t edge_list_ch_8, uint64_t edge_list_ch_9, uint64_t edge_list_ch_10, uint64_t edge_list_ch_11, uint64_t edge_list_ch_12, uint64_t edge_list_ch_13, uint64_t edge_list_ch_14, uint64_t edge_list_ch_15,\n                uint64_t vec_x_0, uint64_t vec_x_1,\n                uint64_t vec_p_0, uint64_t vec_p_1,\n                uint64_t  vec_Ap,\n                uint64_t vec_r_0, uint64_t vec_r_1,\n                uint64_t  vec_digA,\n                uint64_t  vec_res,\n                const int NUM_ITE,\n                const int NUM_A_LEN,\n                const int M,\n                const int rp_time,\n                const double th_termination\n                ) ;\n",
            "level": "lower",
            "target": "hls",
            "vendor": "xilinx"
        }
    },
    "top": "Callipepla"
}
